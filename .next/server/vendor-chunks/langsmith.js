"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/langsmith";
exports.ids = ["vendor-chunks/langsmith"];
exports.modules = {

/***/ "(rsc)/./node_modules/langsmith/dist/client.js":
/*!***********************************************!*\
  !*** ./node_modules/langsmith/dist/client.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AutoBatchQueue: () => (/* binding */ AutoBatchQueue),\n/* harmony export */   Client: () => (/* binding */ Client),\n/* harmony export */   DEFAULT_BATCH_SIZE_LIMIT_BYTES: () => (/* binding */ DEFAULT_BATCH_SIZE_LIMIT_BYTES),\n/* harmony export */   mergeRuntimeEnvIntoRunCreate: () => (/* binding */ mergeRuntimeEnvIntoRunCreate)\n/* harmony export */ });\n/* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! uuid */ \"(rsc)/./node_modules/uuid/dist/esm-node/v4.js\");\n/* harmony import */ var _utils_async_caller_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils/async_caller.js */ \"(rsc)/./node_modules/langsmith/dist/utils/async_caller.js\");\n/* harmony import */ var _utils_messages_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils/messages.js */ \"(rsc)/./node_modules/langsmith/dist/utils/messages.js\");\n/* harmony import */ var _utils_env_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils/env.js */ \"(rsc)/./node_modules/langsmith/dist/utils/env.js\");\n/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./index.js */ \"(rsc)/./node_modules/langsmith/dist/index.js\");\n/* harmony import */ var _utils_uuid_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./utils/_uuid.js */ \"(rsc)/./node_modules/langsmith/dist/utils/_uuid.js\");\n/* harmony import */ var _utils_warn_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./utils/warn.js */ \"(rsc)/./node_modules/langsmith/dist/utils/warn.js\");\n/* harmony import */ var _utils_prompts_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./utils/prompts.js */ \"(rsc)/./node_modules/langsmith/dist/utils/prompts.js\");\n/* harmony import */ var _utils_error_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./utils/error.js */ \"(rsc)/./node_modules/langsmith/dist/utils/error.js\");\n/* harmony import */ var _singletons_fetch_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./singletons/fetch.js */ \"(rsc)/./node_modules/langsmith/dist/singletons/fetch.js\");\n/* harmony import */ var _utils_fast_safe_stringify_index_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./utils/fast-safe-stringify/index.js */ \"(rsc)/./node_modules/langsmith/dist/utils/fast-safe-stringify/index.js\");\n\n\n\n\n\n\n\n\n\n\n\nfunction mergeRuntimeEnvIntoRunCreate(run) {\n    const runtimeEnv = (0,_utils_env_js__WEBPACK_IMPORTED_MODULE_2__.getRuntimeEnvironment)();\n    const envVars = (0,_utils_env_js__WEBPACK_IMPORTED_MODULE_2__.getLangChainEnvVarsMetadata)();\n    const extra = run.extra ?? {};\n    const metadata = extra.metadata;\n    run.extra = {\n        ...extra,\n        runtime: {\n            ...runtimeEnv,\n            ...extra?.runtime\n        },\n        metadata: {\n            ...envVars,\n            ...envVars.revision_id || run.revision_id ? {\n                revision_id: run.revision_id ?? envVars.revision_id\n            } : {},\n            ...metadata\n        }\n    };\n    return run;\n}\nconst getTracingSamplingRate = (configRate)=>{\n    const samplingRateStr = configRate?.toString() ?? (0,_utils_env_js__WEBPACK_IMPORTED_MODULE_2__.getLangSmithEnvironmentVariable)(\"TRACING_SAMPLING_RATE\");\n    if (samplingRateStr === undefined) {\n        return undefined;\n    }\n    const samplingRate = parseFloat(samplingRateStr);\n    if (samplingRate < 0 || samplingRate > 1) {\n        throw new Error(`LANGSMITH_TRACING_SAMPLING_RATE must be between 0 and 1 if set. Got: ${samplingRate}`);\n    }\n    return samplingRate;\n};\n// utility functions\nconst isLocalhost = (url)=>{\n    const strippedUrl = url.replace(\"http://\", \"\").replace(\"https://\", \"\");\n    const hostname = strippedUrl.split(\"/\")[0].split(\":\")[0];\n    return hostname === \"localhost\" || hostname === \"127.0.0.1\" || hostname === \"::1\";\n};\nasync function toArray(iterable) {\n    const result = [];\n    for await (const item of iterable){\n        result.push(item);\n    }\n    return result;\n}\nfunction trimQuotes(str) {\n    if (str === undefined) {\n        return undefined;\n    }\n    return str.trim().replace(/^\"(.*)\"$/, \"$1\").replace(/^'(.*)'$/, \"$1\");\n}\nconst handle429 = async (response)=>{\n    if (response?.status === 429) {\n        const retryAfter = parseInt(response.headers.get(\"retry-after\") ?? \"30\", 10) * 1000;\n        if (retryAfter > 0) {\n            await new Promise((resolve)=>setTimeout(resolve, retryAfter));\n            // Return directly after calling this check\n            return true;\n        }\n    }\n    // Fall back to existing status checks\n    return false;\n};\nfunction _formatFeedbackScore(score) {\n    if (typeof score === \"number\") {\n        // Truncate at 4 decimal places\n        return Number(score.toFixed(4));\n    }\n    return score;\n}\nclass AutoBatchQueue {\n    constructor(){\n        Object.defineProperty(this, \"items\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: []\n        });\n        Object.defineProperty(this, \"sizeBytes\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 0\n        });\n    }\n    peek() {\n        return this.items[0];\n    }\n    push(item) {\n        let itemPromiseResolve;\n        const itemPromise = new Promise((resolve)=>{\n            // Setting itemPromiseResolve is synchronous with promise creation:\n            // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/Promise\n            itemPromiseResolve = resolve;\n        });\n        const size = (0,_utils_fast_safe_stringify_index_js__WEBPACK_IMPORTED_MODULE_9__.serialize)(item.item).length;\n        this.items.push({\n            action: item.action,\n            payload: item.item,\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            itemPromiseResolve: itemPromiseResolve,\n            itemPromise,\n            size\n        });\n        this.sizeBytes += size;\n        return itemPromise;\n    }\n    pop(upToSizeBytes) {\n        if (upToSizeBytes < 1) {\n            throw new Error(\"Number of bytes to pop off may not be less than 1.\");\n        }\n        const popped = [];\n        let poppedSizeBytes = 0;\n        // Pop items until we reach or exceed the size limit\n        while(poppedSizeBytes + (this.peek()?.size ?? 0) < upToSizeBytes && this.items.length > 0){\n            const item = this.items.shift();\n            if (item) {\n                popped.push(item);\n                poppedSizeBytes += item.size;\n                this.sizeBytes -= item.size;\n            }\n        }\n        // If there is an item on the queue we were unable to pop,\n        // just return it as a single batch.\n        if (popped.length === 0 && this.items.length > 0) {\n            const item = this.items.shift();\n            popped.push(item);\n            poppedSizeBytes += item.size;\n            this.sizeBytes -= item.size;\n        }\n        return [\n            popped.map((it)=>({\n                    action: it.action,\n                    item: it.payload\n                })),\n            ()=>popped.forEach((it)=>it.itemPromiseResolve())\n        ];\n    }\n}\n// 20 MB\nconst DEFAULT_BATCH_SIZE_LIMIT_BYTES = 20971520;\nconst SERVER_INFO_REQUEST_TIMEOUT = 2500;\nclass Client {\n    constructor(config = {}){\n        Object.defineProperty(this, \"apiKey\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"apiUrl\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"webUrl\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"caller\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"batchIngestCaller\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"timeout_ms\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"_tenantId\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: null\n        });\n        Object.defineProperty(this, \"hideInputs\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"hideOutputs\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"tracingSampleRate\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"filteredPostUuids\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: new Set()\n        });\n        Object.defineProperty(this, \"autoBatchTracing\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        Object.defineProperty(this, \"autoBatchQueue\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: new AutoBatchQueue()\n        });\n        Object.defineProperty(this, \"autoBatchTimeout\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"autoBatchAggregationDelayMs\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 250\n        });\n        Object.defineProperty(this, \"batchSizeBytesLimit\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"fetchOptions\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"settings\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"blockOnRootRunFinalization\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: (0,_utils_env_js__WEBPACK_IMPORTED_MODULE_2__.getEnvironmentVariable)(\"LANGSMITH_TRACING_BACKGROUND\") === \"false\"\n        });\n        Object.defineProperty(this, \"traceBatchConcurrency\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 5\n        });\n        Object.defineProperty(this, \"_serverInfo\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        Object.defineProperty(this, \"_getServerInfoPromise\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"manualFlushMode\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: false\n        });\n        const defaultConfig = Client.getDefaultClientConfig();\n        this.tracingSampleRate = getTracingSamplingRate(config.tracingSamplingRate);\n        this.apiUrl = trimQuotes(config.apiUrl ?? defaultConfig.apiUrl) ?? \"\";\n        if (this.apiUrl.endsWith(\"/\")) {\n            this.apiUrl = this.apiUrl.slice(0, -1);\n        }\n        this.apiKey = trimQuotes(config.apiKey ?? defaultConfig.apiKey);\n        this.webUrl = trimQuotes(config.webUrl ?? defaultConfig.webUrl);\n        if (this.webUrl?.endsWith(\"/\")) {\n            this.webUrl = this.webUrl.slice(0, -1);\n        }\n        this.timeout_ms = config.timeout_ms ?? 90000;\n        this.caller = new _utils_async_caller_js__WEBPACK_IMPORTED_MODULE_0__.AsyncCaller(config.callerOptions ?? {});\n        this.traceBatchConcurrency = config.traceBatchConcurrency ?? this.traceBatchConcurrency;\n        if (this.traceBatchConcurrency < 1) {\n            throw new Error(\"Trace batch concurrency must be positive.\");\n        }\n        this.batchIngestCaller = new _utils_async_caller_js__WEBPACK_IMPORTED_MODULE_0__.AsyncCaller({\n            maxRetries: 2,\n            maxConcurrency: this.traceBatchConcurrency,\n            ...config.callerOptions ?? {},\n            onFailedResponseHook: handle429\n        });\n        this.hideInputs = config.hideInputs ?? config.anonymizer ?? defaultConfig.hideInputs;\n        this.hideOutputs = config.hideOutputs ?? config.anonymizer ?? defaultConfig.hideOutputs;\n        this.autoBatchTracing = config.autoBatchTracing ?? this.autoBatchTracing;\n        this.blockOnRootRunFinalization = config.blockOnRootRunFinalization ?? this.blockOnRootRunFinalization;\n        this.batchSizeBytesLimit = config.batchSizeBytesLimit;\n        this.fetchOptions = config.fetchOptions || {};\n        this.manualFlushMode = config.manualFlushMode ?? this.manualFlushMode;\n    }\n    static getDefaultClientConfig() {\n        const apiKey = (0,_utils_env_js__WEBPACK_IMPORTED_MODULE_2__.getLangSmithEnvironmentVariable)(\"API_KEY\");\n        const apiUrl = (0,_utils_env_js__WEBPACK_IMPORTED_MODULE_2__.getLangSmithEnvironmentVariable)(\"ENDPOINT\") ?? \"https://api.smith.langchain.com\";\n        const hideInputs = (0,_utils_env_js__WEBPACK_IMPORTED_MODULE_2__.getLangSmithEnvironmentVariable)(\"HIDE_INPUTS\") === \"true\";\n        const hideOutputs = (0,_utils_env_js__WEBPACK_IMPORTED_MODULE_2__.getLangSmithEnvironmentVariable)(\"HIDE_OUTPUTS\") === \"true\";\n        return {\n            apiUrl: apiUrl,\n            apiKey: apiKey,\n            webUrl: undefined,\n            hideInputs: hideInputs,\n            hideOutputs: hideOutputs\n        };\n    }\n    getHostUrl() {\n        if (this.webUrl) {\n            return this.webUrl;\n        } else if (isLocalhost(this.apiUrl)) {\n            this.webUrl = \"http://localhost:3000\";\n            return this.webUrl;\n        } else if (this.apiUrl.endsWith(\"/api/v1\")) {\n            this.webUrl = this.apiUrl.replace(\"/api/v1\", \"\");\n            return this.webUrl;\n        } else if (this.apiUrl.includes(\"/api\") && !this.apiUrl.split(\".\", 1)[0].endsWith(\"api\")) {\n            this.webUrl = this.apiUrl.replace(\"/api\", \"\");\n            return this.webUrl;\n        } else if (this.apiUrl.split(\".\", 1)[0].includes(\"dev\")) {\n            this.webUrl = \"https://dev.smith.langchain.com\";\n            return this.webUrl;\n        } else if (this.apiUrl.split(\".\", 1)[0].includes(\"eu\")) {\n            this.webUrl = \"https://eu.smith.langchain.com\";\n            return this.webUrl;\n        } else if (this.apiUrl.split(\".\", 1)[0].includes(\"beta\")) {\n            this.webUrl = \"https://beta.smith.langchain.com\";\n            return this.webUrl;\n        } else {\n            this.webUrl = \"https://smith.langchain.com\";\n            return this.webUrl;\n        }\n    }\n    get headers() {\n        const headers = {\n            \"User-Agent\": `langsmith-js/${_index_js__WEBPACK_IMPORTED_MODULE_3__.__version__}`\n        };\n        if (this.apiKey) {\n            headers[\"x-api-key\"] = `${this.apiKey}`;\n        }\n        return headers;\n    }\n    processInputs(inputs) {\n        if (this.hideInputs === false) {\n            return inputs;\n        }\n        if (this.hideInputs === true) {\n            return {};\n        }\n        if (typeof this.hideInputs === \"function\") {\n            return this.hideInputs(inputs);\n        }\n        return inputs;\n    }\n    processOutputs(outputs) {\n        if (this.hideOutputs === false) {\n            return outputs;\n        }\n        if (this.hideOutputs === true) {\n            return {};\n        }\n        if (typeof this.hideOutputs === \"function\") {\n            return this.hideOutputs(outputs);\n        }\n        return outputs;\n    }\n    prepareRunCreateOrUpdateInputs(run) {\n        const runParams = {\n            ...run\n        };\n        if (runParams.inputs !== undefined) {\n            runParams.inputs = this.processInputs(runParams.inputs);\n        }\n        if (runParams.outputs !== undefined) {\n            runParams.outputs = this.processOutputs(runParams.outputs);\n        }\n        return runParams;\n    }\n    async _getResponse(path, queryParams) {\n        const paramsString = queryParams?.toString() ?? \"\";\n        const url = `${this.apiUrl}${path}?${paramsString}`;\n        const response = await this.caller.call((0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_8__._getFetchImplementation)(), url, {\n            method: \"GET\",\n            headers: this.headers,\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions\n        });\n        await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_7__.raiseForStatus)(response, `Failed to fetch ${path}`);\n        return response;\n    }\n    async _get(path, queryParams) {\n        const response = await this._getResponse(path, queryParams);\n        return response.json();\n    }\n    async *_getPaginated(path, queryParams = new URLSearchParams(), transform) {\n        let offset = Number(queryParams.get(\"offset\")) || 0;\n        const limit = Number(queryParams.get(\"limit\")) || 100;\n        while(true){\n            queryParams.set(\"offset\", String(offset));\n            queryParams.set(\"limit\", String(limit));\n            const url = `${this.apiUrl}${path}?${queryParams}`;\n            const response = await this.caller.call((0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_8__._getFetchImplementation)(), url, {\n                method: \"GET\",\n                headers: this.headers,\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions\n            });\n            await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_7__.raiseForStatus)(response, `Failed to fetch ${path}`);\n            const items = transform ? transform(await response.json()) : await response.json();\n            if (items.length === 0) {\n                break;\n            }\n            yield items;\n            if (items.length < limit) {\n                break;\n            }\n            offset += items.length;\n        }\n    }\n    async *_getCursorPaginatedList(path, body = null, requestMethod = \"POST\", dataKey = \"runs\") {\n        const bodyParams = body ? {\n            ...body\n        } : {};\n        while(true){\n            const response = await this.caller.call((0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_8__._getFetchImplementation)(), `${this.apiUrl}${path}`, {\n                method: requestMethod,\n                headers: {\n                    ...this.headers,\n                    \"Content-Type\": \"application/json\"\n                },\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions,\n                body: JSON.stringify(bodyParams)\n            });\n            const responseBody = await response.json();\n            if (!responseBody) {\n                break;\n            }\n            if (!responseBody[dataKey]) {\n                break;\n            }\n            yield responseBody[dataKey];\n            const cursors = responseBody.cursors;\n            if (!cursors) {\n                break;\n            }\n            if (!cursors.next) {\n                break;\n            }\n            bodyParams.cursor = cursors.next;\n        }\n    }\n    // Allows mocking for tests\n    _shouldSample() {\n        if (this.tracingSampleRate === undefined) {\n            return true;\n        }\n        return Math.random() < this.tracingSampleRate;\n    }\n    _filterForSampling(runs, patch = false) {\n        if (this.tracingSampleRate === undefined) {\n            return runs;\n        }\n        if (patch) {\n            const sampled = [];\n            for (const run of runs){\n                if (!this.filteredPostUuids.has(run.id)) {\n                    sampled.push(run);\n                } else {\n                    this.filteredPostUuids.delete(run.id);\n                }\n            }\n            return sampled;\n        } else {\n            // For new runs, sample at trace level to maintain consistency\n            const sampled = [];\n            for (const run of runs){\n                const traceId = run.trace_id ?? run.id;\n                // If we've already made a decision about this trace, follow it\n                if (this.filteredPostUuids.has(traceId)) {\n                    continue;\n                }\n                // For new traces, apply sampling\n                if (run.id === traceId) {\n                    if (this._shouldSample()) {\n                        sampled.push(run);\n                    } else {\n                        this.filteredPostUuids.add(traceId);\n                    }\n                } else {\n                    // Child runs follow their trace's sampling decision\n                    sampled.push(run);\n                }\n            }\n            return sampled;\n        }\n    }\n    async _getBatchSizeLimitBytes() {\n        const serverInfo = await this._ensureServerInfo();\n        return this.batchSizeBytesLimit ?? serverInfo.batch_ingest_config?.size_limit_bytes ?? DEFAULT_BATCH_SIZE_LIMIT_BYTES;\n    }\n    async _getMultiPartSupport() {\n        const serverInfo = await this._ensureServerInfo();\n        return serverInfo.instance_flags?.dataset_examples_multipart_enabled ?? false;\n    }\n    drainAutoBatchQueue(batchSizeLimit) {\n        const promises = [];\n        while(this.autoBatchQueue.items.length > 0){\n            const [batch, done] = this.autoBatchQueue.pop(batchSizeLimit);\n            if (!batch.length) {\n                done();\n                break;\n            }\n            const batchPromise = this._processBatch(batch, done).catch(console.error);\n            promises.push(batchPromise);\n        }\n        return Promise.all(promises);\n    }\n    async _processBatch(batch, done) {\n        if (!batch.length) {\n            done();\n            return;\n        }\n        try {\n            const ingestParams = {\n                runCreates: batch.filter((item)=>item.action === \"create\").map((item)=>item.item),\n                runUpdates: batch.filter((item)=>item.action === \"update\").map((item)=>item.item)\n            };\n            const serverInfo = await this._ensureServerInfo();\n            if (serverInfo?.batch_ingest_config?.use_multipart_endpoint) {\n                await this.multipartIngestRuns(ingestParams);\n            } else {\n                await this.batchIngestRuns(ingestParams);\n            }\n        } finally{\n            done();\n        }\n    }\n    async processRunOperation(item) {\n        clearTimeout(this.autoBatchTimeout);\n        this.autoBatchTimeout = undefined;\n        if (item.action === \"create\") {\n            item.item = mergeRuntimeEnvIntoRunCreate(item.item);\n        }\n        const itemPromise = this.autoBatchQueue.push(item);\n        if (this.manualFlushMode) {\n            // Rely on manual flushing in serverless environments\n            return itemPromise;\n        }\n        const sizeLimitBytes = await this._getBatchSizeLimitBytes();\n        if (this.autoBatchQueue.sizeBytes > sizeLimitBytes) {\n            void this.drainAutoBatchQueue(sizeLimitBytes);\n        }\n        if (this.autoBatchQueue.items.length > 0) {\n            this.autoBatchTimeout = setTimeout(()=>{\n                this.autoBatchTimeout = undefined;\n                void this.drainAutoBatchQueue(sizeLimitBytes);\n            }, this.autoBatchAggregationDelayMs);\n        }\n        return itemPromise;\n    }\n    async _getServerInfo() {\n        const response = await (0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_8__._getFetchImplementation)()(`${this.apiUrl}/info`, {\n            method: \"GET\",\n            headers: {\n                Accept: \"application/json\"\n            },\n            signal: AbortSignal.timeout(SERVER_INFO_REQUEST_TIMEOUT),\n            ...this.fetchOptions\n        });\n        await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_7__.raiseForStatus)(response, \"get server info\");\n        return response.json();\n    }\n    async _ensureServerInfo() {\n        if (this._getServerInfoPromise === undefined) {\n            this._getServerInfoPromise = (async ()=>{\n                if (this._serverInfo === undefined) {\n                    try {\n                        this._serverInfo = await this._getServerInfo();\n                    } catch (e) {\n                        console.warn(`[WARNING]: LangSmith failed to fetch info on supported operations. Falling back to batch operations and default limits.`);\n                    }\n                }\n                return this._serverInfo ?? {};\n            })();\n        }\n        return this._getServerInfoPromise.then((serverInfo)=>{\n            if (this._serverInfo === undefined) {\n                this._getServerInfoPromise = undefined;\n            }\n            return serverInfo;\n        });\n    }\n    async _getSettings() {\n        if (!this.settings) {\n            this.settings = this._get(\"/settings\");\n        }\n        return await this.settings;\n    }\n    /**\n     * Flushes current queued traces.\n     */ async flush() {\n        const sizeLimitBytes = await this._getBatchSizeLimitBytes();\n        await this.drainAutoBatchQueue(sizeLimitBytes);\n    }\n    async createRun(run) {\n        if (!this._filterForSampling([\n            run\n        ]).length) {\n            return;\n        }\n        const headers = {\n            ...this.headers,\n            \"Content-Type\": \"application/json\"\n        };\n        const session_name = run.project_name;\n        delete run.project_name;\n        const runCreate = this.prepareRunCreateOrUpdateInputs({\n            session_name,\n            ...run,\n            start_time: run.start_time ?? Date.now()\n        });\n        if (this.autoBatchTracing && runCreate.trace_id !== undefined && runCreate.dotted_order !== undefined) {\n            void this.processRunOperation({\n                action: \"create\",\n                item: runCreate\n            }).catch(console.error);\n            return;\n        }\n        const mergedRunCreateParam = mergeRuntimeEnvIntoRunCreate(runCreate);\n        const response = await this.caller.call((0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_8__._getFetchImplementation)(), `${this.apiUrl}/runs`, {\n            method: \"POST\",\n            headers,\n            body: (0,_utils_fast_safe_stringify_index_js__WEBPACK_IMPORTED_MODULE_9__.serialize)(mergedRunCreateParam),\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions\n        });\n        await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_7__.raiseForStatus)(response, \"create run\", true);\n    }\n    /**\n     * Batch ingest/upsert multiple runs in the Langsmith system.\n     * @param runs\n     */ async batchIngestRuns({ runCreates, runUpdates }) {\n        if (runCreates === undefined && runUpdates === undefined) {\n            return;\n        }\n        let preparedCreateParams = runCreates?.map((create)=>this.prepareRunCreateOrUpdateInputs(create)) ?? [];\n        let preparedUpdateParams = runUpdates?.map((update)=>this.prepareRunCreateOrUpdateInputs(update)) ?? [];\n        if (preparedCreateParams.length > 0 && preparedUpdateParams.length > 0) {\n            const createById = preparedCreateParams.reduce((params, run)=>{\n                if (!run.id) {\n                    return params;\n                }\n                params[run.id] = run;\n                return params;\n            }, {});\n            const standaloneUpdates = [];\n            for (const updateParam of preparedUpdateParams){\n                if (updateParam.id !== undefined && createById[updateParam.id]) {\n                    createById[updateParam.id] = {\n                        ...createById[updateParam.id],\n                        ...updateParam\n                    };\n                } else {\n                    standaloneUpdates.push(updateParam);\n                }\n            }\n            preparedCreateParams = Object.values(createById);\n            preparedUpdateParams = standaloneUpdates;\n        }\n        const rawBatch = {\n            post: preparedCreateParams,\n            patch: preparedUpdateParams\n        };\n        if (!rawBatch.post.length && !rawBatch.patch.length) {\n            return;\n        }\n        const batchChunks = {\n            post: [],\n            patch: []\n        };\n        for (const k of [\n            \"post\",\n            \"patch\"\n        ]){\n            const key = k;\n            const batchItems = rawBatch[key].reverse();\n            let batchItem = batchItems.pop();\n            while(batchItem !== undefined){\n                // Type is wrong but this is a deprecated code path anyway\n                batchChunks[key].push(batchItem);\n                batchItem = batchItems.pop();\n            }\n        }\n        if (batchChunks.post.length > 0 || batchChunks.patch.length > 0) {\n            await this._postBatchIngestRuns((0,_utils_fast_safe_stringify_index_js__WEBPACK_IMPORTED_MODULE_9__.serialize)(batchChunks));\n        }\n    }\n    async _postBatchIngestRuns(body) {\n        const headers = {\n            ...this.headers,\n            \"Content-Type\": \"application/json\",\n            Accept: \"application/json\"\n        };\n        const response = await this.batchIngestCaller.call((0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_8__._getFetchImplementation)(), `${this.apiUrl}/runs/batch`, {\n            method: \"POST\",\n            headers,\n            body: body,\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions\n        });\n        await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_7__.raiseForStatus)(response, \"batch create run\", true);\n    }\n    /**\n     * Batch ingest/upsert multiple runs in the Langsmith system.\n     * @param runs\n     */ async multipartIngestRuns({ runCreates, runUpdates }) {\n        if (runCreates === undefined && runUpdates === undefined) {\n            return;\n        }\n        // transform and convert to dicts\n        const allAttachments = {};\n        let preparedCreateParams = [];\n        for (const create of runCreates ?? []){\n            const preparedCreate = this.prepareRunCreateOrUpdateInputs(create);\n            if (preparedCreate.id !== undefined && preparedCreate.attachments !== undefined) {\n                allAttachments[preparedCreate.id] = preparedCreate.attachments;\n            }\n            delete preparedCreate.attachments;\n            preparedCreateParams.push(preparedCreate);\n        }\n        let preparedUpdateParams = [];\n        for (const update of runUpdates ?? []){\n            preparedUpdateParams.push(this.prepareRunCreateOrUpdateInputs(update));\n        }\n        // require trace_id and dotted_order\n        const invalidRunCreate = preparedCreateParams.find((runCreate)=>{\n            return runCreate.trace_id === undefined || runCreate.dotted_order === undefined;\n        });\n        if (invalidRunCreate !== undefined) {\n            throw new Error(`Multipart ingest requires \"trace_id\" and \"dotted_order\" to be set when creating a run`);\n        }\n        const invalidRunUpdate = preparedUpdateParams.find((runUpdate)=>{\n            return runUpdate.trace_id === undefined || runUpdate.dotted_order === undefined;\n        });\n        if (invalidRunUpdate !== undefined) {\n            throw new Error(`Multipart ingest requires \"trace_id\" and \"dotted_order\" to be set when updating a run`);\n        }\n        // combine post and patch dicts where possible\n        if (preparedCreateParams.length > 0 && preparedUpdateParams.length > 0) {\n            const createById = preparedCreateParams.reduce((params, run)=>{\n                if (!run.id) {\n                    return params;\n                }\n                params[run.id] = run;\n                return params;\n            }, {});\n            const standaloneUpdates = [];\n            for (const updateParam of preparedUpdateParams){\n                if (updateParam.id !== undefined && createById[updateParam.id]) {\n                    createById[updateParam.id] = {\n                        ...createById[updateParam.id],\n                        ...updateParam\n                    };\n                } else {\n                    standaloneUpdates.push(updateParam);\n                }\n            }\n            preparedCreateParams = Object.values(createById);\n            preparedUpdateParams = standaloneUpdates;\n        }\n        if (preparedCreateParams.length === 0 && preparedUpdateParams.length === 0) {\n            return;\n        }\n        // send the runs in multipart requests\n        const accumulatedContext = [];\n        const accumulatedParts = [];\n        for (const [method, payloads] of [\n            [\n                \"post\",\n                preparedCreateParams\n            ],\n            [\n                \"patch\",\n                preparedUpdateParams\n            ]\n        ]){\n            for (const originalPayload of payloads){\n                // collect fields to be sent as separate parts\n                const { inputs, outputs, events, attachments, ...payload } = originalPayload;\n                const fields = {\n                    inputs,\n                    outputs,\n                    events\n                };\n                // encode the main run payload\n                const stringifiedPayload = (0,_utils_fast_safe_stringify_index_js__WEBPACK_IMPORTED_MODULE_9__.serialize)(payload);\n                accumulatedParts.push({\n                    name: `${method}.${payload.id}`,\n                    payload: new Blob([\n                        stringifiedPayload\n                    ], {\n                        type: `application/json; length=${stringifiedPayload.length}`\n                    })\n                });\n                // encode the fields we collected\n                for (const [key, value] of Object.entries(fields)){\n                    if (value === undefined) {\n                        continue;\n                    }\n                    const stringifiedValue = (0,_utils_fast_safe_stringify_index_js__WEBPACK_IMPORTED_MODULE_9__.serialize)(value);\n                    accumulatedParts.push({\n                        name: `${method}.${payload.id}.${key}`,\n                        payload: new Blob([\n                            stringifiedValue\n                        ], {\n                            type: `application/json; length=${stringifiedValue.length}`\n                        })\n                    });\n                }\n                // encode the attachments\n                if (payload.id !== undefined) {\n                    const attachments = allAttachments[payload.id];\n                    if (attachments) {\n                        delete allAttachments[payload.id];\n                        for (const [name, attachment] of Object.entries(attachments)){\n                            let contentType;\n                            let content;\n                            if (Array.isArray(attachment)) {\n                                [contentType, content] = attachment;\n                            } else {\n                                contentType = attachment.mimeType;\n                                content = attachment.data;\n                            }\n                            // Validate that the attachment name doesn't contain a '.'\n                            if (name.includes(\".\")) {\n                                console.warn(`Skipping attachment '${name}' for run ${payload.id}: Invalid attachment name. ` + `Attachment names must not contain periods ('.'). Please rename the attachment and try again.`);\n                                continue;\n                            }\n                            accumulatedParts.push({\n                                name: `attachment.${payload.id}.${name}`,\n                                payload: new Blob([\n                                    content\n                                ], {\n                                    type: `${contentType}; length=${content.byteLength}`\n                                })\n                            });\n                        }\n                    }\n                }\n                // compute context\n                accumulatedContext.push(`trace=${payload.trace_id},id=${payload.id}`);\n            }\n        }\n        await this._sendMultipartRequest(accumulatedParts, accumulatedContext.join(\"; \"));\n    }\n    async _sendMultipartRequest(parts, context) {\n        try {\n            // Create multipart form data manually using Blobs\n            const boundary = \"----LangSmithFormBoundary\" + Math.random().toString(36).slice(2);\n            const chunks = [];\n            for (const part of parts){\n                // Add field boundary\n                chunks.push(new Blob([\n                    `--${boundary}\\r\\n`\n                ]));\n                chunks.push(new Blob([\n                    `Content-Disposition: form-data; name=\"${part.name}\"\\r\\n`,\n                    `Content-Type: ${part.payload.type}\\r\\n\\r\\n`\n                ]));\n                chunks.push(part.payload);\n                chunks.push(new Blob([\n                    \"\\r\\n\"\n                ]));\n            }\n            // Add final boundary\n            chunks.push(new Blob([\n                `--${boundary}--\\r\\n`\n            ]));\n            // Combine all chunks into a single Blob\n            const body = new Blob(chunks);\n            // Convert Blob to ArrayBuffer for compatibility\n            const arrayBuffer = await body.arrayBuffer();\n            const res = await this.batchIngestCaller.call((0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_8__._getFetchImplementation)(), `${this.apiUrl}/runs/multipart`, {\n                method: \"POST\",\n                headers: {\n                    ...this.headers,\n                    \"Content-Type\": `multipart/form-data; boundary=${boundary}`\n                },\n                body: arrayBuffer,\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions\n            });\n            await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_7__.raiseForStatus)(res, \"ingest multipart runs\", true);\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        } catch (e) {\n            console.warn(`${e.message.trim()}\\n\\nContext: ${context}`);\n        }\n    }\n    async updateRun(runId, run) {\n        (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_4__.assertUuid)(runId);\n        if (run.inputs) {\n            run.inputs = this.processInputs(run.inputs);\n        }\n        if (run.outputs) {\n            run.outputs = this.processOutputs(run.outputs);\n        }\n        // TODO: Untangle types\n        const data = {\n            ...run,\n            id: runId\n        };\n        if (!this._filterForSampling([\n            data\n        ], true).length) {\n            return;\n        }\n        if (this.autoBatchTracing && data.trace_id !== undefined && data.dotted_order !== undefined) {\n            if (run.end_time !== undefined && data.parent_run_id === undefined && this.blockOnRootRunFinalization && !this.manualFlushMode) {\n                // Trigger batches as soon as a root trace ends and wait to ensure trace finishes\n                // in serverless environments.\n                await this.processRunOperation({\n                    action: \"update\",\n                    item: data\n                }).catch(console.error);\n                return;\n            } else {\n                void this.processRunOperation({\n                    action: \"update\",\n                    item: data\n                }).catch(console.error);\n            }\n            return;\n        }\n        const headers = {\n            ...this.headers,\n            \"Content-Type\": \"application/json\"\n        };\n        const response = await this.caller.call((0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_8__._getFetchImplementation)(), `${this.apiUrl}/runs/${runId}`, {\n            method: \"PATCH\",\n            headers,\n            body: (0,_utils_fast_safe_stringify_index_js__WEBPACK_IMPORTED_MODULE_9__.serialize)(run),\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions\n        });\n        await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_7__.raiseForStatus)(response, \"update run\", true);\n    }\n    async readRun(runId, { loadChildRuns } = {\n        loadChildRuns: false\n    }) {\n        (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_4__.assertUuid)(runId);\n        let run = await this._get(`/runs/${runId}`);\n        if (loadChildRuns && run.child_run_ids) {\n            run = await this._loadChildRuns(run);\n        }\n        return run;\n    }\n    async getRunUrl({ runId, run, projectOpts }) {\n        if (run !== undefined) {\n            let sessionId;\n            if (run.session_id) {\n                sessionId = run.session_id;\n            } else if (projectOpts?.projectName) {\n                sessionId = (await this.readProject({\n                    projectName: projectOpts?.projectName\n                })).id;\n            } else if (projectOpts?.projectId) {\n                sessionId = projectOpts?.projectId;\n            } else {\n                const project = await this.readProject({\n                    projectName: (0,_utils_env_js__WEBPACK_IMPORTED_MODULE_2__.getLangSmithEnvironmentVariable)(\"PROJECT\") || \"default\"\n                });\n                sessionId = project.id;\n            }\n            const tenantId = await this._getTenantId();\n            return `${this.getHostUrl()}/o/${tenantId}/projects/p/${sessionId}/r/${run.id}?poll=true`;\n        } else if (runId !== undefined) {\n            const run_ = await this.readRun(runId);\n            if (!run_.app_path) {\n                throw new Error(`Run ${runId} has no app_path`);\n            }\n            const baseUrl = this.getHostUrl();\n            return `${baseUrl}${run_.app_path}`;\n        } else {\n            throw new Error(\"Must provide either runId or run\");\n        }\n    }\n    async _loadChildRuns(run) {\n        const childRuns = await toArray(this.listRuns({\n            id: run.child_run_ids\n        }));\n        const treemap = {};\n        const runs = {};\n        // TODO: make dotted order required when the migration finishes\n        childRuns.sort((a, b)=>(a?.dotted_order ?? \"\").localeCompare(b?.dotted_order ?? \"\"));\n        for (const childRun of childRuns){\n            if (childRun.parent_run_id === null || childRun.parent_run_id === undefined) {\n                throw new Error(`Child run ${childRun.id} has no parent`);\n            }\n            if (!(childRun.parent_run_id in treemap)) {\n                treemap[childRun.parent_run_id] = [];\n            }\n            treemap[childRun.parent_run_id].push(childRun);\n            runs[childRun.id] = childRun;\n        }\n        run.child_runs = treemap[run.id] || [];\n        for(const runId in treemap){\n            if (runId !== run.id) {\n                runs[runId].child_runs = treemap[runId];\n            }\n        }\n        return run;\n    }\n    /**\n     * List runs from the LangSmith server.\n     * @param projectId - The ID of the project to filter by.\n     * @param projectName - The name of the project to filter by.\n     * @param parentRunId - The ID of the parent run to filter by.\n     * @param traceId - The ID of the trace to filter by.\n     * @param referenceExampleId - The ID of the reference example to filter by.\n     * @param startTime - The start time to filter by.\n     * @param isRoot - Indicates whether to only return root runs.\n     * @param runType - The run type to filter by.\n     * @param error - Indicates whether to filter by error runs.\n     * @param id - The ID of the run to filter by.\n     * @param query - The query string to filter by.\n     * @param filter - The filter string to apply to the run spans.\n     * @param traceFilter - The filter string to apply on the root run of the trace.\n     * @param treeFilter - The filter string to apply on other runs in the trace.\n     * @param limit - The maximum number of runs to retrieve.\n     * @returns {AsyncIterable<Run>} - The runs.\n     *\n     * @example\n     * // List all runs in a project\n     * const projectRuns = client.listRuns({ projectName: \"<your_project>\" });\n     *\n     * @example\n     * // List LLM and Chat runs in the last 24 hours\n     * const todaysLLMRuns = client.listRuns({\n     *   projectName: \"<your_project>\",\n     *   start_time: new Date(Date.now() - 24 * 60 * 60 * 1000),\n     *   run_type: \"llm\",\n     * });\n     *\n     * @example\n     * // List traces in a project\n     * const rootRuns = client.listRuns({\n     *   projectName: \"<your_project>\",\n     *   execution_order: 1,\n     * });\n     *\n     * @example\n     * // List runs without errors\n     * const correctRuns = client.listRuns({\n     *   projectName: \"<your_project>\",\n     *   error: false,\n     * });\n     *\n     * @example\n     * // List runs by run ID\n     * const runIds = [\n     *   \"a36092d2-4ad5-4fb4-9c0d-0dba9a2ed836\",\n     *   \"9398e6be-964f-4aa4-8ae9-ad78cd4b7074\",\n     * ];\n     * const selectedRuns = client.listRuns({ run_ids: runIds });\n     *\n     * @example\n     * // List all \"chain\" type runs that took more than 10 seconds and had `total_tokens` greater than 5000\n     * const chainRuns = client.listRuns({\n     *   projectName: \"<your_project>\",\n     *   filter: 'and(eq(run_type, \"chain\"), gt(latency, 10), gt(total_tokens, 5000))',\n     * });\n     *\n     * @example\n     * // List all runs called \"extractor\" whose root of the trace was assigned feedback \"user_score\" score of 1\n     * const goodExtractorRuns = client.listRuns({\n     *   projectName: \"<your_project>\",\n     *   filter: 'eq(name, \"extractor\")',\n     *   traceFilter: 'and(eq(feedback_key, \"user_score\"), eq(feedback_score, 1))',\n     * });\n     *\n     * @example\n     * // List all runs that started after a specific timestamp and either have \"error\" not equal to null or a \"Correctness\" feedback score equal to 0\n     * const complexRuns = client.listRuns({\n     *   projectName: \"<your_project>\",\n     *   filter: 'and(gt(start_time, \"2023-07-15T12:34:56Z\"), or(neq(error, null), and(eq(feedback_key, \"Correctness\"), eq(feedback_score, 0.0))))',\n     * });\n     *\n     * @example\n     * // List all runs where `tags` include \"experimental\" or \"beta\" and `latency` is greater than 2 seconds\n     * const taggedRuns = client.listRuns({\n     *   projectName: \"<your_project>\",\n     *   filter: 'and(or(has(tags, \"experimental\"), has(tags, \"beta\")), gt(latency, 2))',\n     * });\n     */ async *listRuns(props) {\n        const { projectId, projectName, parentRunId, traceId, referenceExampleId, startTime, executionOrder, isRoot, runType, error, id, query, filter, traceFilter, treeFilter, limit, select } = props;\n        let projectIds = [];\n        if (projectId) {\n            projectIds = Array.isArray(projectId) ? projectId : [\n                projectId\n            ];\n        }\n        if (projectName) {\n            const projectNames = Array.isArray(projectName) ? projectName : [\n                projectName\n            ];\n            const projectIds_ = await Promise.all(projectNames.map((name)=>this.readProject({\n                    projectName: name\n                }).then((project)=>project.id)));\n            projectIds.push(...projectIds_);\n        }\n        const default_select = [\n            \"app_path\",\n            \"child_run_ids\",\n            \"completion_cost\",\n            \"completion_tokens\",\n            \"dotted_order\",\n            \"end_time\",\n            \"error\",\n            \"events\",\n            \"extra\",\n            \"feedback_stats\",\n            \"first_token_time\",\n            \"id\",\n            \"inputs\",\n            \"name\",\n            \"outputs\",\n            \"parent_run_id\",\n            \"parent_run_ids\",\n            \"prompt_cost\",\n            \"prompt_tokens\",\n            \"reference_example_id\",\n            \"run_type\",\n            \"session_id\",\n            \"start_time\",\n            \"status\",\n            \"tags\",\n            \"total_cost\",\n            \"total_tokens\",\n            \"trace_id\"\n        ];\n        const body = {\n            session: projectIds.length ? projectIds : null,\n            run_type: runType,\n            reference_example: referenceExampleId,\n            query,\n            filter,\n            trace_filter: traceFilter,\n            tree_filter: treeFilter,\n            execution_order: executionOrder,\n            parent_run: parentRunId,\n            start_time: startTime ? startTime.toISOString() : null,\n            error,\n            id,\n            limit,\n            trace: traceId,\n            select: select ? select : default_select,\n            is_root: isRoot\n        };\n        let runsYielded = 0;\n        for await (const runs of this._getCursorPaginatedList(\"/runs/query\", body)){\n            if (limit) {\n                if (runsYielded >= limit) {\n                    break;\n                }\n                if (runs.length + runsYielded > limit) {\n                    const newRuns = runs.slice(0, limit - runsYielded);\n                    yield* newRuns;\n                    break;\n                }\n                runsYielded += runs.length;\n                yield* runs;\n            } else {\n                yield* runs;\n            }\n        }\n    }\n    async getRunStats({ id, trace, parentRun, runType, projectNames, projectIds, referenceExampleIds, startTime, endTime, error, query, filter, traceFilter, treeFilter, isRoot, dataSourceType }) {\n        let projectIds_ = projectIds || [];\n        if (projectNames) {\n            projectIds_ = [\n                ...projectIds || [],\n                ...await Promise.all(projectNames.map((name)=>this.readProject({\n                        projectName: name\n                    }).then((project)=>project.id)))\n            ];\n        }\n        const payload = {\n            id,\n            trace,\n            parent_run: parentRun,\n            run_type: runType,\n            session: projectIds_,\n            reference_example: referenceExampleIds,\n            start_time: startTime,\n            end_time: endTime,\n            error,\n            query,\n            filter,\n            trace_filter: traceFilter,\n            tree_filter: treeFilter,\n            is_root: isRoot,\n            data_source_type: dataSourceType\n        };\n        // Remove undefined values from the payload\n        const filteredPayload = Object.fromEntries(Object.entries(payload).filter(([_, value])=>value !== undefined));\n        const response = await this.caller.call((0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_8__._getFetchImplementation)(), `${this.apiUrl}/runs/stats`, {\n            method: \"POST\",\n            headers: this.headers,\n            body: JSON.stringify(filteredPayload),\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions\n        });\n        const result = await response.json();\n        return result;\n    }\n    async shareRun(runId, { shareId } = {}) {\n        const data = {\n            run_id: runId,\n            share_token: shareId || uuid__WEBPACK_IMPORTED_MODULE_10__[\"default\"]()\n        };\n        (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_4__.assertUuid)(runId);\n        const response = await this.caller.call((0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_8__._getFetchImplementation)(), `${this.apiUrl}/runs/${runId}/share`, {\n            method: \"PUT\",\n            headers: this.headers,\n            body: JSON.stringify(data),\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions\n        });\n        const result = await response.json();\n        if (result === null || !(\"share_token\" in result)) {\n            throw new Error(\"Invalid response from server\");\n        }\n        return `${this.getHostUrl()}/public/${result[\"share_token\"]}/r`;\n    }\n    async unshareRun(runId) {\n        (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_4__.assertUuid)(runId);\n        const response = await this.caller.call((0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_8__._getFetchImplementation)(), `${this.apiUrl}/runs/${runId}/share`, {\n            method: \"DELETE\",\n            headers: this.headers,\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions\n        });\n        await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_7__.raiseForStatus)(response, \"unshare run\", true);\n    }\n    async readRunSharedLink(runId) {\n        (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_4__.assertUuid)(runId);\n        const response = await this.caller.call((0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_8__._getFetchImplementation)(), `${this.apiUrl}/runs/${runId}/share`, {\n            method: \"GET\",\n            headers: this.headers,\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions\n        });\n        const result = await response.json();\n        if (result === null || !(\"share_token\" in result)) {\n            return undefined;\n        }\n        return `${this.getHostUrl()}/public/${result[\"share_token\"]}/r`;\n    }\n    async listSharedRuns(shareToken, { runIds } = {}) {\n        const queryParams = new URLSearchParams({\n            share_token: shareToken\n        });\n        if (runIds !== undefined) {\n            for (const runId of runIds){\n                queryParams.append(\"id\", runId);\n            }\n        }\n        (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_4__.assertUuid)(shareToken);\n        const response = await this.caller.call((0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_8__._getFetchImplementation)(), `${this.apiUrl}/public/${shareToken}/runs${queryParams}`, {\n            method: \"GET\",\n            headers: this.headers,\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions\n        });\n        const runs = await response.json();\n        return runs;\n    }\n    async readDatasetSharedSchema(datasetId, datasetName) {\n        if (!datasetId && !datasetName) {\n            throw new Error(\"Either datasetId or datasetName must be given\");\n        }\n        if (!datasetId) {\n            const dataset = await this.readDataset({\n                datasetName\n            });\n            datasetId = dataset.id;\n        }\n        (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_4__.assertUuid)(datasetId);\n        const response = await this.caller.call((0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_8__._getFetchImplementation)(), `${this.apiUrl}/datasets/${datasetId}/share`, {\n            method: \"GET\",\n            headers: this.headers,\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions\n        });\n        const shareSchema = await response.json();\n        shareSchema.url = `${this.getHostUrl()}/public/${shareSchema.share_token}/d`;\n        return shareSchema;\n    }\n    async shareDataset(datasetId, datasetName) {\n        if (!datasetId && !datasetName) {\n            throw new Error(\"Either datasetId or datasetName must be given\");\n        }\n        if (!datasetId) {\n            const dataset = await this.readDataset({\n                datasetName\n            });\n            datasetId = dataset.id;\n        }\n        const data = {\n            dataset_id: datasetId\n        };\n        (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_4__.assertUuid)(datasetId);\n        const response = await this.caller.call((0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_8__._getFetchImplementation)(), `${this.apiUrl}/datasets/${datasetId}/share`, {\n            method: \"PUT\",\n            headers: this.headers,\n            body: JSON.stringify(data),\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions\n        });\n        const shareSchema = await response.json();\n        shareSchema.url = `${this.getHostUrl()}/public/${shareSchema.share_token}/d`;\n        return shareSchema;\n    }\n    async unshareDataset(datasetId) {\n        (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_4__.assertUuid)(datasetId);\n        const response = await this.caller.call((0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_8__._getFetchImplementation)(), `${this.apiUrl}/datasets/${datasetId}/share`, {\n            method: \"DELETE\",\n            headers: this.headers,\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions\n        });\n        await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_7__.raiseForStatus)(response, \"unshare dataset\", true);\n    }\n    async readSharedDataset(shareToken) {\n        (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_4__.assertUuid)(shareToken);\n        const response = await this.caller.call((0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_8__._getFetchImplementation)(), `${this.apiUrl}/public/${shareToken}/datasets`, {\n            method: \"GET\",\n            headers: this.headers,\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions\n        });\n        const dataset = await response.json();\n        return dataset;\n    }\n    /**\n     * Get shared examples.\n     *\n     * @param {string} shareToken The share token to get examples for. A share token is the UUID (or LangSmith URL, including UUID) generated when explicitly marking an example as public.\n     * @param {Object} [options] Additional options for listing the examples.\n     * @param {string[] | undefined} [options.exampleIds] A list of example IDs to filter by.\n     * @returns {Promise<Example[]>} The shared examples.\n     */ async listSharedExamples(shareToken, options) {\n        const params = {};\n        if (options?.exampleIds) {\n            params.id = options.exampleIds;\n        }\n        const urlParams = new URLSearchParams();\n        Object.entries(params).forEach(([key, value])=>{\n            if (Array.isArray(value)) {\n                value.forEach((v)=>urlParams.append(key, v));\n            } else {\n                urlParams.append(key, value);\n            }\n        });\n        const response = await this.caller.call((0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_8__._getFetchImplementation)(), `${this.apiUrl}/public/${shareToken}/examples?${urlParams.toString()}`, {\n            method: \"GET\",\n            headers: this.headers,\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions\n        });\n        const result = await response.json();\n        if (!response.ok) {\n            if (\"detail\" in result) {\n                throw new Error(`Failed to list shared examples.\\nStatus: ${response.status}\\nMessage: ${result.detail.join(\"\\n\")}`);\n            }\n            throw new Error(`Failed to list shared examples: ${response.status} ${response.statusText}`);\n        }\n        return result.map((example)=>({\n                ...example,\n                _hostUrl: this.getHostUrl()\n            }));\n    }\n    async createProject({ projectName, description = null, metadata = null, upsert = false, projectExtra = null, referenceDatasetId = null }) {\n        const upsert_ = upsert ? `?upsert=true` : \"\";\n        const endpoint = `${this.apiUrl}/sessions${upsert_}`;\n        const extra = projectExtra || {};\n        if (metadata) {\n            extra[\"metadata\"] = metadata;\n        }\n        const body = {\n            name: projectName,\n            extra,\n            description\n        };\n        if (referenceDatasetId !== null) {\n            body[\"reference_dataset_id\"] = referenceDatasetId;\n        }\n        const response = await this.caller.call((0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_8__._getFetchImplementation)(), endpoint, {\n            method: \"POST\",\n            headers: {\n                ...this.headers,\n                \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify(body),\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions\n        });\n        await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_7__.raiseForStatus)(response, \"create project\");\n        const result = await response.json();\n        return result;\n    }\n    async updateProject(projectId, { name = null, description = null, metadata = null, projectExtra = null, endTime = null }) {\n        const endpoint = `${this.apiUrl}/sessions/${projectId}`;\n        let extra = projectExtra;\n        if (metadata) {\n            extra = {\n                ...extra || {},\n                metadata\n            };\n        }\n        const body = {\n            name,\n            extra,\n            description,\n            end_time: endTime ? new Date(endTime).toISOString() : null\n        };\n        const response = await this.caller.call((0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_8__._getFetchImplementation)(), endpoint, {\n            method: \"PATCH\",\n            headers: {\n                ...this.headers,\n                \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify(body),\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions\n        });\n        await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_7__.raiseForStatus)(response, \"update project\");\n        const result = await response.json();\n        return result;\n    }\n    async hasProject({ projectId, projectName }) {\n        // TODO: Add a head request\n        let path = \"/sessions\";\n        const params = new URLSearchParams();\n        if (projectId !== undefined && projectName !== undefined) {\n            throw new Error(\"Must provide either projectName or projectId, not both\");\n        } else if (projectId !== undefined) {\n            (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_4__.assertUuid)(projectId);\n            path += `/${projectId}`;\n        } else if (projectName !== undefined) {\n            params.append(\"name\", projectName);\n        } else {\n            throw new Error(\"Must provide projectName or projectId\");\n        }\n        const response = await this.caller.call((0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_8__._getFetchImplementation)(), `${this.apiUrl}${path}?${params}`, {\n            method: \"GET\",\n            headers: this.headers,\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions\n        });\n        // consume the response body to release the connection\n        // https://undici.nodejs.org/#/?id=garbage-collection\n        try {\n            const result = await response.json();\n            if (!response.ok) {\n                return false;\n            }\n            // If it's OK and we're querying by name, need to check the list is not empty\n            if (Array.isArray(result)) {\n                return result.length > 0;\n            }\n            // projectId querying\n            return true;\n        } catch (e) {\n            return false;\n        }\n    }\n    async readProject({ projectId, projectName, includeStats }) {\n        let path = \"/sessions\";\n        const params = new URLSearchParams();\n        if (projectId !== undefined && projectName !== undefined) {\n            throw new Error(\"Must provide either projectName or projectId, not both\");\n        } else if (projectId !== undefined) {\n            (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_4__.assertUuid)(projectId);\n            path += `/${projectId}`;\n        } else if (projectName !== undefined) {\n            params.append(\"name\", projectName);\n        } else {\n            throw new Error(\"Must provide projectName or projectId\");\n        }\n        if (includeStats !== undefined) {\n            params.append(\"include_stats\", includeStats.toString());\n        }\n        const response = await this._get(path, params);\n        let result;\n        if (Array.isArray(response)) {\n            if (response.length === 0) {\n                throw new Error(`Project[id=${projectId}, name=${projectName}] not found`);\n            }\n            result = response[0];\n        } else {\n            result = response;\n        }\n        return result;\n    }\n    async getProjectUrl({ projectId, projectName }) {\n        if (projectId === undefined && projectName === undefined) {\n            throw new Error(\"Must provide either projectName or projectId\");\n        }\n        const project = await this.readProject({\n            projectId,\n            projectName\n        });\n        const tenantId = await this._getTenantId();\n        return `${this.getHostUrl()}/o/${tenantId}/projects/p/${project.id}`;\n    }\n    async getDatasetUrl({ datasetId, datasetName }) {\n        if (datasetId === undefined && datasetName === undefined) {\n            throw new Error(\"Must provide either datasetName or datasetId\");\n        }\n        const dataset = await this.readDataset({\n            datasetId,\n            datasetName\n        });\n        const tenantId = await this._getTenantId();\n        return `${this.getHostUrl()}/o/${tenantId}/datasets/${dataset.id}`;\n    }\n    async _getTenantId() {\n        if (this._tenantId !== null) {\n            return this._tenantId;\n        }\n        const queryParams = new URLSearchParams({\n            limit: \"1\"\n        });\n        for await (const projects of this._getPaginated(\"/sessions\", queryParams)){\n            this._tenantId = projects[0].tenant_id;\n            return projects[0].tenant_id;\n        }\n        throw new Error(\"No projects found to resolve tenant.\");\n    }\n    async *listProjects({ projectIds, name, nameContains, referenceDatasetId, referenceDatasetName, referenceFree, metadata } = {}) {\n        const params = new URLSearchParams();\n        if (projectIds !== undefined) {\n            for (const projectId of projectIds){\n                params.append(\"id\", projectId);\n            }\n        }\n        if (name !== undefined) {\n            params.append(\"name\", name);\n        }\n        if (nameContains !== undefined) {\n            params.append(\"name_contains\", nameContains);\n        }\n        if (referenceDatasetId !== undefined) {\n            params.append(\"reference_dataset\", referenceDatasetId);\n        } else if (referenceDatasetName !== undefined) {\n            const dataset = await this.readDataset({\n                datasetName: referenceDatasetName\n            });\n            params.append(\"reference_dataset\", dataset.id);\n        }\n        if (referenceFree !== undefined) {\n            params.append(\"reference_free\", referenceFree.toString());\n        }\n        if (metadata !== undefined) {\n            params.append(\"metadata\", JSON.stringify(metadata));\n        }\n        for await (const projects of this._getPaginated(\"/sessions\", params)){\n            yield* projects;\n        }\n    }\n    async deleteProject({ projectId, projectName }) {\n        let projectId_;\n        if (projectId === undefined && projectName === undefined) {\n            throw new Error(\"Must provide projectName or projectId\");\n        } else if (projectId !== undefined && projectName !== undefined) {\n            throw new Error(\"Must provide either projectName or projectId, not both\");\n        } else if (projectId === undefined) {\n            projectId_ = (await this.readProject({\n                projectName\n            })).id;\n        } else {\n            projectId_ = projectId;\n        }\n        (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_4__.assertUuid)(projectId_);\n        const response = await this.caller.call((0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_8__._getFetchImplementation)(), `${this.apiUrl}/sessions/${projectId_}`, {\n            method: \"DELETE\",\n            headers: this.headers,\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions\n        });\n        await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_7__.raiseForStatus)(response, `delete session ${projectId_} (${projectName})`, true);\n    }\n    async uploadCsv({ csvFile, fileName, inputKeys, outputKeys, description, dataType, name }) {\n        const url = `${this.apiUrl}/datasets/upload`;\n        const formData = new FormData();\n        formData.append(\"file\", csvFile, fileName);\n        inputKeys.forEach((key)=>{\n            formData.append(\"input_keys\", key);\n        });\n        outputKeys.forEach((key)=>{\n            formData.append(\"output_keys\", key);\n        });\n        if (description) {\n            formData.append(\"description\", description);\n        }\n        if (dataType) {\n            formData.append(\"data_type\", dataType);\n        }\n        if (name) {\n            formData.append(\"name\", name);\n        }\n        const response = await this.caller.call((0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_8__._getFetchImplementation)(), url, {\n            method: \"POST\",\n            headers: this.headers,\n            body: formData,\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions\n        });\n        await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_7__.raiseForStatus)(response, \"upload CSV\");\n        const result = await response.json();\n        return result;\n    }\n    async createDataset(name, { description, dataType, inputsSchema, outputsSchema, metadata } = {}) {\n        const body = {\n            name,\n            description,\n            extra: metadata ? {\n                metadata\n            } : undefined\n        };\n        if (dataType) {\n            body.data_type = dataType;\n        }\n        if (inputsSchema) {\n            body.inputs_schema_definition = inputsSchema;\n        }\n        if (outputsSchema) {\n            body.outputs_schema_definition = outputsSchema;\n        }\n        const response = await this.caller.call((0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_8__._getFetchImplementation)(), `${this.apiUrl}/datasets`, {\n            method: \"POST\",\n            headers: {\n                ...this.headers,\n                \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify(body),\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions\n        });\n        await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_7__.raiseForStatus)(response, \"create dataset\");\n        const result = await response.json();\n        return result;\n    }\n    async readDataset({ datasetId, datasetName }) {\n        let path = \"/datasets\";\n        // limit to 1 result\n        const params = new URLSearchParams({\n            limit: \"1\"\n        });\n        if (datasetId !== undefined && datasetName !== undefined) {\n            throw new Error(\"Must provide either datasetName or datasetId, not both\");\n        } else if (datasetId !== undefined) {\n            (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_4__.assertUuid)(datasetId);\n            path += `/${datasetId}`;\n        } else if (datasetName !== undefined) {\n            params.append(\"name\", datasetName);\n        } else {\n            throw new Error(\"Must provide datasetName or datasetId\");\n        }\n        const response = await this._get(path, params);\n        let result;\n        if (Array.isArray(response)) {\n            if (response.length === 0) {\n                throw new Error(`Dataset[id=${datasetId}, name=${datasetName}] not found`);\n            }\n            result = response[0];\n        } else {\n            result = response;\n        }\n        return result;\n    }\n    async hasDataset({ datasetId, datasetName }) {\n        try {\n            await this.readDataset({\n                datasetId,\n                datasetName\n            });\n            return true;\n        } catch (e) {\n            if (// eslint-disable-next-line no-instanceof/no-instanceof\n            e instanceof Error && e.message.toLocaleLowerCase().includes(\"not found\")) {\n                return false;\n            }\n            throw e;\n        }\n    }\n    async diffDatasetVersions({ datasetId, datasetName, fromVersion, toVersion }) {\n        let datasetId_ = datasetId;\n        if (datasetId_ === undefined && datasetName === undefined) {\n            throw new Error(\"Must provide either datasetName or datasetId\");\n        } else if (datasetId_ !== undefined && datasetName !== undefined) {\n            throw new Error(\"Must provide either datasetName or datasetId, not both\");\n        } else if (datasetId_ === undefined) {\n            const dataset = await this.readDataset({\n                datasetName\n            });\n            datasetId_ = dataset.id;\n        }\n        const urlParams = new URLSearchParams({\n            from_version: typeof fromVersion === \"string\" ? fromVersion : fromVersion.toISOString(),\n            to_version: typeof toVersion === \"string\" ? toVersion : toVersion.toISOString()\n        });\n        const response = await this._get(`/datasets/${datasetId_}/versions/diff`, urlParams);\n        return response;\n    }\n    async readDatasetOpenaiFinetuning({ datasetId, datasetName }) {\n        const path = \"/datasets\";\n        if (datasetId !== undefined) {\n        // do nothing\n        } else if (datasetName !== undefined) {\n            datasetId = (await this.readDataset({\n                datasetName\n            })).id;\n        } else {\n            throw new Error(\"Must provide either datasetName or datasetId\");\n        }\n        const response = await this._getResponse(`${path}/${datasetId}/openai_ft`);\n        const datasetText = await response.text();\n        const dataset = datasetText.trim().split(\"\\n\").map((line)=>JSON.parse(line));\n        return dataset;\n    }\n    async *listDatasets({ limit = 100, offset = 0, datasetIds, datasetName, datasetNameContains, metadata } = {}) {\n        const path = \"/datasets\";\n        const params = new URLSearchParams({\n            limit: limit.toString(),\n            offset: offset.toString()\n        });\n        if (datasetIds !== undefined) {\n            for (const id_ of datasetIds){\n                params.append(\"id\", id_);\n            }\n        }\n        if (datasetName !== undefined) {\n            params.append(\"name\", datasetName);\n        }\n        if (datasetNameContains !== undefined) {\n            params.append(\"name_contains\", datasetNameContains);\n        }\n        if (metadata !== undefined) {\n            params.append(\"metadata\", JSON.stringify(metadata));\n        }\n        for await (const datasets of this._getPaginated(path, params)){\n            yield* datasets;\n        }\n    }\n    /**\n     * Update a dataset\n     * @param props The dataset details to update\n     * @returns The updated dataset\n     */ async updateDataset(props) {\n        const { datasetId, datasetName, ...update } = props;\n        if (!datasetId && !datasetName) {\n            throw new Error(\"Must provide either datasetName or datasetId\");\n        }\n        const _datasetId = datasetId ?? (await this.readDataset({\n            datasetName\n        })).id;\n        (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_4__.assertUuid)(_datasetId);\n        const response = await this.caller.call((0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_8__._getFetchImplementation)(), `${this.apiUrl}/datasets/${_datasetId}`, {\n            method: \"PATCH\",\n            headers: {\n                ...this.headers,\n                \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify(update),\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions\n        });\n        await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_7__.raiseForStatus)(response, \"update dataset\");\n        return await response.json();\n    }\n    /**\n     * Updates a tag on a dataset.\n     *\n     * If the tag is already assigned to a different version of this dataset,\n     * the tag will be moved to the new version. The as_of parameter is used to\n     * determine which version of the dataset to apply the new tags to.\n     *\n     * It must be an exact version of the dataset to succeed. You can\n     * use the \"readDatasetVersion\" method to find the exact version\n     * to apply the tags to.\n     * @param params.datasetId The ID of the dataset to update. Must be provided if \"datasetName\" is not provided.\n     * @param params.datasetName The name of the dataset to update. Must be provided if \"datasetId\" is not provided.\n     * @param params.asOf The timestamp of the dataset to apply the new tags to.\n     * @param params.tag The new tag to apply to the dataset.\n     */ async updateDatasetTag(props) {\n        const { datasetId, datasetName, asOf, tag } = props;\n        if (!datasetId && !datasetName) {\n            throw new Error(\"Must provide either datasetName or datasetId\");\n        }\n        const _datasetId = datasetId ?? (await this.readDataset({\n            datasetName\n        })).id;\n        (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_4__.assertUuid)(_datasetId);\n        const response = await this.caller.call((0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_8__._getFetchImplementation)(), `${this.apiUrl}/datasets/${_datasetId}/tags`, {\n            method: \"PUT\",\n            headers: {\n                ...this.headers,\n                \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify({\n                as_of: typeof asOf === \"string\" ? asOf : asOf.toISOString(),\n                tag\n            }),\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions\n        });\n        await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_7__.raiseForStatus)(response, \"update dataset tags\");\n    }\n    async deleteDataset({ datasetId, datasetName }) {\n        let path = \"/datasets\";\n        let datasetId_ = datasetId;\n        if (datasetId !== undefined && datasetName !== undefined) {\n            throw new Error(\"Must provide either datasetName or datasetId, not both\");\n        } else if (datasetName !== undefined) {\n            const dataset = await this.readDataset({\n                datasetName\n            });\n            datasetId_ = dataset.id;\n        }\n        if (datasetId_ !== undefined) {\n            (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_4__.assertUuid)(datasetId_);\n            path += `/${datasetId_}`;\n        } else {\n            throw new Error(\"Must provide datasetName or datasetId\");\n        }\n        const response = await this.caller.call((0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_8__._getFetchImplementation)(), this.apiUrl + path, {\n            method: \"DELETE\",\n            headers: this.headers,\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions\n        });\n        await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_7__.raiseForStatus)(response, `delete ${path}`);\n        await response.json();\n    }\n    async indexDataset({ datasetId, datasetName, tag }) {\n        let datasetId_ = datasetId;\n        if (!datasetId_ && !datasetName) {\n            throw new Error(\"Must provide either datasetName or datasetId\");\n        } else if (datasetId_ && datasetName) {\n            throw new Error(\"Must provide either datasetName or datasetId, not both\");\n        } else if (!datasetId_) {\n            const dataset = await this.readDataset({\n                datasetName\n            });\n            datasetId_ = dataset.id;\n        }\n        (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_4__.assertUuid)(datasetId_);\n        const data = {\n            tag: tag\n        };\n        const response = await this.caller.call((0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_8__._getFetchImplementation)(), `${this.apiUrl}/datasets/${datasetId_}/index`, {\n            method: \"POST\",\n            headers: {\n                ...this.headers,\n                \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify(data),\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions\n        });\n        await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_7__.raiseForStatus)(response, \"index dataset\");\n        await response.json();\n    }\n    /**\n     * Lets you run a similarity search query on a dataset.\n     *\n     * Requires the dataset to be indexed. Please see the `indexDataset` method to set up indexing.\n     *\n     * @param inputs      The input on which to run the similarity search. Must have the\n     *                    same schema as the dataset.\n     *\n     * @param datasetId   The dataset to search for similar examples.\n     *\n     * @param limit       The maximum number of examples to return. Will return the top `limit` most\n     *                    similar examples in order of most similar to least similar. If no similar\n     *                    examples are found, random examples will be returned.\n     *\n     * @param filter      A filter string to apply to the search. Only examples will be returned that\n     *                    match the filter string. Some examples of filters\n     *\n     *                    - eq(metadata.mykey, \"value\")\n     *                    - and(neq(metadata.my.nested.key, \"value\"), neq(metadata.mykey, \"value\"))\n     *                    - or(eq(metadata.mykey, \"value\"), eq(metadata.mykey, \"othervalue\"))\n     *\n     * @returns           A list of similar examples.\n     *\n     *\n     * @example\n     * dataset_id = \"123e4567-e89b-12d3-a456-426614174000\"\n     * inputs = {\"text\": \"How many people live in Berlin?\"}\n     * limit = 5\n     * examples = await client.similarExamples(inputs, dataset_id, limit)\n     */ async similarExamples(inputs, datasetId, limit, { filter } = {}) {\n        const data = {\n            limit: limit,\n            inputs: inputs\n        };\n        if (filter !== undefined) {\n            data[\"filter\"] = filter;\n        }\n        (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_4__.assertUuid)(datasetId);\n        const response = await this.caller.call((0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_8__._getFetchImplementation)(), `${this.apiUrl}/datasets/${datasetId}/search`, {\n            method: \"POST\",\n            headers: {\n                ...this.headers,\n                \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify(data),\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions\n        });\n        await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_7__.raiseForStatus)(response, \"fetch similar examples\");\n        const result = await response.json();\n        return result[\"examples\"];\n    }\n    async createExample(inputsOrUpdate, outputs, options) {\n        if (isExampleCreate(inputsOrUpdate)) {\n            if (outputs !== undefined || options !== undefined) {\n                throw new Error(\"Cannot provide outputs or options when using ExampleCreate object\");\n            }\n        }\n        let datasetId_ = outputs ? options?.datasetId : inputsOrUpdate.dataset_id;\n        const datasetName_ = outputs ? options?.datasetName : inputsOrUpdate.dataset_name;\n        if (datasetId_ === undefined && datasetName_ === undefined) {\n            throw new Error(\"Must provide either datasetName or datasetId\");\n        } else if (datasetId_ !== undefined && datasetName_ !== undefined) {\n            throw new Error(\"Must provide either datasetName or datasetId, not both\");\n        } else if (datasetId_ === undefined) {\n            const dataset = await this.readDataset({\n                datasetName: datasetName_\n            });\n            datasetId_ = dataset.id;\n        }\n        const createdAt_ = (outputs ? options?.createdAt : inputsOrUpdate.created_at) || new Date();\n        let data;\n        if (!isExampleCreate(inputsOrUpdate)) {\n            data = {\n                inputs: inputsOrUpdate,\n                outputs,\n                created_at: createdAt_?.toISOString(),\n                id: options?.exampleId,\n                metadata: options?.metadata,\n                split: options?.split,\n                source_run_id: options?.sourceRunId,\n                use_source_run_io: options?.useSourceRunIO,\n                use_source_run_attachments: options?.useSourceRunAttachments,\n                attachments: options?.attachments\n            };\n        } else {\n            data = inputsOrUpdate;\n        }\n        const response = await this._uploadExamplesMultipart(datasetId_, [\n            data\n        ]);\n        const example = await this.readExample(response.example_ids?.[0] ?? uuid__WEBPACK_IMPORTED_MODULE_10__[\"default\"]());\n        return example;\n    }\n    async createExamples(propsOrUploads) {\n        if (Array.isArray(propsOrUploads)) {\n            if (propsOrUploads.length === 0) {\n                return [];\n            }\n            const uploads = propsOrUploads;\n            let datasetId_ = uploads[0].dataset_id;\n            const datasetName_ = uploads[0].dataset_name;\n            if (datasetId_ === undefined && datasetName_ === undefined) {\n                throw new Error(\"Must provide either datasetName or datasetId\");\n            } else if (datasetId_ !== undefined && datasetName_ !== undefined) {\n                throw new Error(\"Must provide either datasetName or datasetId, not both\");\n            } else if (datasetId_ === undefined) {\n                const dataset = await this.readDataset({\n                    datasetName: datasetName_\n                });\n                datasetId_ = dataset.id;\n            }\n            const response = await this._uploadExamplesMultipart(datasetId_, uploads);\n            const examples = await Promise.all(response.example_ids.map((id)=>this.readExample(id)));\n            return examples;\n        }\n        const { inputs, outputs, metadata, splits, sourceRunIds, useSourceRunIOs, useSourceRunAttachments, attachments, exampleIds, datasetId, datasetName } = propsOrUploads;\n        if (inputs === undefined) {\n            throw new Error(\"Must provide inputs when using legacy parameters\");\n        }\n        let datasetId_ = datasetId;\n        const datasetName_ = datasetName;\n        if (datasetId_ === undefined && datasetName_ === undefined) {\n            throw new Error(\"Must provide either datasetName or datasetId\");\n        } else if (datasetId_ !== undefined && datasetName_ !== undefined) {\n            throw new Error(\"Must provide either datasetName or datasetId, not both\");\n        } else if (datasetId_ === undefined) {\n            const dataset = await this.readDataset({\n                datasetName: datasetName_\n            });\n            datasetId_ = dataset.id;\n        }\n        const formattedExamples = inputs.map((input, idx)=>{\n            return {\n                dataset_id: datasetId_,\n                inputs: input,\n                outputs: outputs?.[idx],\n                metadata: metadata?.[idx],\n                split: splits?.[idx],\n                id: exampleIds?.[idx],\n                attachments: attachments?.[idx],\n                source_run_id: sourceRunIds?.[idx],\n                use_source_run_io: useSourceRunIOs?.[idx],\n                use_source_run_attachments: useSourceRunAttachments?.[idx]\n            };\n        });\n        const response = await this._uploadExamplesMultipart(datasetId_, formattedExamples);\n        const examples = await Promise.all(response.example_ids.map((id)=>this.readExample(id)));\n        return examples;\n    }\n    async createLLMExample(input, generation, options) {\n        return this.createExample({\n            input\n        }, {\n            output: generation\n        }, options);\n    }\n    async createChatExample(input, generations, options) {\n        const finalInput = input.map((message)=>{\n            if ((0,_utils_messages_js__WEBPACK_IMPORTED_MODULE_1__.isLangChainMessage)(message)) {\n                return (0,_utils_messages_js__WEBPACK_IMPORTED_MODULE_1__.convertLangChainMessageToExample)(message);\n            }\n            return message;\n        });\n        const finalOutput = (0,_utils_messages_js__WEBPACK_IMPORTED_MODULE_1__.isLangChainMessage)(generations) ? (0,_utils_messages_js__WEBPACK_IMPORTED_MODULE_1__.convertLangChainMessageToExample)(generations) : generations;\n        return this.createExample({\n            input: finalInput\n        }, {\n            output: finalOutput\n        }, options);\n    }\n    async readExample(exampleId) {\n        (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_4__.assertUuid)(exampleId);\n        const path = `/examples/${exampleId}`;\n        const rawExample = await this._get(path);\n        const { attachment_urls, ...rest } = rawExample;\n        const example = rest;\n        if (attachment_urls) {\n            example.attachments = Object.entries(attachment_urls).reduce((acc, [key, value])=>{\n                acc[key.slice(\"attachment.\".length)] = {\n                    presigned_url: value.presigned_url,\n                    mime_type: value.mime_type\n                };\n                return acc;\n            }, {});\n        }\n        return example;\n    }\n    async *listExamples({ datasetId, datasetName, exampleIds, asOf, splits, inlineS3Urls, metadata, limit, offset, filter, includeAttachments } = {}) {\n        let datasetId_;\n        if (datasetId !== undefined && datasetName !== undefined) {\n            throw new Error(\"Must provide either datasetName or datasetId, not both\");\n        } else if (datasetId !== undefined) {\n            datasetId_ = datasetId;\n        } else if (datasetName !== undefined) {\n            const dataset = await this.readDataset({\n                datasetName\n            });\n            datasetId_ = dataset.id;\n        } else {\n            throw new Error(\"Must provide a datasetName or datasetId\");\n        }\n        const params = new URLSearchParams({\n            dataset: datasetId_\n        });\n        const dataset_version = asOf ? typeof asOf === \"string\" ? asOf : asOf?.toISOString() : undefined;\n        if (dataset_version) {\n            params.append(\"as_of\", dataset_version);\n        }\n        const inlineS3Urls_ = inlineS3Urls ?? true;\n        params.append(\"inline_s3_urls\", inlineS3Urls_.toString());\n        if (exampleIds !== undefined) {\n            for (const id_ of exampleIds){\n                params.append(\"id\", id_);\n            }\n        }\n        if (splits !== undefined) {\n            for (const split of splits){\n                params.append(\"splits\", split);\n            }\n        }\n        if (metadata !== undefined) {\n            const serializedMetadata = JSON.stringify(metadata);\n            params.append(\"metadata\", serializedMetadata);\n        }\n        if (limit !== undefined) {\n            params.append(\"limit\", limit.toString());\n        }\n        if (offset !== undefined) {\n            params.append(\"offset\", offset.toString());\n        }\n        if (filter !== undefined) {\n            params.append(\"filter\", filter);\n        }\n        if (includeAttachments === true) {\n            [\n                \"attachment_urls\",\n                \"outputs\",\n                \"metadata\"\n            ].forEach((field)=>params.append(\"select\", field));\n        }\n        let i = 0;\n        for await (const rawExamples of this._getPaginated(\"/examples\", params)){\n            for (const rawExample of rawExamples){\n                const { attachment_urls, ...rest } = rawExample;\n                const example = rest;\n                if (attachment_urls) {\n                    example.attachments = Object.entries(attachment_urls).reduce((acc, [key, value])=>{\n                        acc[key.slice(\"attachment.\".length)] = {\n                            presigned_url: value.presigned_url,\n                            mime_type: value.mime_type || undefined\n                        };\n                        return acc;\n                    }, {});\n                }\n                yield example;\n                i++;\n            }\n            if (limit !== undefined && i >= limit) {\n                break;\n            }\n        }\n    }\n    async deleteExample(exampleId) {\n        (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_4__.assertUuid)(exampleId);\n        const path = `/examples/${exampleId}`;\n        const response = await this.caller.call((0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_8__._getFetchImplementation)(), this.apiUrl + path, {\n            method: \"DELETE\",\n            headers: this.headers,\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions\n        });\n        await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_7__.raiseForStatus)(response, `delete ${path}`);\n        await response.json();\n    }\n    async updateExample(exampleIdOrUpdate, update) {\n        let exampleId;\n        if (update) {\n            exampleId = exampleIdOrUpdate;\n        } else {\n            exampleId = exampleIdOrUpdate.id;\n        }\n        (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_4__.assertUuid)(exampleId);\n        let updateToUse;\n        if (update) {\n            updateToUse = {\n                id: exampleId,\n                ...update\n            };\n        } else {\n            updateToUse = exampleIdOrUpdate;\n        }\n        let datasetId;\n        if (updateToUse.dataset_id !== undefined) {\n            datasetId = updateToUse.dataset_id;\n        } else {\n            const example = await this.readExample(exampleId);\n            datasetId = example.dataset_id;\n        }\n        return this._updateExamplesMultipart(datasetId, [\n            updateToUse\n        ]);\n    }\n    async updateExamples(update) {\n        // We will naively get dataset id from first example and assume it works for all\n        let datasetId;\n        if (update[0].dataset_id === undefined) {\n            const example = await this.readExample(update[0].id);\n            datasetId = example.dataset_id;\n        } else {\n            datasetId = update[0].dataset_id;\n        }\n        return this._updateExamplesMultipart(datasetId, update);\n    }\n    /**\n     * Get dataset version by closest date or exact tag.\n     *\n     * Use this to resolve the nearest version to a given timestamp or for a given tag.\n     *\n     * @param options The options for getting the dataset version\n     * @param options.datasetId The ID of the dataset\n     * @param options.datasetName The name of the dataset\n     * @param options.asOf The timestamp of the dataset to retrieve\n     * @param options.tag The tag of the dataset to retrieve\n     * @returns The dataset version\n     */ async readDatasetVersion({ datasetId, datasetName, asOf, tag }) {\n        let resolvedDatasetId;\n        if (!datasetId) {\n            const dataset = await this.readDataset({\n                datasetName\n            });\n            resolvedDatasetId = dataset.id;\n        } else {\n            resolvedDatasetId = datasetId;\n        }\n        (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_4__.assertUuid)(resolvedDatasetId);\n        if (asOf && tag || !asOf && !tag) {\n            throw new Error(\"Exactly one of asOf and tag must be specified.\");\n        }\n        const params = new URLSearchParams();\n        if (asOf !== undefined) {\n            params.append(\"as_of\", typeof asOf === \"string\" ? asOf : asOf.toISOString());\n        }\n        if (tag !== undefined) {\n            params.append(\"tag\", tag);\n        }\n        const response = await this.caller.call((0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_8__._getFetchImplementation)(), `${this.apiUrl}/datasets/${resolvedDatasetId}/version?${params.toString()}`, {\n            method: \"GET\",\n            headers: {\n                ...this.headers\n            },\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions\n        });\n        await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_7__.raiseForStatus)(response, \"read dataset version\");\n        return await response.json();\n    }\n    async listDatasetSplits({ datasetId, datasetName, asOf }) {\n        let datasetId_;\n        if (datasetId === undefined && datasetName === undefined) {\n            throw new Error(\"Must provide dataset name or ID\");\n        } else if (datasetId !== undefined && datasetName !== undefined) {\n            throw new Error(\"Must provide either datasetName or datasetId, not both\");\n        } else if (datasetId === undefined) {\n            const dataset = await this.readDataset({\n                datasetName\n            });\n            datasetId_ = dataset.id;\n        } else {\n            datasetId_ = datasetId;\n        }\n        (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_4__.assertUuid)(datasetId_);\n        const params = new URLSearchParams();\n        const dataset_version = asOf ? typeof asOf === \"string\" ? asOf : asOf?.toISOString() : undefined;\n        if (dataset_version) {\n            params.append(\"as_of\", dataset_version);\n        }\n        const response = await this._get(`/datasets/${datasetId_}/splits`, params);\n        return response;\n    }\n    async updateDatasetSplits({ datasetId, datasetName, splitName, exampleIds, remove = false }) {\n        let datasetId_;\n        if (datasetId === undefined && datasetName === undefined) {\n            throw new Error(\"Must provide dataset name or ID\");\n        } else if (datasetId !== undefined && datasetName !== undefined) {\n            throw new Error(\"Must provide either datasetName or datasetId, not both\");\n        } else if (datasetId === undefined) {\n            const dataset = await this.readDataset({\n                datasetName\n            });\n            datasetId_ = dataset.id;\n        } else {\n            datasetId_ = datasetId;\n        }\n        (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_4__.assertUuid)(datasetId_);\n        const data = {\n            split_name: splitName,\n            examples: exampleIds.map((id)=>{\n                (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_4__.assertUuid)(id);\n                return id;\n            }),\n            remove\n        };\n        const response = await this.caller.call((0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_8__._getFetchImplementation)(), `${this.apiUrl}/datasets/${datasetId_}/splits`, {\n            method: \"PUT\",\n            headers: {\n                ...this.headers,\n                \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify(data),\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions\n        });\n        await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_7__.raiseForStatus)(response, \"update dataset splits\", true);\n    }\n    /**\n     * @deprecated This method is deprecated and will be removed in future LangSmith versions, use `evaluate` from `langsmith/evaluation` instead.\n     */ async evaluateRun(run, evaluator, { sourceInfo, loadChildRuns, referenceExample } = {\n        loadChildRuns: false\n    }) {\n        (0,_utils_warn_js__WEBPACK_IMPORTED_MODULE_5__.warnOnce)(\"This method is deprecated and will be removed in future LangSmith versions, use `evaluate` from `langsmith/evaluation` instead.\");\n        let run_;\n        if (typeof run === \"string\") {\n            run_ = await this.readRun(run, {\n                loadChildRuns\n            });\n        } else if (typeof run === \"object\" && \"id\" in run) {\n            run_ = run;\n        } else {\n            throw new Error(`Invalid run type: ${typeof run}`);\n        }\n        if (run_.reference_example_id !== null && run_.reference_example_id !== undefined) {\n            referenceExample = await this.readExample(run_.reference_example_id);\n        }\n        const feedbackResult = await evaluator.evaluateRun(run_, referenceExample);\n        const [_, feedbacks] = await this._logEvaluationFeedback(feedbackResult, run_, sourceInfo);\n        return feedbacks[0];\n    }\n    async createFeedback(runId, key, { score, value, correction, comment, sourceInfo, feedbackSourceType = \"api\", sourceRunId, feedbackId, feedbackConfig, projectId, comparativeExperimentId }) {\n        if (!runId && !projectId) {\n            throw new Error(\"One of runId or projectId must be provided\");\n        }\n        if (runId && projectId) {\n            throw new Error(\"Only one of runId or projectId can be provided\");\n        }\n        const feedback_source = {\n            type: feedbackSourceType ?? \"api\",\n            metadata: sourceInfo ?? {}\n        };\n        if (sourceRunId !== undefined && feedback_source?.metadata !== undefined && !feedback_source.metadata[\"__run\"]) {\n            feedback_source.metadata[\"__run\"] = {\n                run_id: sourceRunId\n            };\n        }\n        if (feedback_source?.metadata !== undefined && feedback_source.metadata[\"__run\"]?.run_id !== undefined) {\n            (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_4__.assertUuid)(feedback_source.metadata[\"__run\"].run_id);\n        }\n        const feedback = {\n            id: feedbackId ?? uuid__WEBPACK_IMPORTED_MODULE_10__[\"default\"](),\n            run_id: runId,\n            key,\n            score: _formatFeedbackScore(score),\n            value,\n            correction,\n            comment,\n            feedback_source: feedback_source,\n            comparative_experiment_id: comparativeExperimentId,\n            feedbackConfig,\n            session_id: projectId\n        };\n        const url = `${this.apiUrl}/feedback`;\n        const response = await this.caller.call((0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_8__._getFetchImplementation)(), url, {\n            method: \"POST\",\n            headers: {\n                ...this.headers,\n                \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify(feedback),\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions\n        });\n        await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_7__.raiseForStatus)(response, \"create feedback\", true);\n        return feedback;\n    }\n    async updateFeedback(feedbackId, { score, value, correction, comment }) {\n        const feedbackUpdate = {};\n        if (score !== undefined && score !== null) {\n            feedbackUpdate[\"score\"] = _formatFeedbackScore(score);\n        }\n        if (value !== undefined && value !== null) {\n            feedbackUpdate[\"value\"] = value;\n        }\n        if (correction !== undefined && correction !== null) {\n            feedbackUpdate[\"correction\"] = correction;\n        }\n        if (comment !== undefined && comment !== null) {\n            feedbackUpdate[\"comment\"] = comment;\n        }\n        (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_4__.assertUuid)(feedbackId);\n        const response = await this.caller.call((0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_8__._getFetchImplementation)(), `${this.apiUrl}/feedback/${feedbackId}`, {\n            method: \"PATCH\",\n            headers: {\n                ...this.headers,\n                \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify(feedbackUpdate),\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions\n        });\n        await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_7__.raiseForStatus)(response, \"update feedback\", true);\n    }\n    async readFeedback(feedbackId) {\n        (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_4__.assertUuid)(feedbackId);\n        const path = `/feedback/${feedbackId}`;\n        const response = await this._get(path);\n        return response;\n    }\n    async deleteFeedback(feedbackId) {\n        (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_4__.assertUuid)(feedbackId);\n        const path = `/feedback/${feedbackId}`;\n        const response = await this.caller.call((0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_8__._getFetchImplementation)(), this.apiUrl + path, {\n            method: \"DELETE\",\n            headers: this.headers,\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions\n        });\n        await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_7__.raiseForStatus)(response, `delete ${path}`);\n        await response.json();\n    }\n    async *listFeedback({ runIds, feedbackKeys, feedbackSourceTypes } = {}) {\n        const queryParams = new URLSearchParams();\n        if (runIds) {\n            queryParams.append(\"run\", runIds.join(\",\"));\n        }\n        if (feedbackKeys) {\n            for (const key of feedbackKeys){\n                queryParams.append(\"key\", key);\n            }\n        }\n        if (feedbackSourceTypes) {\n            for (const type of feedbackSourceTypes){\n                queryParams.append(\"source\", type);\n            }\n        }\n        for await (const feedbacks of this._getPaginated(\"/feedback\", queryParams)){\n            yield* feedbacks;\n        }\n    }\n    /**\n     * Creates a presigned feedback token and URL.\n     *\n     * The token can be used to authorize feedback metrics without\n     * needing an API key. This is useful for giving browser-based\n     * applications the ability to submit feedback without needing\n     * to expose an API key.\n     *\n     * @param runId The ID of the run.\n     * @param feedbackKey The feedback key.\n     * @param options Additional options for the token.\n     * @param options.expiration The expiration time for the token.\n     *\n     * @returns A promise that resolves to a FeedbackIngestToken.\n     */ async createPresignedFeedbackToken(runId, feedbackKey, { expiration, feedbackConfig } = {}) {\n        const body = {\n            run_id: runId,\n            feedback_key: feedbackKey,\n            feedback_config: feedbackConfig\n        };\n        if (expiration) {\n            if (typeof expiration === \"string\") {\n                body[\"expires_at\"] = expiration;\n            } else if (expiration?.hours || expiration?.minutes || expiration?.days) {\n                body[\"expires_in\"] = expiration;\n            }\n        } else {\n            body[\"expires_in\"] = {\n                hours: 3\n            };\n        }\n        const response = await this.caller.call((0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_8__._getFetchImplementation)(), `${this.apiUrl}/feedback/tokens`, {\n            method: \"POST\",\n            headers: {\n                ...this.headers,\n                \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify(body),\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions\n        });\n        const result = await response.json();\n        return result;\n    }\n    async createComparativeExperiment({ name, experimentIds, referenceDatasetId, createdAt, description, metadata, id }) {\n        if (experimentIds.length === 0) {\n            throw new Error(\"At least one experiment is required\");\n        }\n        if (!referenceDatasetId) {\n            referenceDatasetId = (await this.readProject({\n                projectId: experimentIds[0]\n            })).reference_dataset_id;\n        }\n        if (!referenceDatasetId == null) {\n            throw new Error(\"A reference dataset is required\");\n        }\n        const body = {\n            id,\n            name,\n            experiment_ids: experimentIds,\n            reference_dataset_id: referenceDatasetId,\n            description,\n            created_at: (createdAt ?? new Date())?.toISOString(),\n            extra: {}\n        };\n        if (metadata) body.extra[\"metadata\"] = metadata;\n        const response = await this.caller.call((0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_8__._getFetchImplementation)(), `${this.apiUrl}/datasets/comparative`, {\n            method: \"POST\",\n            headers: {\n                ...this.headers,\n                \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify(body),\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions\n        });\n        return await response.json();\n    }\n    /**\n     * Retrieves a list of presigned feedback tokens for a given run ID.\n     * @param runId The ID of the run.\n     * @returns An async iterable of FeedbackIngestToken objects.\n     */ async *listPresignedFeedbackTokens(runId) {\n        (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_4__.assertUuid)(runId);\n        const params = new URLSearchParams({\n            run_id: runId\n        });\n        for await (const tokens of this._getPaginated(\"/feedback/tokens\", params)){\n            yield* tokens;\n        }\n    }\n    _selectEvalResults(results) {\n        let results_;\n        if (\"results\" in results) {\n            results_ = results.results;\n        } else if (Array.isArray(results)) {\n            results_ = results;\n        } else {\n            results_ = [\n                results\n            ];\n        }\n        return results_;\n    }\n    async _logEvaluationFeedback(evaluatorResponse, run, sourceInfo) {\n        const evalResults = this._selectEvalResults(evaluatorResponse);\n        const feedbacks = [];\n        for (const res of evalResults){\n            let sourceInfo_ = sourceInfo || {};\n            if (res.evaluatorInfo) {\n                sourceInfo_ = {\n                    ...res.evaluatorInfo,\n                    ...sourceInfo_\n                };\n            }\n            let runId_ = null;\n            if (res.targetRunId) {\n                runId_ = res.targetRunId;\n            } else if (run) {\n                runId_ = run.id;\n            }\n            feedbacks.push(await this.createFeedback(runId_, res.key, {\n                score: res.score,\n                value: res.value,\n                comment: res.comment,\n                correction: res.correction,\n                sourceInfo: sourceInfo_,\n                sourceRunId: res.sourceRunId,\n                feedbackConfig: res.feedbackConfig,\n                feedbackSourceType: \"model\"\n            }));\n        }\n        return [\n            evalResults,\n            feedbacks\n        ];\n    }\n    async logEvaluationFeedback(evaluatorResponse, run, sourceInfo) {\n        const [results] = await this._logEvaluationFeedback(evaluatorResponse, run, sourceInfo);\n        return results;\n    }\n    /**\n     * API for managing annotation queues\n     */ /**\n     * List the annotation queues on the LangSmith API.\n     * @param options - The options for listing annotation queues\n     * @param options.queueIds - The IDs of the queues to filter by\n     * @param options.name - The name of the queue to filter by\n     * @param options.nameContains - The substring that the queue name should contain\n     * @param options.limit - The maximum number of queues to return\n     * @returns An iterator of AnnotationQueue objects\n     */ async *listAnnotationQueues(options = {}) {\n        const { queueIds, name, nameContains, limit } = options;\n        const params = new URLSearchParams();\n        if (queueIds) {\n            queueIds.forEach((id, i)=>{\n                (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_4__.assertUuid)(id, `queueIds[${i}]`);\n                params.append(\"ids\", id);\n            });\n        }\n        if (name) params.append(\"name\", name);\n        if (nameContains) params.append(\"name_contains\", nameContains);\n        params.append(\"limit\", (limit !== undefined ? Math.min(limit, 100) : 100).toString());\n        let count = 0;\n        for await (const queues of this._getPaginated(\"/annotation-queues\", params)){\n            yield* queues;\n            count++;\n            if (limit !== undefined && count >= limit) break;\n        }\n    }\n    /**\n     * Create an annotation queue on the LangSmith API.\n     * @param options - The options for creating an annotation queue\n     * @param options.name - The name of the annotation queue\n     * @param options.description - The description of the annotation queue\n     * @param options.queueId - The ID of the annotation queue\n     * @returns The created AnnotationQueue object\n     */ async createAnnotationQueue(options) {\n        const { name, description, queueId } = options;\n        const body = {\n            name,\n            description,\n            id: queueId || uuid__WEBPACK_IMPORTED_MODULE_10__[\"default\"]()\n        };\n        const response = await this.caller.call((0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_8__._getFetchImplementation)(), `${this.apiUrl}/annotation-queues`, {\n            method: \"POST\",\n            headers: {\n                ...this.headers,\n                \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify(Object.fromEntries(Object.entries(body).filter(([_, v])=>v !== undefined))),\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions\n        });\n        await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_7__.raiseForStatus)(response, \"create annotation queue\");\n        const data = await response.json();\n        return data;\n    }\n    /**\n     * Read an annotation queue with the specified queue ID.\n     * @param queueId - The ID of the annotation queue to read\n     * @returns The AnnotationQueue object\n     */ async readAnnotationQueue(queueId) {\n        // TODO: Replace when actual endpoint is added\n        const queueIteratorResult = await this.listAnnotationQueues({\n            queueIds: [\n                queueId\n            ]\n        }).next();\n        if (queueIteratorResult.done) {\n            throw new Error(`Annotation queue with ID ${queueId} not found`);\n        }\n        return queueIteratorResult.value;\n    }\n    /**\n     * Update an annotation queue with the specified queue ID.\n     * @param queueId - The ID of the annotation queue to update\n     * @param options - The options for updating the annotation queue\n     * @param options.name - The new name for the annotation queue\n     * @param options.description - The new description for the annotation queue\n     */ async updateAnnotationQueue(queueId, options) {\n        const { name, description } = options;\n        const response = await this.caller.call((0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_8__._getFetchImplementation)(), `${this.apiUrl}/annotation-queues/${(0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_4__.assertUuid)(queueId, \"queueId\")}`, {\n            method: \"PATCH\",\n            headers: {\n                ...this.headers,\n                \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify({\n                name,\n                description\n            }),\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions\n        });\n        await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_7__.raiseForStatus)(response, \"update annotation queue\");\n    }\n    /**\n     * Delete an annotation queue with the specified queue ID.\n     * @param queueId - The ID of the annotation queue to delete\n     */ async deleteAnnotationQueue(queueId) {\n        const response = await this.caller.call((0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_8__._getFetchImplementation)(), `${this.apiUrl}/annotation-queues/${(0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_4__.assertUuid)(queueId, \"queueId\")}`, {\n            method: \"DELETE\",\n            headers: {\n                ...this.headers,\n                Accept: \"application/json\"\n            },\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions\n        });\n        await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_7__.raiseForStatus)(response, \"delete annotation queue\");\n    }\n    /**\n     * Add runs to an annotation queue with the specified queue ID.\n     * @param queueId - The ID of the annotation queue\n     * @param runIds - The IDs of the runs to be added to the annotation queue\n     */ async addRunsToAnnotationQueue(queueId, runIds) {\n        const response = await this.caller.call((0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_8__._getFetchImplementation)(), `${this.apiUrl}/annotation-queues/${(0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_4__.assertUuid)(queueId, \"queueId\")}/runs`, {\n            method: \"POST\",\n            headers: {\n                ...this.headers,\n                \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify(runIds.map((id, i)=>(0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_4__.assertUuid)(id, `runIds[${i}]`).toString())),\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions\n        });\n        await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_7__.raiseForStatus)(response, \"add runs to annotation queue\");\n    }\n    /**\n     * Get a run from an annotation queue at the specified index.\n     * @param queueId - The ID of the annotation queue\n     * @param index - The index of the run to retrieve\n     * @returns A Promise that resolves to a RunWithAnnotationQueueInfo object\n     * @throws {Error} If the run is not found at the given index or for other API-related errors\n     */ async getRunFromAnnotationQueue(queueId, index) {\n        const baseUrl = `/annotation-queues/${(0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_4__.assertUuid)(queueId, \"queueId\")}/run`;\n        const response = await this.caller.call((0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_8__._getFetchImplementation)(), `${this.apiUrl}${baseUrl}/${index}`, {\n            method: \"GET\",\n            headers: this.headers,\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions\n        });\n        await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_7__.raiseForStatus)(response, \"get run from annotation queue\");\n        return await response.json();\n    }\n    /**\n     * Delete a run from an an annotation queue.\n     * @param queueId - The ID of the annotation queue to delete the run from\n     * @param queueRunId - The ID of the run to delete from the annotation queue\n     */ async deleteRunFromAnnotationQueue(queueId, queueRunId) {\n        const response = await this.caller.call((0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_8__._getFetchImplementation)(), `${this.apiUrl}/annotation-queues/${(0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_4__.assertUuid)(queueId, \"queueId\")}/runs/${(0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_4__.assertUuid)(queueRunId, \"queueRunId\")}`, {\n            method: \"DELETE\",\n            headers: {\n                ...this.headers,\n                Accept: \"application/json\"\n            },\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions\n        });\n        await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_7__.raiseForStatus)(response, \"delete run from annotation queue\");\n    }\n    /**\n     * Get the size of an annotation queue.\n     * @param queueId - The ID of the annotation queue\n     */ async getSizeFromAnnotationQueue(queueId) {\n        const response = await this.caller.call((0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_8__._getFetchImplementation)(), `${this.apiUrl}/annotation-queues/${(0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_4__.assertUuid)(queueId, \"queueId\")}/size`, {\n            method: \"GET\",\n            headers: this.headers,\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions\n        });\n        await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_7__.raiseForStatus)(response, \"get size from annotation queue\");\n        return await response.json();\n    }\n    async _currentTenantIsOwner(owner) {\n        const settings = await this._getSettings();\n        return owner == \"-\" || settings.tenant_handle === owner;\n    }\n    async _ownerConflictError(action, owner) {\n        const settings = await this._getSettings();\n        return new Error(`Cannot ${action} for another tenant.\\n\n      Current tenant: ${settings.tenant_handle}\\n\n      Requested tenant: ${owner}`);\n    }\n    async _getLatestCommitHash(promptOwnerAndName) {\n        const res = await this.caller.call((0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_8__._getFetchImplementation)(), `${this.apiUrl}/commits/${promptOwnerAndName}/?limit=${1}&offset=${0}`, {\n            method: \"GET\",\n            headers: this.headers,\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions\n        });\n        const json = await res.json();\n        if (!res.ok) {\n            const detail = typeof json.detail === \"string\" ? json.detail : JSON.stringify(json.detail);\n            const error = new Error(`Error ${res.status}: ${res.statusText}\\n${detail}`);\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            error.statusCode = res.status;\n            throw error;\n        }\n        if (json.commits.length === 0) {\n            return undefined;\n        }\n        return json.commits[0].commit_hash;\n    }\n    async _likeOrUnlikePrompt(promptIdentifier, like) {\n        const [owner, promptName, _] = (0,_utils_prompts_js__WEBPACK_IMPORTED_MODULE_6__.parsePromptIdentifier)(promptIdentifier);\n        const response = await this.caller.call((0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_8__._getFetchImplementation)(), `${this.apiUrl}/likes/${owner}/${promptName}`, {\n            method: \"POST\",\n            body: JSON.stringify({\n                like: like\n            }),\n            headers: {\n                ...this.headers,\n                \"Content-Type\": \"application/json\"\n            },\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions\n        });\n        await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_7__.raiseForStatus)(response, `${like ? \"like\" : \"unlike\"} prompt`);\n        return await response.json();\n    }\n    async _getPromptUrl(promptIdentifier) {\n        const [owner, promptName, commitHash] = (0,_utils_prompts_js__WEBPACK_IMPORTED_MODULE_6__.parsePromptIdentifier)(promptIdentifier);\n        if (!await this._currentTenantIsOwner(owner)) {\n            if (commitHash !== \"latest\") {\n                return `${this.getHostUrl()}/hub/${owner}/${promptName}/${commitHash.substring(0, 8)}`;\n            } else {\n                return `${this.getHostUrl()}/hub/${owner}/${promptName}`;\n            }\n        } else {\n            const settings = await this._getSettings();\n            if (commitHash !== \"latest\") {\n                return `${this.getHostUrl()}/prompts/${promptName}/${commitHash.substring(0, 8)}?organizationId=${settings.id}`;\n            } else {\n                return `${this.getHostUrl()}/prompts/${promptName}?organizationId=${settings.id}`;\n            }\n        }\n    }\n    async promptExists(promptIdentifier) {\n        const prompt = await this.getPrompt(promptIdentifier);\n        return !!prompt;\n    }\n    async likePrompt(promptIdentifier) {\n        return this._likeOrUnlikePrompt(promptIdentifier, true);\n    }\n    async unlikePrompt(promptIdentifier) {\n        return this._likeOrUnlikePrompt(promptIdentifier, false);\n    }\n    async *listCommits(promptOwnerAndName) {\n        for await (const commits of this._getPaginated(`/commits/${promptOwnerAndName}/`, new URLSearchParams(), (res)=>res.commits)){\n            yield* commits;\n        }\n    }\n    async *listPrompts(options) {\n        const params = new URLSearchParams();\n        params.append(\"sort_field\", options?.sortField ?? \"updated_at\");\n        params.append(\"sort_direction\", \"desc\");\n        params.append(\"is_archived\", (!!options?.isArchived).toString());\n        if (options?.isPublic !== undefined) {\n            params.append(\"is_public\", options.isPublic.toString());\n        }\n        if (options?.query) {\n            params.append(\"query\", options.query);\n        }\n        for await (const prompts of this._getPaginated(\"/repos\", params, (res)=>res.repos)){\n            yield* prompts;\n        }\n    }\n    async getPrompt(promptIdentifier) {\n        const [owner, promptName, _] = (0,_utils_prompts_js__WEBPACK_IMPORTED_MODULE_6__.parsePromptIdentifier)(promptIdentifier);\n        const response = await this.caller.call((0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_8__._getFetchImplementation)(), `${this.apiUrl}/repos/${owner}/${promptName}`, {\n            method: \"GET\",\n            headers: this.headers,\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions\n        });\n        if (response.status === 404) {\n            return null;\n        }\n        await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_7__.raiseForStatus)(response, \"get prompt\");\n        const result = await response.json();\n        if (result.repo) {\n            return result.repo;\n        } else {\n            return null;\n        }\n    }\n    async createPrompt(promptIdentifier, options) {\n        const settings = await this._getSettings();\n        if (options?.isPublic && !settings.tenant_handle) {\n            throw new Error(`Cannot create a public prompt without first\\n\n        creating a LangChain Hub handle. \n        You can add a handle by creating a public prompt at:\\n\n        https://smith.langchain.com/prompts`);\n        }\n        const [owner, promptName, _] = (0,_utils_prompts_js__WEBPACK_IMPORTED_MODULE_6__.parsePromptIdentifier)(promptIdentifier);\n        if (!await this._currentTenantIsOwner(owner)) {\n            throw await this._ownerConflictError(\"create a prompt\", owner);\n        }\n        const data = {\n            repo_handle: promptName,\n            ...options?.description && {\n                description: options.description\n            },\n            ...options?.readme && {\n                readme: options.readme\n            },\n            ...options?.tags && {\n                tags: options.tags\n            },\n            is_public: !!options?.isPublic\n        };\n        const response = await this.caller.call((0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_8__._getFetchImplementation)(), `${this.apiUrl}/repos/`, {\n            method: \"POST\",\n            headers: {\n                ...this.headers,\n                \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify(data),\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions\n        });\n        await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_7__.raiseForStatus)(response, \"create prompt\");\n        const { repo } = await response.json();\n        return repo;\n    }\n    async createCommit(promptIdentifier, object, options) {\n        if (!await this.promptExists(promptIdentifier)) {\n            throw new Error(\"Prompt does not exist, you must create it first.\");\n        }\n        const [owner, promptName, _] = (0,_utils_prompts_js__WEBPACK_IMPORTED_MODULE_6__.parsePromptIdentifier)(promptIdentifier);\n        const resolvedParentCommitHash = options?.parentCommitHash === \"latest\" || !options?.parentCommitHash ? await this._getLatestCommitHash(`${owner}/${promptName}`) : options?.parentCommitHash;\n        const payload = {\n            manifest: JSON.parse(JSON.stringify(object)),\n            parent_commit: resolvedParentCommitHash\n        };\n        const response = await this.caller.call((0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_8__._getFetchImplementation)(), `${this.apiUrl}/commits/${owner}/${promptName}`, {\n            method: \"POST\",\n            headers: {\n                ...this.headers,\n                \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify(payload),\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions\n        });\n        await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_7__.raiseForStatus)(response, \"create commit\");\n        const result = await response.json();\n        return this._getPromptUrl(`${owner}/${promptName}${result.commit_hash ? `:${result.commit_hash}` : \"\"}`);\n    }\n    /**\n     * Update examples with attachments using multipart form data.\n     * @param updates List of ExampleUpdateWithAttachments objects to upsert\n     * @returns Promise with the update response\n     */ async updateExamplesMultipart(datasetId, updates = []) {\n        return this._updateExamplesMultipart(datasetId, updates);\n    }\n    async _updateExamplesMultipart(datasetId, updates = []) {\n        if (!await this._getMultiPartSupport()) {\n            throw new Error(\"Your LangSmith version does not allow using the multipart examples endpoint, please update to the latest version.\");\n        }\n        const formData = new FormData();\n        for (const example of updates){\n            const exampleId = example.id;\n            // Prepare the main example body\n            const exampleBody = {\n                ...example.metadata && {\n                    metadata: example.metadata\n                },\n                ...example.split && {\n                    split: example.split\n                }\n            };\n            // Add main example data\n            const stringifiedExample = (0,_utils_fast_safe_stringify_index_js__WEBPACK_IMPORTED_MODULE_9__.serialize)(exampleBody);\n            const exampleBlob = new Blob([\n                stringifiedExample\n            ], {\n                type: \"application/json\"\n            });\n            formData.append(exampleId, exampleBlob);\n            // Add inputs if present\n            if (example.inputs) {\n                const stringifiedInputs = (0,_utils_fast_safe_stringify_index_js__WEBPACK_IMPORTED_MODULE_9__.serialize)(example.inputs);\n                const inputsBlob = new Blob([\n                    stringifiedInputs\n                ], {\n                    type: \"application/json\"\n                });\n                formData.append(`${exampleId}.inputs`, inputsBlob);\n            }\n            // Add outputs if present\n            if (example.outputs) {\n                const stringifiedOutputs = (0,_utils_fast_safe_stringify_index_js__WEBPACK_IMPORTED_MODULE_9__.serialize)(example.outputs);\n                const outputsBlob = new Blob([\n                    stringifiedOutputs\n                ], {\n                    type: \"application/json\"\n                });\n                formData.append(`${exampleId}.outputs`, outputsBlob);\n            }\n            // Add attachments if present\n            if (example.attachments) {\n                for (const [name, attachment] of Object.entries(example.attachments)){\n                    let mimeType;\n                    let data;\n                    if (Array.isArray(attachment)) {\n                        [mimeType, data] = attachment;\n                    } else {\n                        mimeType = attachment.mimeType;\n                        data = attachment.data;\n                    }\n                    const attachmentBlob = new Blob([\n                        data\n                    ], {\n                        type: `${mimeType}; length=${data.byteLength}`\n                    });\n                    formData.append(`${exampleId}.attachment.${name}`, attachmentBlob);\n                }\n            }\n            if (example.attachments_operations) {\n                const stringifiedAttachmentsOperations = (0,_utils_fast_safe_stringify_index_js__WEBPACK_IMPORTED_MODULE_9__.serialize)(example.attachments_operations);\n                const attachmentsOperationsBlob = new Blob([\n                    stringifiedAttachmentsOperations\n                ], {\n                    type: \"application/json\"\n                });\n                formData.append(`${exampleId}.attachments_operations`, attachmentsOperationsBlob);\n            }\n        }\n        const datasetIdToUse = datasetId ?? updates[0]?.dataset_id;\n        const response = await this.caller.call((0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_8__._getFetchImplementation)(), `${this.apiUrl}/v1/platform/datasets/${datasetIdToUse}/examples`, {\n            method: \"PATCH\",\n            headers: this.headers,\n            body: formData\n        });\n        const result = await response.json();\n        return result;\n    }\n    /**\n     * Upload examples with attachments using multipart form data.\n     * @param uploads List of ExampleUploadWithAttachments objects to upload\n     * @returns Promise with the upload response\n     * @deprecated This method is deprecated and will be removed in future LangSmith versions, please use `createExamples` instead\n     */ async uploadExamplesMultipart(datasetId, uploads = []) {\n        return this._uploadExamplesMultipart(datasetId, uploads);\n    }\n    async _uploadExamplesMultipart(datasetId, uploads = []) {\n        if (!await this._getMultiPartSupport()) {\n            throw new Error(\"Your LangSmith version does not allow using the multipart examples endpoint, please update to the latest version.\");\n        }\n        const formData = new FormData();\n        for (const example of uploads){\n            const exampleId = (example.id ?? uuid__WEBPACK_IMPORTED_MODULE_10__[\"default\"]()).toString();\n            // Prepare the main example body\n            const exampleBody = {\n                created_at: example.created_at,\n                ...example.metadata && {\n                    metadata: example.metadata\n                },\n                ...example.split && {\n                    split: example.split\n                },\n                ...example.source_run_id && {\n                    source_run_id: example.source_run_id\n                },\n                ...example.use_source_run_io && {\n                    use_source_run_io: example.use_source_run_io\n                },\n                ...example.use_source_run_attachments && {\n                    use_source_run_attachments: example.use_source_run_attachments\n                }\n            };\n            // Add main example data\n            const stringifiedExample = (0,_utils_fast_safe_stringify_index_js__WEBPACK_IMPORTED_MODULE_9__.serialize)(exampleBody);\n            const exampleBlob = new Blob([\n                stringifiedExample\n            ], {\n                type: \"application/json\"\n            });\n            formData.append(exampleId, exampleBlob);\n            // Add inputs if present\n            if (example.inputs) {\n                const stringifiedInputs = (0,_utils_fast_safe_stringify_index_js__WEBPACK_IMPORTED_MODULE_9__.serialize)(example.inputs);\n                const inputsBlob = new Blob([\n                    stringifiedInputs\n                ], {\n                    type: \"application/json\"\n                });\n                formData.append(`${exampleId}.inputs`, inputsBlob);\n            }\n            // Add outputs if present\n            if (example.outputs) {\n                const stringifiedOutputs = (0,_utils_fast_safe_stringify_index_js__WEBPACK_IMPORTED_MODULE_9__.serialize)(example.outputs);\n                const outputsBlob = new Blob([\n                    stringifiedOutputs\n                ], {\n                    type: \"application/json\"\n                });\n                formData.append(`${exampleId}.outputs`, outputsBlob);\n            }\n            // Add attachments if present\n            if (example.attachments) {\n                for (const [name, attachment] of Object.entries(example.attachments)){\n                    let mimeType;\n                    let data;\n                    if (Array.isArray(attachment)) {\n                        [mimeType, data] = attachment;\n                    } else {\n                        mimeType = attachment.mimeType;\n                        data = attachment.data;\n                    }\n                    const attachmentBlob = new Blob([\n                        data\n                    ], {\n                        type: `${mimeType}; length=${data.byteLength}`\n                    });\n                    formData.append(`${exampleId}.attachment.${name}`, attachmentBlob);\n                }\n            }\n        }\n        const response = await this.caller.call((0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_8__._getFetchImplementation)(), `${this.apiUrl}/v1/platform/datasets/${datasetId}/examples`, {\n            method: \"POST\",\n            headers: this.headers,\n            body: formData\n        });\n        const result = await response.json();\n        return result;\n    }\n    async updatePrompt(promptIdentifier, options) {\n        if (!await this.promptExists(promptIdentifier)) {\n            throw new Error(\"Prompt does not exist, you must create it first.\");\n        }\n        const [owner, promptName] = (0,_utils_prompts_js__WEBPACK_IMPORTED_MODULE_6__.parsePromptIdentifier)(promptIdentifier);\n        if (!await this._currentTenantIsOwner(owner)) {\n            throw await this._ownerConflictError(\"update a prompt\", owner);\n        }\n        const payload = {};\n        if (options?.description !== undefined) payload.description = options.description;\n        if (options?.readme !== undefined) payload.readme = options.readme;\n        if (options?.tags !== undefined) payload.tags = options.tags;\n        if (options?.isPublic !== undefined) payload.is_public = options.isPublic;\n        if (options?.isArchived !== undefined) payload.is_archived = options.isArchived;\n        // Check if payload is empty\n        if (Object.keys(payload).length === 0) {\n            throw new Error(\"No valid update options provided\");\n        }\n        const response = await this.caller.call((0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_8__._getFetchImplementation)(), `${this.apiUrl}/repos/${owner}/${promptName}`, {\n            method: \"PATCH\",\n            body: JSON.stringify(payload),\n            headers: {\n                ...this.headers,\n                \"Content-Type\": \"application/json\"\n            },\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions\n        });\n        await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_7__.raiseForStatus)(response, \"update prompt\");\n        return response.json();\n    }\n    async deletePrompt(promptIdentifier) {\n        if (!await this.promptExists(promptIdentifier)) {\n            throw new Error(\"Prompt does not exist, you must create it first.\");\n        }\n        const [owner, promptName, _] = (0,_utils_prompts_js__WEBPACK_IMPORTED_MODULE_6__.parsePromptIdentifier)(promptIdentifier);\n        if (!await this._currentTenantIsOwner(owner)) {\n            throw await this._ownerConflictError(\"delete a prompt\", owner);\n        }\n        const response = await this.caller.call((0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_8__._getFetchImplementation)(), `${this.apiUrl}/repos/${owner}/${promptName}`, {\n            method: \"DELETE\",\n            headers: this.headers,\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions\n        });\n        return await response.json();\n    }\n    async pullPromptCommit(promptIdentifier, options) {\n        const [owner, promptName, commitHash] = (0,_utils_prompts_js__WEBPACK_IMPORTED_MODULE_6__.parsePromptIdentifier)(promptIdentifier);\n        const response = await this.caller.call((0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_8__._getFetchImplementation)(), `${this.apiUrl}/commits/${owner}/${promptName}/${commitHash}${options?.includeModel ? \"?include_model=true\" : \"\"}`, {\n            method: \"GET\",\n            headers: this.headers,\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions\n        });\n        await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_7__.raiseForStatus)(response, \"pull prompt commit\");\n        const result = await response.json();\n        return {\n            owner,\n            repo: promptName,\n            commit_hash: result.commit_hash,\n            manifest: result.manifest,\n            examples: result.examples\n        };\n    }\n    /**\n     * This method should not be used directly, use `import { pull } from \"langchain/hub\"` instead.\n     * Using this method directly returns the JSON string of the prompt rather than a LangChain object.\n     * @private\n     */ async _pullPrompt(promptIdentifier, options) {\n        const promptObject = await this.pullPromptCommit(promptIdentifier, {\n            includeModel: options?.includeModel\n        });\n        const prompt = JSON.stringify(promptObject.manifest);\n        return prompt;\n    }\n    async pushPrompt(promptIdentifier, options) {\n        // Create or update prompt metadata\n        if (await this.promptExists(promptIdentifier)) {\n            if (options && Object.keys(options).some((key)=>key !== \"object\")) {\n                await this.updatePrompt(promptIdentifier, {\n                    description: options?.description,\n                    readme: options?.readme,\n                    tags: options?.tags,\n                    isPublic: options?.isPublic\n                });\n            }\n        } else {\n            await this.createPrompt(promptIdentifier, {\n                description: options?.description,\n                readme: options?.readme,\n                tags: options?.tags,\n                isPublic: options?.isPublic\n            });\n        }\n        if (!options?.object) {\n            return await this._getPromptUrl(promptIdentifier);\n        }\n        // Create a commit with the new manifest\n        const url = await this.createCommit(promptIdentifier, options?.object, {\n            parentCommitHash: options?.parentCommitHash\n        });\n        return url;\n    }\n    /**\n     * Clone a public dataset to your own langsmith tenant.\n     * This operation is idempotent. If you already have a dataset with the given name,\n     * this function will do nothing.\n  \n     * @param {string} tokenOrUrl The token of the public dataset to clone.\n     * @param {Object} [options] Additional options for cloning the dataset.\n     * @param {string} [options.sourceApiUrl] The URL of the langsmith server where the data is hosted. Defaults to the API URL of your current client.\n     * @param {string} [options.datasetName] The name of the dataset to create in your tenant. Defaults to the name of the public dataset.\n     * @returns {Promise<void>}\n     */ async clonePublicDataset(tokenOrUrl, options = {}) {\n        const { sourceApiUrl = this.apiUrl, datasetName } = options;\n        const [parsedApiUrl, tokenUuid] = this.parseTokenOrUrl(tokenOrUrl, sourceApiUrl);\n        const sourceClient = new Client({\n            apiUrl: parsedApiUrl,\n            // Placeholder API key not needed anymore in most cases, but\n            // some private deployments may have API key-based rate limiting\n            // that would cause this to fail if we provide no value.\n            apiKey: \"placeholder\"\n        });\n        const ds = await sourceClient.readSharedDataset(tokenUuid);\n        const finalDatasetName = datasetName || ds.name;\n        try {\n            if (await this.hasDataset({\n                datasetId: finalDatasetName\n            })) {\n                console.log(`Dataset ${finalDatasetName} already exists in your tenant. Skipping.`);\n                return;\n            }\n        } catch (_) {\n        // `.hasDataset` will throw an error if the dataset does not exist.\n        // no-op in that case\n        }\n        // Fetch examples first, then create the dataset\n        const examples = await sourceClient.listSharedExamples(tokenUuid);\n        const dataset = await this.createDataset(finalDatasetName, {\n            description: ds.description,\n            dataType: ds.data_type || \"kv\",\n            inputsSchema: ds.inputs_schema_definition ?? undefined,\n            outputsSchema: ds.outputs_schema_definition ?? undefined\n        });\n        try {\n            await this.createExamples({\n                inputs: examples.map((e)=>e.inputs),\n                outputs: examples.flatMap((e)=>e.outputs ? [\n                        e.outputs\n                    ] : []),\n                datasetId: dataset.id\n            });\n        } catch (e) {\n            console.error(`An error occurred while creating dataset ${finalDatasetName}. ` + \"You should delete it manually.\");\n            throw e;\n        }\n    }\n    parseTokenOrUrl(urlOrToken, apiUrl, numParts = 2, kind = \"dataset\") {\n        // Try parsing as UUID\n        try {\n            (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_4__.assertUuid)(urlOrToken); // Will throw if it's not a UUID.\n            return [\n                apiUrl,\n                urlOrToken\n            ];\n        } catch (_) {\n        // no-op if it's not a uuid\n        }\n        // Parse as URL\n        try {\n            const parsedUrl = new URL(urlOrToken);\n            const pathParts = parsedUrl.pathname.split(\"/\").filter((part)=>part !== \"\");\n            if (pathParts.length >= numParts) {\n                const tokenUuid = pathParts[pathParts.length - numParts];\n                return [\n                    apiUrl,\n                    tokenUuid\n                ];\n            } else {\n                throw new Error(`Invalid public ${kind} URL: ${urlOrToken}`);\n            }\n        } catch (error) {\n            throw new Error(`Invalid public ${kind} URL or token: ${urlOrToken}`);\n        }\n    }\n    /**\n     * Awaits all pending trace batches. Useful for environments where\n     * you need to be sure that all tracing requests finish before execution ends,\n     * such as serverless environments.\n     *\n     * @example\n     * ```\n     * import { Client } from \"langsmith\";\n     *\n     * const client = new Client();\n     *\n     * try {\n     *   // Tracing happens here\n     *   ...\n     * } finally {\n     *   await client.awaitPendingTraceBatches();\n     * }\n     * ```\n     *\n     * @returns A promise that resolves once all currently pending traces have sent.\n     */ awaitPendingTraceBatches() {\n        if (this.manualFlushMode) {\n            console.warn(\"[WARNING]: When tracing in manual flush mode, you must call `await client.flush()` manually to submit trace batches.\");\n            return Promise.resolve();\n        }\n        return Promise.all([\n            ...this.autoBatchQueue.items.map(({ itemPromise })=>itemPromise),\n            this.batchIngestCaller.queue.onIdle()\n        ]);\n    }\n}\nfunction isExampleCreate(input) {\n    return \"dataset_id\" in input || \"dataset_name\" in input;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL2Rpc3QvY2xpZW50LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUE2QjtBQUN5QjtBQUNzQztBQUNrRDtBQUNyRztBQUNLO0FBQ0g7QUFDZ0I7QUFDVDtBQUNjO0FBQytCO0FBQ3hGLFNBQVNnQiw2QkFBNkJDLEdBQUc7SUFDNUMsTUFBTUMsYUFBYVgsb0VBQXFCQTtJQUN4QyxNQUFNWSxVQUFVZCwwRUFBMkJBO0lBQzNDLE1BQU1lLFFBQVFILElBQUlHLEtBQUssSUFBSSxDQUFDO0lBQzVCLE1BQU1DLFdBQVdELE1BQU1DLFFBQVE7SUFDL0JKLElBQUlHLEtBQUssR0FBRztRQUNSLEdBQUdBLEtBQUs7UUFDUkUsU0FBUztZQUNMLEdBQUdKLFVBQVU7WUFDYixHQUFHRSxPQUFPRSxPQUFPO1FBQ3JCO1FBQ0FELFVBQVU7WUFDTixHQUFHRixPQUFPO1lBQ1YsR0FBSUEsUUFBUUksV0FBVyxJQUFJTixJQUFJTSxXQUFXLEdBQ3BDO2dCQUFFQSxhQUFhTixJQUFJTSxXQUFXLElBQUlKLFFBQVFJLFdBQVc7WUFBQyxJQUN0RCxDQUFDLENBQUM7WUFDUixHQUFHRixRQUFRO1FBQ2Y7SUFDSjtJQUNBLE9BQU9KO0FBQ1g7QUFDQSxNQUFNTyx5QkFBeUIsQ0FBQ0M7SUFDNUIsTUFBTUMsa0JBQWtCRCxZQUFZRSxjQUNoQ3JCLDhFQUErQkEsQ0FBQztJQUNwQyxJQUFJb0Isb0JBQW9CRSxXQUFXO1FBQy9CLE9BQU9BO0lBQ1g7SUFDQSxNQUFNQyxlQUFlQyxXQUFXSjtJQUNoQyxJQUFJRyxlQUFlLEtBQUtBLGVBQWUsR0FBRztRQUN0QyxNQUFNLElBQUlFLE1BQU0sQ0FBQyxxRUFBcUUsRUFBRUYsYUFBYSxDQUFDO0lBQzFHO0lBQ0EsT0FBT0E7QUFDWDtBQUNBLG9CQUFvQjtBQUNwQixNQUFNRyxjQUFjLENBQUNDO0lBQ2pCLE1BQU1DLGNBQWNELElBQUlFLE9BQU8sQ0FBQyxXQUFXLElBQUlBLE9B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TUFBTThTLFlBQVksSUFBSUMsSUFBSUo7WUFDMUIsTUFBTUssWUFBWUYsVUFBVUcsUUFBUSxDQUMvQjlsQixLQUFLLENBQUMsS0FDTnVKLE1BQU0sQ0FBQyxDQUFDaUYsT0FBU0EsU0FBUztZQUMvQixJQUFJcVgsVUFBVXpqQixNQUFNLElBQUlxakIsVUFBVTtnQkFDOUIsTUFBTVIsWUFBWVksU0FBUyxDQUFDQSxVQUFVempCLE1BQU0sR0FBR3FqQixTQUFTO2dCQUN4RCxPQUFPO29CQUFDaGlCO29CQUFRd2hCO2lCQUFVO1lBQzlCLE9BQ0s7Z0JBQ0QsTUFBTSxJQUFJdmxCLE1BQU0sQ0FBQyxlQUFlLEVBQUVnbUIsS0FBSyxNQUFNLEVBQUVGLFdBQVcsQ0FBQztZQUMvRDtRQUNKLEVBQ0EsT0FBT3JjLE9BQU87WUFDVixNQUFNLElBQUl6SixNQUFNLENBQUMsZUFBZSxFQUFFZ21CLEtBQUssZUFBZSxFQUFFRixXQUFXLENBQUM7UUFDeEU7SUFDSjtJQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztLQW9CQyxHQUNETywyQkFBMkI7UUFDdkIsSUFBSSxJQUFJLENBQUNsaEIsZUFBZSxFQUFFO1lBQ3RCcUUsUUFBUW9CLElBQUksQ0FBQztZQUNiLE9BQU90SixRQUFRQyxPQUFPO1FBQzFCO1FBQ0EsT0FBT0QsUUFBUW9JLEdBQUcsQ0FBQztlQUNaLElBQUksQ0FBQ1IsY0FBYyxDQUFDNUcsS0FBSyxDQUFDYSxHQUFHLENBQUMsQ0FBQyxFQUFFWCxXQUFXLEVBQUUsR0FBS0E7WUFDdEQsSUFBSSxDQUFDZ0MsaUJBQWlCLENBQUM4aEIsS0FBSyxDQUFDQyxNQUFNO1NBQ3RDO0lBQ0w7QUFDSjtBQUNBLFNBQVNwTixnQkFBZ0J3QixLQUFLO0lBQzFCLE9BQU8sZ0JBQWdCQSxTQUFTLGtCQUFrQkE7QUFDdEQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9haS1tYXJrZXQtcmVzZWFyY2gtYWdlbnQvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL2Rpc3QvY2xpZW50LmpzP2VkMTUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgdXVpZCBmcm9tIFwidXVpZFwiO1xuaW1wb3J0IHsgQXN5bmNDYWxsZXIgfSBmcm9tIFwiLi91dGlscy9hc3luY19jYWxsZXIuanNcIjtcbmltcG9ydCB7IGNvbnZlcnRMYW5nQ2hhaW5NZXNzYWdlVG9FeGFtcGxlLCBpc0xhbmdDaGFpbk1lc3NhZ2UsIH0gZnJvbSBcIi4vdXRpbHMvbWVzc2FnZXMuanNcIjtcbmltcG9ydCB7IGdldEVudmlyb25tZW50VmFyaWFibGUsIGdldExhbmdDaGFpbkVudlZhcnNNZXRhZGF0YSwgZ2V0TGFuZ1NtaXRoRW52aXJvbm1lbnRWYXJpYWJsZSwgZ2V0UnVudGltZUVudmlyb25tZW50LCB9IGZyb20gXCIuL3V0aWxzL2Vudi5qc1wiO1xuaW1wb3J0IHsgX192ZXJzaW9uX18gfSBmcm9tIFwiLi9pbmRleC5qc1wiO1xuaW1wb3J0IHsgYXNzZXJ0VXVpZCB9IGZyb20gXCIuL3V0aWxzL191dWlkLmpzXCI7XG5pbXBvcnQgeyB3YXJuT25jZSB9IGZyb20gXCIuL3V0aWxzL3dhcm4uanNcIjtcbmltcG9ydCB7IHBhcnNlUHJvbXB0SWRlbnRpZmllciB9IGZyb20gXCIuL3V0aWxzL3Byb21wdHMuanNcIjtcbmltcG9ydCB7IHJhaXNlRm9yU3RhdHVzIH0gZnJvbSBcIi4vdXRpbHMvZXJyb3IuanNcIjtcbmltcG9ydCB7IF9nZXRGZXRjaEltcGxlbWVudGF0aW9uIH0gZnJvbSBcIi4vc2luZ2xldG9ucy9mZXRjaC5qc1wiO1xuaW1wb3J0IHsgc2VyaWFsaXplIGFzIHNlcmlhbGl6ZVBheWxvYWRGb3JUcmFjaW5nIH0gZnJvbSBcIi4vdXRpbHMvZmFzdC1zYWZlLXN0cmluZ2lmeS9pbmRleC5qc1wiO1xuZXhwb3J0IGZ1bmN0aW9uIG1lcmdlUnVudGltZUVudkludG9SdW5DcmVhdGUocnVuKSB7XG4gICAgY29uc3QgcnVudGltZUVudiA9IGdldFJ1bnRpbWVFbnZpcm9ubWVudCgpO1xuICAgIGNvbnN0IGVudlZhcnMgPSBnZXRMYW5nQ2hhaW5FbnZWYXJzTWV0YWRhdGEoKTtcbiAgICBjb25zdCBleHRyYSA9IHJ1bi5leHRyYSA/PyB7fTtcbiAgICBjb25zdCBtZXRhZGF0YSA9IGV4dHJhLm1ldGFkYXRhO1xuICAgIHJ1bi5leHRyYSA9IHtcbiAgICAgICAgLi4uZXh0cmEsXG4gICAgICAgIHJ1bnRpbWU6IHtcbiAgICAgICAgICAgIC4uLnJ1bnRpbWVFbnYsXG4gICAgICAgICAgICAuLi5leHRyYT8ucnVudGltZSxcbiAgICAgICAgfSxcbiAgICAgICAgbWV0YWRhdGE6IHtcbiAgICAgICAgICAgIC4uLmVudlZhcnMsXG4gICAgICAgICAgICAuLi4oZW52VmFycy5yZXZpc2lvbl9pZCB8fCBydW4ucmV2aXNpb25faWRcbiAgICAgICAgICAgICAgICA/IHsgcmV2aXNpb25faWQ6IHJ1bi5yZXZpc2lvbl9pZCA/PyBlbnZWYXJzLnJldmlzaW9uX2lkIH1cbiAgICAgICAgICAgICAgICA6IHt9KSxcbiAgICAgICAgICAgIC4uLm1ldGFkYXRhLFxuICAgICAgICB9LFxuICAgIH07XG4gICAgcmV0dXJuIHJ1bjtcbn1cbmNvbnN0IGdldFRyYWNpbmdTYW1wbGluZ1JhdGUgPSAoY29uZmlnUmF0ZSkgPT4ge1xuICAgIGNvbnN0IHNhbXBsaW5nUmF0ZVN0ciA9IGNvbmZpZ1JhdGU/LnRvU3RyaW5nKCkgPz9cbiAgICAgICAgZ2V0TGFuZ1NtaXRoRW52aXJvbm1lbnRWYXJpYWJsZShcIlRSQUNJTkdfU0FNUExJTkdfUkFURVwiKTtcbiAgICBpZiAoc2FtcGxpbmdSYXRlU3RyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgY29uc3Qgc2FtcGxpbmdSYXRlID0gcGFyc2VGbG9hdChzYW1wbGluZ1JhdGVTdHIpO1xuICAgIGlmIChzYW1wbGluZ1JhdGUgPCAwIHx8IHNhbXBsaW5nUmF0ZSA+IDEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBMQU5HU01JVEhfVFJBQ0lOR19TQU1QTElOR19SQVRFIG11c3QgYmUgYmV0d2VlbiAwIGFuZCAxIGlmIHNldC4gR290OiAke3NhbXBsaW5nUmF0ZX1gKTtcbiAgICB9XG4gICAgcmV0dXJuIHNhbXBsaW5nUmF0ZTtcbn07XG4vLyB1dGlsaXR5IGZ1bmN0aW9uc1xuY29uc3QgaXNMb2NhbGhvc3QgPSAodXJsKSA9PiB7XG4gICAgY29uc3Qgc3RyaXBwZWRVcmwgPSB1cmwucmVwbGFjZShcImh0dHA6Ly9cIiwgXCJcIikucmVwbGFjZShcImh0dHBzOi8vXCIsIFwiXCIpO1xuICAgIGNvbnN0IGhvc3RuYW1lID0gc3RyaXBwZWRVcmwuc3BsaXQoXCIvXCIpWzBdLnNwbGl0KFwiOlwiKVswXTtcbiAgICByZXR1cm4gKGhvc3RuYW1lID09PSBcImxvY2FsaG9zdFwiIHx8IGhvc3RuYW1lID09PSBcIjEyNy4wLjAuMVwiIHx8IGhvc3RuYW1lID09PSBcIjo6MVwiKTtcbn07XG5hc3luYyBmdW5jdGlvbiB0b0FycmF5KGl0ZXJhYmxlKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgZm9yIGF3YWl0IChjb25zdCBpdGVtIG9mIGl0ZXJhYmxlKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKGl0ZW0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gdHJpbVF1b3RlcyhzdHIpIHtcbiAgICBpZiAoc3RyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgcmV0dXJuIHN0clxuICAgICAgICAudHJpbSgpXG4gICAgICAgIC5yZXBsYWNlKC9eXCIoLiopXCIkLywgXCIkMVwiKVxuICAgICAgICAucmVwbGFjZSgvXicoLiopJyQvLCBcIiQxXCIpO1xufVxuY29uc3QgaGFuZGxlNDI5ID0gYXN5bmMgKHJlc3BvbnNlKSA9PiB7XG4gICAgaWYgKHJlc3BvbnNlPy5zdGF0dXMgPT09IDQyOSkge1xuICAgICAgICBjb25zdCByZXRyeUFmdGVyID0gcGFyc2VJbnQocmVzcG9uc2UuaGVhZGVycy5nZXQoXCJyZXRyeS1hZnRlclwiKSA/PyBcIjMwXCIsIDEwKSAqIDEwMDA7XG4gICAgICAgIGlmIChyZXRyeUFmdGVyID4gMCkge1xuICAgICAgICAgICAgYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgcmV0cnlBZnRlcikpO1xuICAgICAgICAgICAgLy8gUmV0dXJuIGRpcmVjdGx5IGFmdGVyIGNhbGxpbmcgdGhpcyBjaGVja1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gRmFsbCBiYWNrIHRvIGV4aXN0aW5nIHN0YXR1cyBjaGVja3NcbiAgICByZXR1cm4gZmFsc2U7XG59O1xuZnVuY3Rpb24gX2Zvcm1hdEZlZWRiYWNrU2NvcmUoc2NvcmUpIHtcbiAgICBpZiAodHlwZW9mIHNjb3JlID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgIC8vIFRydW5jYXRlIGF0IDQgZGVjaW1hbCBwbGFjZXNcbiAgICAgICAgcmV0dXJuIE51bWJlcihzY29yZS50b0ZpeGVkKDQpKTtcbiAgICB9XG4gICAgcmV0dXJuIHNjb3JlO1xufVxuZXhwb3J0IGNsYXNzIEF1dG9CYXRjaFF1ZXVlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiaXRlbXNcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IFtdXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJzaXplQnl0ZXNcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IDBcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHBlZWsoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLml0ZW1zWzBdO1xuICAgIH1cbiAgICBwdXNoKGl0ZW0pIHtcbiAgICAgICAgbGV0IGl0ZW1Qcm9taXNlUmVzb2x2ZTtcbiAgICAgICAgY29uc3QgaXRlbVByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICAgICAgLy8gU2V0dGluZyBpdGVtUHJvbWlzZVJlc29sdmUgaXMgc3luY2hyb25vdXMgd2l0aCBwcm9taXNlIGNyZWF0aW9uOlxuICAgICAgICAgICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvUHJvbWlzZS9Qcm9taXNlXG4gICAgICAgICAgICBpdGVtUHJvbWlzZVJlc29sdmUgPSByZXNvbHZlO1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3Qgc2l6ZSA9IHNlcmlhbGl6ZVBheWxvYWRGb3JUcmFjaW5nKGl0ZW0uaXRlbSkubGVuZ3RoO1xuICAgICAgICB0aGlzLml0ZW1zLnB1c2goe1xuICAgICAgICAgICAgYWN0aW9uOiBpdGVtLmFjdGlvbixcbiAgICAgICAgICAgIHBheWxvYWQ6IGl0ZW0uaXRlbSxcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tbm9uLW51bGwtYXNzZXJ0aW9uXG4gICAgICAgICAgICBpdGVtUHJvbWlzZVJlc29sdmU6IGl0ZW1Qcm9taXNlUmVzb2x2ZSxcbiAgICAgICAgICAgIGl0ZW1Qcm9taXNlLFxuICAgICAgICAgICAgc2l6ZSxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuc2l6ZUJ5dGVzICs9IHNpemU7XG4gICAgICAgIHJldHVybiBpdGVtUHJvbWlzZTtcbiAgICB9XG4gICAgcG9wKHVwVG9TaXplQnl0ZXMpIHtcbiAgICAgICAgaWYgKHVwVG9TaXplQnl0ZXMgPCAxKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJOdW1iZXIgb2YgYnl0ZXMgdG8gcG9wIG9mZiBtYXkgbm90IGJlIGxlc3MgdGhhbiAxLlwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwb3BwZWQgPSBbXTtcbiAgICAgICAgbGV0IHBvcHBlZFNpemVCeXRlcyA9IDA7XG4gICAgICAgIC8vIFBvcCBpdGVtcyB1bnRpbCB3ZSByZWFjaCBvciBleGNlZWQgdGhlIHNpemUgbGltaXRcbiAgICAgICAgd2hpbGUgKHBvcHBlZFNpemVCeXRlcyArICh0aGlzLnBlZWsoKT8uc2l6ZSA/PyAwKSA8IHVwVG9TaXplQnl0ZXMgJiZcbiAgICAgICAgICAgIHRoaXMuaXRlbXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgY29uc3QgaXRlbSA9IHRoaXMuaXRlbXMuc2hpZnQoKTtcbiAgICAgICAgICAgIGlmIChpdGVtKSB7XG4gICAgICAgICAgICAgICAgcG9wcGVkLnB1c2goaXRlbSk7XG4gICAgICAgICAgICAgICAgcG9wcGVkU2l6ZUJ5dGVzICs9IGl0ZW0uc2l6ZTtcbiAgICAgICAgICAgICAgICB0aGlzLnNpemVCeXRlcyAtPSBpdGVtLnNpemU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgdGhlcmUgaXMgYW4gaXRlbSBvbiB0aGUgcXVldWUgd2Ugd2VyZSB1bmFibGUgdG8gcG9wLFxuICAgICAgICAvLyBqdXN0IHJldHVybiBpdCBhcyBhIHNpbmdsZSBiYXRjaC5cbiAgICAgICAgaWYgKHBvcHBlZC5sZW5ndGggPT09IDAgJiYgdGhpcy5pdGVtcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBjb25zdCBpdGVtID0gdGhpcy5pdGVtcy5zaGlmdCgpO1xuICAgICAgICAgICAgcG9wcGVkLnB1c2goaXRlbSk7XG4gICAgICAgICAgICBwb3BwZWRTaXplQnl0ZXMgKz0gaXRlbS5zaXplO1xuICAgICAgICAgICAgdGhpcy5zaXplQnl0ZXMgLT0gaXRlbS5zaXplO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBwb3BwZWQubWFwKChpdCkgPT4gKHsgYWN0aW9uOiBpdC5hY3Rpb24sIGl0ZW06IGl0LnBheWxvYWQgfSkpLFxuICAgICAgICAgICAgKCkgPT4gcG9wcGVkLmZvckVhY2goKGl0KSA9PiBpdC5pdGVtUHJvbWlzZVJlc29sdmUoKSksXG4gICAgICAgIF07XG4gICAgfVxufVxuLy8gMjAgTUJcbmV4cG9ydCBjb25zdCBERUZBVUxUX0JBVENIX1NJWkVfTElNSVRfQllURVMgPSAyMF85NzFfNTIwO1xuY29uc3QgU0VSVkVSX0lORk9fUkVRVUVTVF9USU1FT1VUID0gMjUwMDtcbmV4cG9ydCBjbGFzcyBDbGllbnQge1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZyA9IHt9KSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImFwaUtleVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJhcGlVcmxcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwid2ViVXJsXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImNhbGxlclwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJiYXRjaEluZ2VzdENhbGxlclwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJ0aW1lb3V0X21zXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl90ZW5hbnRJZFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogbnVsbFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiaGlkZUlucHV0c1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJoaWRlT3V0cHV0c1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJ0cmFjaW5nU2FtcGxlUmF0ZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJmaWx0ZXJlZFBvc3RVdWlkc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogbmV3IFNldCgpXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJhdXRvQmF0Y2hUcmFjaW5nXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJhdXRvQmF0Y2hRdWV1ZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogbmV3IEF1dG9CYXRjaFF1ZXVlKClcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImF1dG9CYXRjaFRpbWVvdXRcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiYXV0b0JhdGNoQWdncmVnYXRpb25EZWxheU1zXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiAyNTBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImJhdGNoU2l6ZUJ5dGVzTGltaXRcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiZmV0Y2hPcHRpb25zXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInNldHRpbmdzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImJsb2NrT25Sb290UnVuRmluYWxpemF0aW9uXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBnZXRFbnZpcm9ubWVudFZhcmlhYmxlKFwiTEFOR1NNSVRIX1RSQUNJTkdfQkFDS0dST1VORFwiKSA9PT0gXCJmYWxzZVwiXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJ0cmFjZUJhdGNoQ29uY3VycmVuY3lcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IDVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9zZXJ2ZXJJbmZvXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9nZXRTZXJ2ZXJJbmZvUHJvbWlzZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJtYW51YWxGbHVzaE1vZGVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBkZWZhdWx0Q29uZmlnID0gQ2xpZW50LmdldERlZmF1bHRDbGllbnRDb25maWcoKTtcbiAgICAgICAgdGhpcy50cmFjaW5nU2FtcGxlUmF0ZSA9IGdldFRyYWNpbmdTYW1wbGluZ1JhdGUoY29uZmlnLnRyYWNpbmdTYW1wbGluZ1JhdGUpO1xuICAgICAgICB0aGlzLmFwaVVybCA9IHRyaW1RdW90ZXMoY29uZmlnLmFwaVVybCA/PyBkZWZhdWx0Q29uZmlnLmFwaVVybCkgPz8gXCJcIjtcbiAgICAgICAgaWYgKHRoaXMuYXBpVXJsLmVuZHNXaXRoKFwiL1wiKSkge1xuICAgICAgICAgICAgdGhpcy5hcGlVcmwgPSB0aGlzLmFwaVVybC5zbGljZSgwLCAtMSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hcGlLZXkgPSB0cmltUXVvdGVzKGNvbmZpZy5hcGlLZXkgPz8gZGVmYXVsdENvbmZpZy5hcGlLZXkpO1xuICAgICAgICB0aGlzLndlYlVybCA9IHRyaW1RdW90ZXMoY29uZmlnLndlYlVybCA/PyBkZWZhdWx0Q29uZmlnLndlYlVybCk7XG4gICAgICAgIGlmICh0aGlzLndlYlVybD8uZW5kc1dpdGgoXCIvXCIpKSB7XG4gICAgICAgICAgICB0aGlzLndlYlVybCA9IHRoaXMud2ViVXJsLnNsaWNlKDAsIC0xKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRpbWVvdXRfbXMgPSBjb25maWcudGltZW91dF9tcyA/PyA5MF8wMDA7XG4gICAgICAgIHRoaXMuY2FsbGVyID0gbmV3IEFzeW5jQ2FsbGVyKGNvbmZpZy5jYWxsZXJPcHRpb25zID8/IHt9KTtcbiAgICAgICAgdGhpcy50cmFjZUJhdGNoQ29uY3VycmVuY3kgPVxuICAgICAgICAgICAgY29uZmlnLnRyYWNlQmF0Y2hDb25jdXJyZW5jeSA/PyB0aGlzLnRyYWNlQmF0Y2hDb25jdXJyZW5jeTtcbiAgICAgICAgaWYgKHRoaXMudHJhY2VCYXRjaENvbmN1cnJlbmN5IDwgMSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVHJhY2UgYmF0Y2ggY29uY3VycmVuY3kgbXVzdCBiZSBwb3NpdGl2ZS5cIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5iYXRjaEluZ2VzdENhbGxlciA9IG5ldyBBc3luY0NhbGxlcih7XG4gICAgICAgICAgICBtYXhSZXRyaWVzOiAyLFxuICAgICAgICAgICAgbWF4Q29uY3VycmVuY3k6IHRoaXMudHJhY2VCYXRjaENvbmN1cnJlbmN5LFxuICAgICAgICAgICAgLi4uKGNvbmZpZy5jYWxsZXJPcHRpb25zID8/IHt9KSxcbiAgICAgICAgICAgIG9uRmFpbGVkUmVzcG9uc2VIb29rOiBoYW5kbGU0MjksXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmhpZGVJbnB1dHMgPVxuICAgICAgICAgICAgY29uZmlnLmhpZGVJbnB1dHMgPz8gY29uZmlnLmFub255bWl6ZXIgPz8gZGVmYXVsdENvbmZpZy5oaWRlSW5wdXRzO1xuICAgICAgICB0aGlzLmhpZGVPdXRwdXRzID1cbiAgICAgICAgICAgIGNvbmZpZy5oaWRlT3V0cHV0cyA/PyBjb25maWcuYW5vbnltaXplciA/PyBkZWZhdWx0Q29uZmlnLmhpZGVPdXRwdXRzO1xuICAgICAgICB0aGlzLmF1dG9CYXRjaFRyYWNpbmcgPSBjb25maWcuYXV0b0JhdGNoVHJhY2luZyA/PyB0aGlzLmF1dG9CYXRjaFRyYWNpbmc7XG4gICAgICAgIHRoaXMuYmxvY2tPblJvb3RSdW5GaW5hbGl6YXRpb24gPVxuICAgICAgICAgICAgY29uZmlnLmJsb2NrT25Sb290UnVuRmluYWxpemF0aW9uID8/IHRoaXMuYmxvY2tPblJvb3RSdW5GaW5hbGl6YXRpb247XG4gICAgICAgIHRoaXMuYmF0Y2hTaXplQnl0ZXNMaW1pdCA9IGNvbmZpZy5iYXRjaFNpemVCeXRlc0xpbWl0O1xuICAgICAgICB0aGlzLmZldGNoT3B0aW9ucyA9IGNvbmZpZy5mZXRjaE9wdGlvbnMgfHwge307XG4gICAgICAgIHRoaXMubWFudWFsRmx1c2hNb2RlID0gY29uZmlnLm1hbnVhbEZsdXNoTW9kZSA/PyB0aGlzLm1hbnVhbEZsdXNoTW9kZTtcbiAgICB9XG4gICAgc3RhdGljIGdldERlZmF1bHRDbGllbnRDb25maWcoKSB7XG4gICAgICAgIGNvbnN0IGFwaUtleSA9IGdldExhbmdTbWl0aEVudmlyb25tZW50VmFyaWFibGUoXCJBUElfS0VZXCIpO1xuICAgICAgICBjb25zdCBhcGlVcmwgPSBnZXRMYW5nU21pdGhFbnZpcm9ubWVudFZhcmlhYmxlKFwiRU5EUE9JTlRcIikgPz9cbiAgICAgICAgICAgIFwiaHR0cHM6Ly9hcGkuc21pdGgubGFuZ2NoYWluLmNvbVwiO1xuICAgICAgICBjb25zdCBoaWRlSW5wdXRzID0gZ2V0TGFuZ1NtaXRoRW52aXJvbm1lbnRWYXJpYWJsZShcIkhJREVfSU5QVVRTXCIpID09PSBcInRydWVcIjtcbiAgICAgICAgY29uc3QgaGlkZU91dHB1dHMgPSBnZXRMYW5nU21pdGhFbnZpcm9ubWVudFZhcmlhYmxlKFwiSElERV9PVVRQVVRTXCIpID09PSBcInRydWVcIjtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGFwaVVybDogYXBpVXJsLFxuICAgICAgICAgICAgYXBpS2V5OiBhcGlLZXksXG4gICAgICAgICAgICB3ZWJVcmw6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGhpZGVJbnB1dHM6IGhpZGVJbnB1dHMsXG4gICAgICAgICAgICBoaWRlT3V0cHV0czogaGlkZU91dHB1dHMsXG4gICAgICAgIH07XG4gICAgfVxuICAgIGdldEhvc3RVcmwoKSB7XG4gICAgICAgIGlmICh0aGlzLndlYlVybCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMud2ViVXJsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzTG9jYWxob3N0KHRoaXMuYXBpVXJsKSkge1xuICAgICAgICAgICAgdGhpcy53ZWJVcmwgPSBcImh0dHA6Ly9sb2NhbGhvc3Q6MzAwMFwiO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMud2ViVXJsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuYXBpVXJsLmVuZHNXaXRoKFwiL2FwaS92MVwiKSkge1xuICAgICAgICAgICAgdGhpcy53ZWJVcmwgPSB0aGlzLmFwaVVybC5yZXBsYWNlKFwiL2FwaS92MVwiLCBcIlwiKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLndlYlVybDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLmFwaVVybC5pbmNsdWRlcyhcIi9hcGlcIikgJiZcbiAgICAgICAgICAgICF0aGlzLmFwaVVybC5zcGxpdChcIi5cIiwgMSlbMF0uZW5kc1dpdGgoXCJhcGlcIikpIHtcbiAgICAgICAgICAgIHRoaXMud2ViVXJsID0gdGhpcy5hcGlVcmwucmVwbGFjZShcIi9hcGlcIiwgXCJcIik7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy53ZWJVcmw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5hcGlVcmwuc3BsaXQoXCIuXCIsIDEpWzBdLmluY2x1ZGVzKFwiZGV2XCIpKSB7XG4gICAgICAgICAgICB0aGlzLndlYlVybCA9IFwiaHR0cHM6Ly9kZXYuc21pdGgubGFuZ2NoYWluLmNvbVwiO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMud2ViVXJsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuYXBpVXJsLnNwbGl0KFwiLlwiLCAxKVswXS5pbmNsdWRlcyhcImV1XCIpKSB7XG4gICAgICAgICAgICB0aGlzLndlYlVybCA9IFwiaHR0cHM6Ly9ldS5zbWl0aC5sYW5nY2hhaW4uY29tXCI7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy53ZWJVcmw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5hcGlVcmwuc3BsaXQoXCIuXCIsIDEpWzBdLmluY2x1ZGVzKFwiYmV0YVwiKSkge1xuICAgICAgICAgICAgdGhpcy53ZWJVcmwgPSBcImh0dHBzOi8vYmV0YS5zbWl0aC5sYW5nY2hhaW4uY29tXCI7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy53ZWJVcmw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLndlYlVybCA9IFwiaHR0cHM6Ly9zbWl0aC5sYW5nY2hhaW4uY29tXCI7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy53ZWJVcmw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IGhlYWRlcnMoKSB7XG4gICAgICAgIGNvbnN0IGhlYWRlcnMgPSB7XG4gICAgICAgICAgICBcIlVzZXItQWdlbnRcIjogYGxhbmdzbWl0aC1qcy8ke19fdmVyc2lvbl9ffWAsXG4gICAgICAgIH07XG4gICAgICAgIGlmICh0aGlzLmFwaUtleSkge1xuICAgICAgICAgICAgaGVhZGVyc1tcIngtYXBpLWtleVwiXSA9IGAke3RoaXMuYXBpS2V5fWA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGhlYWRlcnM7XG4gICAgfVxuICAgIHByb2Nlc3NJbnB1dHMoaW5wdXRzKSB7XG4gICAgICAgIGlmICh0aGlzLmhpZGVJbnB1dHMgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICByZXR1cm4gaW5wdXRzO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmhpZGVJbnB1dHMgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHJldHVybiB7fTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHRoaXMuaGlkZUlucHV0cyA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5oaWRlSW5wdXRzKGlucHV0cyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGlucHV0cztcbiAgICB9XG4gICAgcHJvY2Vzc091dHB1dHMob3V0cHV0cykge1xuICAgICAgICBpZiAodGhpcy5oaWRlT3V0cHV0cyA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHJldHVybiBvdXRwdXRzO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmhpZGVPdXRwdXRzID09PSB0cnVlKSB7XG4gICAgICAgICAgICByZXR1cm4ge307XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLmhpZGVPdXRwdXRzID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmhpZGVPdXRwdXRzKG91dHB1dHMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvdXRwdXRzO1xuICAgIH1cbiAgICBwcmVwYXJlUnVuQ3JlYXRlT3JVcGRhdGVJbnB1dHMocnVuKSB7XG4gICAgICAgIGNvbnN0IHJ1blBhcmFtcyA9IHsgLi4ucnVuIH07XG4gICAgICAgIGlmIChydW5QYXJhbXMuaW5wdXRzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJ1blBhcmFtcy5pbnB1dHMgPSB0aGlzLnByb2Nlc3NJbnB1dHMocnVuUGFyYW1zLmlucHV0cyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJ1blBhcmFtcy5vdXRwdXRzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJ1blBhcmFtcy5vdXRwdXRzID0gdGhpcy5wcm9jZXNzT3V0cHV0cyhydW5QYXJhbXMub3V0cHV0cyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJ1blBhcmFtcztcbiAgICB9XG4gICAgYXN5bmMgX2dldFJlc3BvbnNlKHBhdGgsIHF1ZXJ5UGFyYW1zKSB7XG4gICAgICAgIGNvbnN0IHBhcmFtc1N0cmluZyA9IHF1ZXJ5UGFyYW1zPy50b1N0cmluZygpID8/IFwiXCI7XG4gICAgICAgIGNvbnN0IHVybCA9IGAke3RoaXMuYXBpVXJsfSR7cGF0aH0/JHtwYXJhbXNTdHJpbmd9YDtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmNhbGxlci5jYWxsKF9nZXRGZXRjaEltcGxlbWVudGF0aW9uKCksIHVybCwge1xuICAgICAgICAgICAgbWV0aG9kOiBcIkdFVFwiLFxuICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgc2lnbmFsOiBBYm9ydFNpZ25hbC50aW1lb3V0KHRoaXMudGltZW91dF9tcyksXG4gICAgICAgICAgICAuLi50aGlzLmZldGNoT3B0aW9ucyxcbiAgICAgICAgfSk7XG4gICAgICAgIGF3YWl0IHJhaXNlRm9yU3RhdHVzKHJlc3BvbnNlLCBgRmFpbGVkIHRvIGZldGNoICR7cGF0aH1gKTtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgIH1cbiAgICBhc3luYyBfZ2V0KHBhdGgsIHF1ZXJ5UGFyYW1zKSB7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5fZ2V0UmVzcG9uc2UocGF0aCwgcXVlcnlQYXJhbXMpO1xuICAgICAgICByZXR1cm4gcmVzcG9uc2UuanNvbigpO1xuICAgIH1cbiAgICBhc3luYyAqX2dldFBhZ2luYXRlZChwYXRoLCBxdWVyeVBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoKSwgdHJhbnNmb3JtKSB7XG4gICAgICAgIGxldCBvZmZzZXQgPSBOdW1iZXIocXVlcnlQYXJhbXMuZ2V0KFwib2Zmc2V0XCIpKSB8fCAwO1xuICAgICAgICBjb25zdCBsaW1pdCA9IE51bWJlcihxdWVyeVBhcmFtcy5nZXQoXCJsaW1pdFwiKSkgfHwgMTAwO1xuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgcXVlcnlQYXJhbXMuc2V0KFwib2Zmc2V0XCIsIFN0cmluZyhvZmZzZXQpKTtcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zLnNldChcImxpbWl0XCIsIFN0cmluZyhsaW1pdCkpO1xuICAgICAgICAgICAgY29uc3QgdXJsID0gYCR7dGhpcy5hcGlVcmx9JHtwYXRofT8ke3F1ZXJ5UGFyYW1zfWA7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuY2FsbGVyLmNhbGwoX2dldEZldGNoSW1wbGVtZW50YXRpb24oKSwgdXJsLCB7XG4gICAgICAgICAgICAgICAgbWV0aG9kOiBcIkdFVFwiLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgICAgICBzaWduYWw6IEFib3J0U2lnbmFsLnRpbWVvdXQodGhpcy50aW1lb3V0X21zKSxcbiAgICAgICAgICAgICAgICAuLi50aGlzLmZldGNoT3B0aW9ucyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYXdhaXQgcmFpc2VGb3JTdGF0dXMocmVzcG9uc2UsIGBGYWlsZWQgdG8gZmV0Y2ggJHtwYXRofWApO1xuICAgICAgICAgICAgY29uc3QgaXRlbXMgPSB0cmFuc2Zvcm1cbiAgICAgICAgICAgICAgICA/IHRyYW5zZm9ybShhd2FpdCByZXNwb25zZS5qc29uKCkpXG4gICAgICAgICAgICAgICAgOiBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgICAgICBpZiAoaXRlbXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB5aWVsZCBpdGVtcztcbiAgICAgICAgICAgIGlmIChpdGVtcy5sZW5ndGggPCBsaW1pdCkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb2Zmc2V0ICs9IGl0ZW1zLmxlbmd0aDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyAqX2dldEN1cnNvclBhZ2luYXRlZExpc3QocGF0aCwgYm9keSA9IG51bGwsIHJlcXVlc3RNZXRob2QgPSBcIlBPU1RcIiwgZGF0YUtleSA9IFwicnVuc1wiKSB7XG4gICAgICAgIGNvbnN0IGJvZHlQYXJhbXMgPSBib2R5ID8geyAuLi5ib2R5IH0gOiB7fTtcbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5jYWxsZXIuY2FsbChfZ2V0RmV0Y2hJbXBsZW1lbnRhdGlvbigpLCBgJHt0aGlzLmFwaVVybH0ke3BhdGh9YCwge1xuICAgICAgICAgICAgICAgIG1ldGhvZDogcmVxdWVzdE1ldGhvZCxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB7IC4uLnRoaXMuaGVhZGVycywgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIgfSxcbiAgICAgICAgICAgICAgICBzaWduYWw6IEFib3J0U2lnbmFsLnRpbWVvdXQodGhpcy50aW1lb3V0X21zKSxcbiAgICAgICAgICAgICAgICAuLi50aGlzLmZldGNoT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5UGFyYW1zKSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2VCb2R5ID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgICAgICAgaWYgKCFyZXNwb25zZUJvZHkpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghcmVzcG9uc2VCb2R5W2RhdGFLZXldKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB5aWVsZCByZXNwb25zZUJvZHlbZGF0YUtleV07XG4gICAgICAgICAgICBjb25zdCBjdXJzb3JzID0gcmVzcG9uc2VCb2R5LmN1cnNvcnM7XG4gICAgICAgICAgICBpZiAoIWN1cnNvcnMpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghY3Vyc29ycy5uZXh0KSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBib2R5UGFyYW1zLmN1cnNvciA9IGN1cnNvcnMubmV4dDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBBbGxvd3MgbW9ja2luZyBmb3IgdGVzdHNcbiAgICBfc2hvdWxkU2FtcGxlKCkge1xuICAgICAgICBpZiAodGhpcy50cmFjaW5nU2FtcGxlUmF0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gTWF0aC5yYW5kb20oKSA8IHRoaXMudHJhY2luZ1NhbXBsZVJhdGU7XG4gICAgfVxuICAgIF9maWx0ZXJGb3JTYW1wbGluZyhydW5zLCBwYXRjaCA9IGZhbHNlKSB7XG4gICAgICAgIGlmICh0aGlzLnRyYWNpbmdTYW1wbGVSYXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBydW5zO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXRjaCkge1xuICAgICAgICAgICAgY29uc3Qgc2FtcGxlZCA9IFtdO1xuICAgICAgICAgICAgZm9yIChjb25zdCBydW4gb2YgcnVucykge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5maWx0ZXJlZFBvc3RVdWlkcy5oYXMocnVuLmlkKSkge1xuICAgICAgICAgICAgICAgICAgICBzYW1wbGVkLnB1c2gocnVuKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZmlsdGVyZWRQb3N0VXVpZHMuZGVsZXRlKHJ1bi5pZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHNhbXBsZWQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBGb3IgbmV3IHJ1bnMsIHNhbXBsZSBhdCB0cmFjZSBsZXZlbCB0byBtYWludGFpbiBjb25zaXN0ZW5jeVxuICAgICAgICAgICAgY29uc3Qgc2FtcGxlZCA9IFtdO1xuICAgICAgICAgICAgZm9yIChjb25zdCBydW4gb2YgcnVucykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRyYWNlSWQgPSBydW4udHJhY2VfaWQgPz8gcnVuLmlkO1xuICAgICAgICAgICAgICAgIC8vIElmIHdlJ3ZlIGFscmVhZHkgbWFkZSBhIGRlY2lzaW9uIGFib3V0IHRoaXMgdHJhY2UsIGZvbGxvdyBpdFxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmZpbHRlcmVkUG9zdFV1aWRzLmhhcyh0cmFjZUlkKSkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gRm9yIG5ldyB0cmFjZXMsIGFwcGx5IHNhbXBsaW5nXG4gICAgICAgICAgICAgICAgaWYgKHJ1bi5pZCA9PT0gdHJhY2VJZCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fc2hvdWxkU2FtcGxlKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNhbXBsZWQucHVzaChydW4pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5maWx0ZXJlZFBvc3RVdWlkcy5hZGQodHJhY2VJZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIENoaWxkIHJ1bnMgZm9sbG93IHRoZWlyIHRyYWNlJ3Mgc2FtcGxpbmcgZGVjaXNpb25cbiAgICAgICAgICAgICAgICAgICAgc2FtcGxlZC5wdXNoKHJ1bik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHNhbXBsZWQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgX2dldEJhdGNoU2l6ZUxpbWl0Qnl0ZXMoKSB7XG4gICAgICAgIGNvbnN0IHNlcnZlckluZm8gPSBhd2FpdCB0aGlzLl9lbnN1cmVTZXJ2ZXJJbmZvKCk7XG4gICAgICAgIHJldHVybiAodGhpcy5iYXRjaFNpemVCeXRlc0xpbWl0ID8/XG4gICAgICAgICAgICBzZXJ2ZXJJbmZvLmJhdGNoX2luZ2VzdF9jb25maWc/LnNpemVfbGltaXRfYnl0ZXMgPz9cbiAgICAgICAgICAgIERFRkFVTFRfQkFUQ0hfU0laRV9MSU1JVF9CWVRFUyk7XG4gICAgfVxuICAgIGFzeW5jIF9nZXRNdWx0aVBhcnRTdXBwb3J0KCkge1xuICAgICAgICBjb25zdCBzZXJ2ZXJJbmZvID0gYXdhaXQgdGhpcy5fZW5zdXJlU2VydmVySW5mbygpO1xuICAgICAgICByZXR1cm4gKHNlcnZlckluZm8uaW5zdGFuY2VfZmxhZ3M/LmRhdGFzZXRfZXhhbXBsZXNfbXVsdGlwYXJ0X2VuYWJsZWQgPz8gZmFsc2UpO1xuICAgIH1cbiAgICBkcmFpbkF1dG9CYXRjaFF1ZXVlKGJhdGNoU2l6ZUxpbWl0KSB7XG4gICAgICAgIGNvbnN0IHByb21pc2VzID0gW107XG4gICAgICAgIHdoaWxlICh0aGlzLmF1dG9CYXRjaFF1ZXVlLml0ZW1zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGNvbnN0IFtiYXRjaCwgZG9uZV0gPSB0aGlzLmF1dG9CYXRjaFF1ZXVlLnBvcChiYXRjaFNpemVMaW1pdCk7XG4gICAgICAgICAgICBpZiAoIWJhdGNoLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGJhdGNoUHJvbWlzZSA9IHRoaXMuX3Byb2Nlc3NCYXRjaChiYXRjaCwgZG9uZSkuY2F0Y2goY29uc29sZS5lcnJvcik7XG4gICAgICAgICAgICBwcm9taXNlcy5wdXNoKGJhdGNoUHJvbWlzZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKHByb21pc2VzKTtcbiAgICB9XG4gICAgYXN5bmMgX3Byb2Nlc3NCYXRjaChiYXRjaCwgZG9uZSkge1xuICAgICAgICBpZiAoIWJhdGNoLmxlbmd0aCkge1xuICAgICAgICAgICAgZG9uZSgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBpbmdlc3RQYXJhbXMgPSB7XG4gICAgICAgICAgICAgICAgcnVuQ3JlYXRlczogYmF0Y2hcbiAgICAgICAgICAgICAgICAgICAgLmZpbHRlcigoaXRlbSkgPT4gaXRlbS5hY3Rpb24gPT09IFwiY3JlYXRlXCIpXG4gICAgICAgICAgICAgICAgICAgIC5tYXAoKGl0ZW0pID0+IGl0ZW0uaXRlbSksXG4gICAgICAgICAgICAgICAgcnVuVXBkYXRlczogYmF0Y2hcbiAgICAgICAgICAgICAgICAgICAgLmZpbHRlcigoaXRlbSkgPT4gaXRlbS5hY3Rpb24gPT09IFwidXBkYXRlXCIpXG4gICAgICAgICAgICAgICAgICAgIC5tYXAoKGl0ZW0pID0+IGl0ZW0uaXRlbSksXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3Qgc2VydmVySW5mbyA9IGF3YWl0IHRoaXMuX2Vuc3VyZVNlcnZlckluZm8oKTtcbiAgICAgICAgICAgIGlmIChzZXJ2ZXJJbmZvPy5iYXRjaF9pbmdlc3RfY29uZmlnPy51c2VfbXVsdGlwYXJ0X2VuZHBvaW50KSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5tdWx0aXBhcnRJbmdlc3RSdW5zKGluZ2VzdFBhcmFtcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLmJhdGNoSW5nZXN0UnVucyhpbmdlc3RQYXJhbXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgZG9uZSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIHByb2Nlc3NSdW5PcGVyYXRpb24oaXRlbSkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5hdXRvQmF0Y2hUaW1lb3V0KTtcbiAgICAgICAgdGhpcy5hdXRvQmF0Y2hUaW1lb3V0ID0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAoaXRlbS5hY3Rpb24gPT09IFwiY3JlYXRlXCIpIHtcbiAgICAgICAgICAgIGl0ZW0uaXRlbSA9IG1lcmdlUnVudGltZUVudkludG9SdW5DcmVhdGUoaXRlbS5pdGVtKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpdGVtUHJvbWlzZSA9IHRoaXMuYXV0b0JhdGNoUXVldWUucHVzaChpdGVtKTtcbiAgICAgICAgaWYgKHRoaXMubWFudWFsRmx1c2hNb2RlKSB7XG4gICAgICAgICAgICAvLyBSZWx5IG9uIG1hbnVhbCBmbHVzaGluZyBpbiBzZXJ2ZXJsZXNzIGVudmlyb25tZW50c1xuICAgICAgICAgICAgcmV0dXJuIGl0ZW1Qcm9taXNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNpemVMaW1pdEJ5dGVzID0gYXdhaXQgdGhpcy5fZ2V0QmF0Y2hTaXplTGltaXRCeXRlcygpO1xuICAgICAgICBpZiAodGhpcy5hdXRvQmF0Y2hRdWV1ZS5zaXplQnl0ZXMgPiBzaXplTGltaXRCeXRlcykge1xuICAgICAgICAgICAgdm9pZCB0aGlzLmRyYWluQXV0b0JhdGNoUXVldWUoc2l6ZUxpbWl0Qnl0ZXMpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmF1dG9CYXRjaFF1ZXVlLml0ZW1zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHRoaXMuYXV0b0JhdGNoVGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuYXV0b0JhdGNoVGltZW91dCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB2b2lkIHRoaXMuZHJhaW5BdXRvQmF0Y2hRdWV1ZShzaXplTGltaXRCeXRlcyk7XG4gICAgICAgICAgICB9LCB0aGlzLmF1dG9CYXRjaEFnZ3JlZ2F0aW9uRGVsYXlNcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGl0ZW1Qcm9taXNlO1xuICAgIH1cbiAgICBhc3luYyBfZ2V0U2VydmVySW5mbygpIHtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBfZ2V0RmV0Y2hJbXBsZW1lbnRhdGlvbigpKGAke3RoaXMuYXBpVXJsfS9pbmZvYCwge1xuICAgICAgICAgICAgbWV0aG9kOiBcIkdFVFwiLFxuICAgICAgICAgICAgaGVhZGVyczogeyBBY2NlcHQ6IFwiYXBwbGljYXRpb24vanNvblwiIH0sXG4gICAgICAgICAgICBzaWduYWw6IEFib3J0U2lnbmFsLnRpbWVvdXQoU0VSVkVSX0lORk9fUkVRVUVTVF9USU1FT1VUKSxcbiAgICAgICAgICAgIC4uLnRoaXMuZmV0Y2hPcHRpb25zLFxuICAgICAgICB9KTtcbiAgICAgICAgYXdhaXQgcmFpc2VGb3JTdGF0dXMocmVzcG9uc2UsIFwiZ2V0IHNlcnZlciBpbmZvXCIpO1xuICAgICAgICByZXR1cm4gcmVzcG9uc2UuanNvbigpO1xuICAgIH1cbiAgICBhc3luYyBfZW5zdXJlU2VydmVySW5mbygpIHtcbiAgICAgICAgaWYgKHRoaXMuX2dldFNlcnZlckluZm9Qcm9taXNlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX2dldFNlcnZlckluZm9Qcm9taXNlID0gKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fc2VydmVySW5mbyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9zZXJ2ZXJJbmZvID0gYXdhaXQgdGhpcy5fZ2V0U2VydmVySW5mbygpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oYFtXQVJOSU5HXTogTGFuZ1NtaXRoIGZhaWxlZCB0byBmZXRjaCBpbmZvIG9uIHN1cHBvcnRlZCBvcGVyYXRpb25zLiBGYWxsaW5nIGJhY2sgdG8gYmF0Y2ggb3BlcmF0aW9ucyBhbmQgZGVmYXVsdCBsaW1pdHMuYCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3NlcnZlckluZm8gPz8ge307XG4gICAgICAgICAgICB9KSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9nZXRTZXJ2ZXJJbmZvUHJvbWlzZS50aGVuKChzZXJ2ZXJJbmZvKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5fc2VydmVySW5mbyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZ2V0U2VydmVySW5mb1Byb21pc2UgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc2VydmVySW5mbztcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFzeW5jIF9nZXRTZXR0aW5ncygpIHtcbiAgICAgICAgaWYgKCF0aGlzLnNldHRpbmdzKSB7XG4gICAgICAgICAgICB0aGlzLnNldHRpbmdzID0gdGhpcy5fZ2V0KFwiL3NldHRpbmdzXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnNldHRpbmdzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBGbHVzaGVzIGN1cnJlbnQgcXVldWVkIHRyYWNlcy5cbiAgICAgKi9cbiAgICBhc3luYyBmbHVzaCgpIHtcbiAgICAgICAgY29uc3Qgc2l6ZUxpbWl0Qnl0ZXMgPSBhd2FpdCB0aGlzLl9nZXRCYXRjaFNpemVMaW1pdEJ5dGVzKCk7XG4gICAgICAgIGF3YWl0IHRoaXMuZHJhaW5BdXRvQmF0Y2hRdWV1ZShzaXplTGltaXRCeXRlcyk7XG4gICAgfVxuICAgIGFzeW5jIGNyZWF0ZVJ1bihydW4pIHtcbiAgICAgICAgaWYgKCF0aGlzLl9maWx0ZXJGb3JTYW1wbGluZyhbcnVuXSkubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaGVhZGVycyA9IHsgLi4udGhpcy5oZWFkZXJzLCBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIiB9O1xuICAgICAgICBjb25zdCBzZXNzaW9uX25hbWUgPSBydW4ucHJvamVjdF9uYW1lO1xuICAgICAgICBkZWxldGUgcnVuLnByb2plY3RfbmFtZTtcbiAgICAgICAgY29uc3QgcnVuQ3JlYXRlID0gdGhpcy5wcmVwYXJlUnVuQ3JlYXRlT3JVcGRhdGVJbnB1dHMoe1xuICAgICAgICAgICAgc2Vzc2lvbl9uYW1lLFxuICAgICAgICAgICAgLi4ucnVuLFxuICAgICAgICAgICAgc3RhcnRfdGltZTogcnVuLnN0YXJ0X3RpbWUgPz8gRGF0ZS5ub3coKSxcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICh0aGlzLmF1dG9CYXRjaFRyYWNpbmcgJiZcbiAgICAgICAgICAgIHJ1bkNyZWF0ZS50cmFjZV9pZCAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICBydW5DcmVhdGUuZG90dGVkX29yZGVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHZvaWQgdGhpcy5wcm9jZXNzUnVuT3BlcmF0aW9uKHtcbiAgICAgICAgICAgICAgICBhY3Rpb246IFwiY3JlYXRlXCIsXG4gICAgICAgICAgICAgICAgaXRlbTogcnVuQ3JlYXRlLFxuICAgICAgICAgICAgfSkuY2F0Y2goY29uc29sZS5lcnJvcik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWVyZ2VkUnVuQ3JlYXRlUGFyYW0gPSBtZXJnZVJ1bnRpbWVFbnZJbnRvUnVuQ3JlYXRlKHJ1bkNyZWF0ZSk7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5jYWxsZXIuY2FsbChfZ2V0RmV0Y2hJbXBsZW1lbnRhdGlvbigpLCBgJHt0aGlzLmFwaVVybH0vcnVuc2AsIHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgICAgICBoZWFkZXJzLFxuICAgICAgICAgICAgYm9keTogc2VyaWFsaXplUGF5bG9hZEZvclRyYWNpbmcobWVyZ2VkUnVuQ3JlYXRlUGFyYW0pLFxuICAgICAgICAgICAgc2lnbmFsOiBBYm9ydFNpZ25hbC50aW1lb3V0KHRoaXMudGltZW91dF9tcyksXG4gICAgICAgICAgICAuLi50aGlzLmZldGNoT3B0aW9ucyxcbiAgICAgICAgfSk7XG4gICAgICAgIGF3YWl0IHJhaXNlRm9yU3RhdHVzKHJlc3BvbnNlLCBcImNyZWF0ZSBydW5cIiwgdHJ1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEJhdGNoIGluZ2VzdC91cHNlcnQgbXVsdGlwbGUgcnVucyBpbiB0aGUgTGFuZ3NtaXRoIHN5c3RlbS5cbiAgICAgKiBAcGFyYW0gcnVuc1xuICAgICAqL1xuICAgIGFzeW5jIGJhdGNoSW5nZXN0UnVucyh7IHJ1bkNyZWF0ZXMsIHJ1blVwZGF0ZXMsIH0pIHtcbiAgICAgICAgaWYgKHJ1bkNyZWF0ZXMgPT09IHVuZGVmaW5lZCAmJiBydW5VcGRhdGVzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcHJlcGFyZWRDcmVhdGVQYXJhbXMgPSBydW5DcmVhdGVzPy5tYXAoKGNyZWF0ZSkgPT4gdGhpcy5wcmVwYXJlUnVuQ3JlYXRlT3JVcGRhdGVJbnB1dHMoY3JlYXRlKSkgPz8gW107XG4gICAgICAgIGxldCBwcmVwYXJlZFVwZGF0ZVBhcmFtcyA9IHJ1blVwZGF0ZXM/Lm1hcCgodXBkYXRlKSA9PiB0aGlzLnByZXBhcmVSdW5DcmVhdGVPclVwZGF0ZUlucHV0cyh1cGRhdGUpKSA/PyBbXTtcbiAgICAgICAgaWYgKHByZXBhcmVkQ3JlYXRlUGFyYW1zLmxlbmd0aCA+IDAgJiYgcHJlcGFyZWRVcGRhdGVQYXJhbXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgY29uc3QgY3JlYXRlQnlJZCA9IHByZXBhcmVkQ3JlYXRlUGFyYW1zLnJlZHVjZSgocGFyYW1zLCBydW4pID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIXJ1bi5pZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGFyYW1zO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwYXJhbXNbcnVuLmlkXSA9IHJ1bjtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyYW1zO1xuICAgICAgICAgICAgfSwge30pO1xuICAgICAgICAgICAgY29uc3Qgc3RhbmRhbG9uZVVwZGF0ZXMgPSBbXTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgdXBkYXRlUGFyYW0gb2YgcHJlcGFyZWRVcGRhdGVQYXJhbXMpIHtcbiAgICAgICAgICAgICAgICBpZiAodXBkYXRlUGFyYW0uaWQgIT09IHVuZGVmaW5lZCAmJiBjcmVhdGVCeUlkW3VwZGF0ZVBhcmFtLmlkXSkge1xuICAgICAgICAgICAgICAgICAgICBjcmVhdGVCeUlkW3VwZGF0ZVBhcmFtLmlkXSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLmNyZWF0ZUJ5SWRbdXBkYXRlUGFyYW0uaWRdLFxuICAgICAgICAgICAgICAgICAgICAgICAgLi4udXBkYXRlUGFyYW0sXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzdGFuZGFsb25lVXBkYXRlcy5wdXNoKHVwZGF0ZVBhcmFtKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwcmVwYXJlZENyZWF0ZVBhcmFtcyA9IE9iamVjdC52YWx1ZXMoY3JlYXRlQnlJZCk7XG4gICAgICAgICAgICBwcmVwYXJlZFVwZGF0ZVBhcmFtcyA9IHN0YW5kYWxvbmVVcGRhdGVzO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJhd0JhdGNoID0ge1xuICAgICAgICAgICAgcG9zdDogcHJlcGFyZWRDcmVhdGVQYXJhbXMsXG4gICAgICAgICAgICBwYXRjaDogcHJlcGFyZWRVcGRhdGVQYXJhbXMsXG4gICAgICAgIH07XG4gICAgICAgIGlmICghcmF3QmF0Y2gucG9zdC5sZW5ndGggJiYgIXJhd0JhdGNoLnBhdGNoLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGJhdGNoQ2h1bmtzID0ge1xuICAgICAgICAgICAgcG9zdDogW10sXG4gICAgICAgICAgICBwYXRjaDogW10sXG4gICAgICAgIH07XG4gICAgICAgIGZvciAoY29uc3QgayBvZiBbXCJwb3N0XCIsIFwicGF0Y2hcIl0pIHtcbiAgICAgICAgICAgIGNvbnN0IGtleSA9IGs7XG4gICAgICAgICAgICBjb25zdCBiYXRjaEl0ZW1zID0gcmF3QmF0Y2hba2V5XS5yZXZlcnNlKCk7XG4gICAgICAgICAgICBsZXQgYmF0Y2hJdGVtID0gYmF0Y2hJdGVtcy5wb3AoKTtcbiAgICAgICAgICAgIHdoaWxlIChiYXRjaEl0ZW0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIC8vIFR5cGUgaXMgd3JvbmcgYnV0IHRoaXMgaXMgYSBkZXByZWNhdGVkIGNvZGUgcGF0aCBhbnl3YXlcbiAgICAgICAgICAgICAgICBiYXRjaENodW5rc1trZXldLnB1c2goYmF0Y2hJdGVtKTtcbiAgICAgICAgICAgICAgICBiYXRjaEl0ZW0gPSBiYXRjaEl0ZW1zLnBvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChiYXRjaENodW5rcy5wb3N0Lmxlbmd0aCA+IDAgfHwgYmF0Y2hDaHVua3MucGF0Y2gubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5fcG9zdEJhdGNoSW5nZXN0UnVucyhzZXJpYWxpemVQYXlsb2FkRm9yVHJhY2luZyhiYXRjaENodW5rcykpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIF9wb3N0QmF0Y2hJbmdlc3RSdW5zKGJvZHkpIHtcbiAgICAgICAgY29uc3QgaGVhZGVycyA9IHtcbiAgICAgICAgICAgIC4uLnRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgICAgICAgQWNjZXB0OiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmJhdGNoSW5nZXN0Q2FsbGVyLmNhbGwoX2dldEZldGNoSW1wbGVtZW50YXRpb24oKSwgYCR7dGhpcy5hcGlVcmx9L3J1bnMvYmF0Y2hgLCB7XG4gICAgICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICAgICAgaGVhZGVycyxcbiAgICAgICAgICAgIGJvZHk6IGJvZHksXG4gICAgICAgICAgICBzaWduYWw6IEFib3J0U2lnbmFsLnRpbWVvdXQodGhpcy50aW1lb3V0X21zKSxcbiAgICAgICAgICAgIC4uLnRoaXMuZmV0Y2hPcHRpb25zLFxuICAgICAgICB9KTtcbiAgICAgICAgYXdhaXQgcmFpc2VGb3JTdGF0dXMocmVzcG9uc2UsIFwiYmF0Y2ggY3JlYXRlIHJ1blwiLCB0cnVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQmF0Y2ggaW5nZXN0L3Vwc2VydCBtdWx0aXBsZSBydW5zIGluIHRoZSBMYW5nc21pdGggc3lzdGVtLlxuICAgICAqIEBwYXJhbSBydW5zXG4gICAgICovXG4gICAgYXN5bmMgbXVsdGlwYXJ0SW5nZXN0UnVucyh7IHJ1bkNyZWF0ZXMsIHJ1blVwZGF0ZXMsIH0pIHtcbiAgICAgICAgaWYgKHJ1bkNyZWF0ZXMgPT09IHVuZGVmaW5lZCAmJiBydW5VcGRhdGVzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyB0cmFuc2Zvcm0gYW5kIGNvbnZlcnQgdG8gZGljdHNcbiAgICAgICAgY29uc3QgYWxsQXR0YWNobWVudHMgPSB7fTtcbiAgICAgICAgbGV0IHByZXBhcmVkQ3JlYXRlUGFyYW1zID0gW107XG4gICAgICAgIGZvciAoY29uc3QgY3JlYXRlIG9mIHJ1bkNyZWF0ZXMgPz8gW10pIHtcbiAgICAgICAgICAgIGNvbnN0IHByZXBhcmVkQ3JlYXRlID0gdGhpcy5wcmVwYXJlUnVuQ3JlYXRlT3JVcGRhdGVJbnB1dHMoY3JlYXRlKTtcbiAgICAgICAgICAgIGlmIChwcmVwYXJlZENyZWF0ZS5pZCAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAgICAgcHJlcGFyZWRDcmVhdGUuYXR0YWNobWVudHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGFsbEF0dGFjaG1lbnRzW3ByZXBhcmVkQ3JlYXRlLmlkXSA9IHByZXBhcmVkQ3JlYXRlLmF0dGFjaG1lbnRzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVsZXRlIHByZXBhcmVkQ3JlYXRlLmF0dGFjaG1lbnRzO1xuICAgICAgICAgICAgcHJlcGFyZWRDcmVhdGVQYXJhbXMucHVzaChwcmVwYXJlZENyZWF0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHByZXBhcmVkVXBkYXRlUGFyYW1zID0gW107XG4gICAgICAgIGZvciAoY29uc3QgdXBkYXRlIG9mIHJ1blVwZGF0ZXMgPz8gW10pIHtcbiAgICAgICAgICAgIHByZXBhcmVkVXBkYXRlUGFyYW1zLnB1c2godGhpcy5wcmVwYXJlUnVuQ3JlYXRlT3JVcGRhdGVJbnB1dHModXBkYXRlKSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gcmVxdWlyZSB0cmFjZV9pZCBhbmQgZG90dGVkX29yZGVyXG4gICAgICAgIGNvbnN0IGludmFsaWRSdW5DcmVhdGUgPSBwcmVwYXJlZENyZWF0ZVBhcmFtcy5maW5kKChydW5DcmVhdGUpID0+IHtcbiAgICAgICAgICAgIHJldHVybiAocnVuQ3JlYXRlLnRyYWNlX2lkID09PSB1bmRlZmluZWQgfHwgcnVuQ3JlYXRlLmRvdHRlZF9vcmRlciA9PT0gdW5kZWZpbmVkKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChpbnZhbGlkUnVuQ3JlYXRlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgTXVsdGlwYXJ0IGluZ2VzdCByZXF1aXJlcyBcInRyYWNlX2lkXCIgYW5kIFwiZG90dGVkX29yZGVyXCIgdG8gYmUgc2V0IHdoZW4gY3JlYXRpbmcgYSBydW5gKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpbnZhbGlkUnVuVXBkYXRlID0gcHJlcGFyZWRVcGRhdGVQYXJhbXMuZmluZCgocnVuVXBkYXRlKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gKHJ1blVwZGF0ZS50cmFjZV9pZCA9PT0gdW5kZWZpbmVkIHx8IHJ1blVwZGF0ZS5kb3R0ZWRfb3JkZXIgPT09IHVuZGVmaW5lZCk7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoaW52YWxpZFJ1blVwZGF0ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE11bHRpcGFydCBpbmdlc3QgcmVxdWlyZXMgXCJ0cmFjZV9pZFwiIGFuZCBcImRvdHRlZF9vcmRlclwiIHRvIGJlIHNldCB3aGVuIHVwZGF0aW5nIGEgcnVuYCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gY29tYmluZSBwb3N0IGFuZCBwYXRjaCBkaWN0cyB3aGVyZSBwb3NzaWJsZVxuICAgICAgICBpZiAocHJlcGFyZWRDcmVhdGVQYXJhbXMubGVuZ3RoID4gMCAmJiBwcmVwYXJlZFVwZGF0ZVBhcmFtcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBjb25zdCBjcmVhdGVCeUlkID0gcHJlcGFyZWRDcmVhdGVQYXJhbXMucmVkdWNlKChwYXJhbXMsIHJ1bikgPT4ge1xuICAgICAgICAgICAgICAgIGlmICghcnVuLmlkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwYXJhbXM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHBhcmFtc1tydW4uaWRdID0gcnVuO1xuICAgICAgICAgICAgICAgIHJldHVybiBwYXJhbXM7XG4gICAgICAgICAgICB9LCB7fSk7XG4gICAgICAgICAgICBjb25zdCBzdGFuZGFsb25lVXBkYXRlcyA9IFtdO1xuICAgICAgICAgICAgZm9yIChjb25zdCB1cGRhdGVQYXJhbSBvZiBwcmVwYXJlZFVwZGF0ZVBhcmFtcykge1xuICAgICAgICAgICAgICAgIGlmICh1cGRhdGVQYXJhbS5pZCAhPT0gdW5kZWZpbmVkICYmIGNyZWF0ZUJ5SWRbdXBkYXRlUGFyYW0uaWRdKSB7XG4gICAgICAgICAgICAgICAgICAgIGNyZWF0ZUJ5SWRbdXBkYXRlUGFyYW0uaWRdID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgLi4uY3JlYXRlQnlJZFt1cGRhdGVQYXJhbS5pZF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAuLi51cGRhdGVQYXJhbSxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YW5kYWxvbmVVcGRhdGVzLnB1c2godXBkYXRlUGFyYW0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHByZXBhcmVkQ3JlYXRlUGFyYW1zID0gT2JqZWN0LnZhbHVlcyhjcmVhdGVCeUlkKTtcbiAgICAgICAgICAgIHByZXBhcmVkVXBkYXRlUGFyYW1zID0gc3RhbmRhbG9uZVVwZGF0ZXM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByZXBhcmVkQ3JlYXRlUGFyYW1zLmxlbmd0aCA9PT0gMCAmJlxuICAgICAgICAgICAgcHJlcGFyZWRVcGRhdGVQYXJhbXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gc2VuZCB0aGUgcnVucyBpbiBtdWx0aXBhcnQgcmVxdWVzdHNcbiAgICAgICAgY29uc3QgYWNjdW11bGF0ZWRDb250ZXh0ID0gW107XG4gICAgICAgIGNvbnN0IGFjY3VtdWxhdGVkUGFydHMgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBbbWV0aG9kLCBwYXlsb2Fkc10gb2YgW1xuICAgICAgICAgICAgW1wicG9zdFwiLCBwcmVwYXJlZENyZWF0ZVBhcmFtc10sXG4gICAgICAgICAgICBbXCJwYXRjaFwiLCBwcmVwYXJlZFVwZGF0ZVBhcmFtc10sXG4gICAgICAgIF0pIHtcbiAgICAgICAgICAgIGZvciAoY29uc3Qgb3JpZ2luYWxQYXlsb2FkIG9mIHBheWxvYWRzKSB7XG4gICAgICAgICAgICAgICAgLy8gY29sbGVjdCBmaWVsZHMgdG8gYmUgc2VudCBhcyBzZXBhcmF0ZSBwYXJ0c1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgaW5wdXRzLCBvdXRwdXRzLCBldmVudHMsIGF0dGFjaG1lbnRzLCAuLi5wYXlsb2FkIH0gPSBvcmlnaW5hbFBheWxvYWQ7XG4gICAgICAgICAgICAgICAgY29uc3QgZmllbGRzID0geyBpbnB1dHMsIG91dHB1dHMsIGV2ZW50cyB9O1xuICAgICAgICAgICAgICAgIC8vIGVuY29kZSB0aGUgbWFpbiBydW4gcGF5bG9hZFxuICAgICAgICAgICAgICAgIGNvbnN0IHN0cmluZ2lmaWVkUGF5bG9hZCA9IHNlcmlhbGl6ZVBheWxvYWRGb3JUcmFjaW5nKHBheWxvYWQpO1xuICAgICAgICAgICAgICAgIGFjY3VtdWxhdGVkUGFydHMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IGAke21ldGhvZH0uJHtwYXlsb2FkLmlkfWAsXG4gICAgICAgICAgICAgICAgICAgIHBheWxvYWQ6IG5ldyBCbG9iKFtzdHJpbmdpZmllZFBheWxvYWRdLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBgYXBwbGljYXRpb24vanNvbjsgbGVuZ3RoPSR7c3RyaW5naWZpZWRQYXlsb2FkLmxlbmd0aH1gLCAvLyBlbmNvZGluZz1nemlwXG4gICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIC8vIGVuY29kZSB0aGUgZmllbGRzIHdlIGNvbGxlY3RlZFxuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKGZpZWxkcykpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHN0cmluZ2lmaWVkVmFsdWUgPSBzZXJpYWxpemVQYXlsb2FkRm9yVHJhY2luZyh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIGFjY3VtdWxhdGVkUGFydHMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBgJHttZXRob2R9LiR7cGF5bG9hZC5pZH0uJHtrZXl9YCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBheWxvYWQ6IG5ldyBCbG9iKFtzdHJpbmdpZmllZFZhbHVlXSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IGBhcHBsaWNhdGlvbi9qc29uOyBsZW5ndGg9JHtzdHJpbmdpZmllZFZhbHVlLmxlbmd0aH1gLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBlbmNvZGUgdGhlIGF0dGFjaG1lbnRzXG4gICAgICAgICAgICAgICAgaWYgKHBheWxvYWQuaWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBhdHRhY2htZW50cyA9IGFsbEF0dGFjaG1lbnRzW3BheWxvYWQuaWRdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYXR0YWNobWVudHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBhbGxBdHRhY2htZW50c1twYXlsb2FkLmlkXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgW25hbWUsIGF0dGFjaG1lbnRdIG9mIE9iamVjdC5lbnRyaWVzKGF0dGFjaG1lbnRzKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBjb250ZW50VHlwZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgY29udGVudDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShhdHRhY2htZW50KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbY29udGVudFR5cGUsIGNvbnRlbnRdID0gYXR0YWNobWVudDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnRUeXBlID0gYXR0YWNobWVudC5taW1lVHlwZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudCA9IGF0dGFjaG1lbnQuZGF0YTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVmFsaWRhdGUgdGhhdCB0aGUgYXR0YWNobWVudCBuYW1lIGRvZXNuJ3QgY29udGFpbiBhICcuJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuYW1lLmluY2x1ZGVzKFwiLlwiKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oYFNraXBwaW5nIGF0dGFjaG1lbnQgJyR7bmFtZX0nIGZvciBydW4gJHtwYXlsb2FkLmlkfTogSW52YWxpZCBhdHRhY2htZW50IG5hbWUuIGAgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYEF0dGFjaG1lbnQgbmFtZXMgbXVzdCBub3QgY29udGFpbiBwZXJpb2RzICgnLicpLiBQbGVhc2UgcmVuYW1lIHRoZSBhdHRhY2htZW50IGFuZCB0cnkgYWdhaW4uYCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY2N1bXVsYXRlZFBhcnRzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBgYXR0YWNobWVudC4ke3BheWxvYWQuaWR9LiR7bmFtZX1gLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXlsb2FkOiBuZXcgQmxvYihbY29udGVudF0sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IGAke2NvbnRlbnRUeXBlfTsgbGVuZ3RoPSR7Y29udGVudC5ieXRlTGVuZ3RofWAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGNvbXB1dGUgY29udGV4dFxuICAgICAgICAgICAgICAgIGFjY3VtdWxhdGVkQ29udGV4dC5wdXNoKGB0cmFjZT0ke3BheWxvYWQudHJhY2VfaWR9LGlkPSR7cGF5bG9hZC5pZH1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBhd2FpdCB0aGlzLl9zZW5kTXVsdGlwYXJ0UmVxdWVzdChhY2N1bXVsYXRlZFBhcnRzLCBhY2N1bXVsYXRlZENvbnRleHQuam9pbihcIjsgXCIpKTtcbiAgICB9XG4gICAgYXN5bmMgX3NlbmRNdWx0aXBhcnRSZXF1ZXN0KHBhcnRzLCBjb250ZXh0KSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBDcmVhdGUgbXVsdGlwYXJ0IGZvcm0gZGF0YSBtYW51YWxseSB1c2luZyBCbG9ic1xuICAgICAgICAgICAgY29uc3QgYm91bmRhcnkgPSBcIi0tLS1MYW5nU21pdGhGb3JtQm91bmRhcnlcIiArIE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnNsaWNlKDIpO1xuICAgICAgICAgICAgY29uc3QgY2h1bmtzID0gW107XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHBhcnQgb2YgcGFydHMpIHtcbiAgICAgICAgICAgICAgICAvLyBBZGQgZmllbGQgYm91bmRhcnlcbiAgICAgICAgICAgICAgICBjaHVua3MucHVzaChuZXcgQmxvYihbYC0tJHtib3VuZGFyeX1cXHJcXG5gXSkpO1xuICAgICAgICAgICAgICAgIGNodW5rcy5wdXNoKG5ldyBCbG9iKFtcbiAgICAgICAgICAgICAgICAgICAgYENvbnRlbnQtRGlzcG9zaXRpb246IGZvcm0tZGF0YTsgbmFtZT1cIiR7cGFydC5uYW1lfVwiXFxyXFxuYCxcbiAgICAgICAgICAgICAgICAgICAgYENvbnRlbnQtVHlwZTogJHtwYXJ0LnBheWxvYWQudHlwZX1cXHJcXG5cXHJcXG5gLFxuICAgICAgICAgICAgICAgIF0pKTtcbiAgICAgICAgICAgICAgICBjaHVua3MucHVzaChwYXJ0LnBheWxvYWQpO1xuICAgICAgICAgICAgICAgIGNodW5rcy5wdXNoKG5ldyBCbG9iKFtcIlxcclxcblwiXSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQWRkIGZpbmFsIGJvdW5kYXJ5XG4gICAgICAgICAgICBjaHVua3MucHVzaChuZXcgQmxvYihbYC0tJHtib3VuZGFyeX0tLVxcclxcbmBdKSk7XG4gICAgICAgICAgICAvLyBDb21iaW5lIGFsbCBjaHVua3MgaW50byBhIHNpbmdsZSBCbG9iXG4gICAgICAgICAgICBjb25zdCBib2R5ID0gbmV3IEJsb2IoY2h1bmtzKTtcbiAgICAgICAgICAgIC8vIENvbnZlcnQgQmxvYiB0byBBcnJheUJ1ZmZlciBmb3IgY29tcGF0aWJpbGl0eVxuICAgICAgICAgICAgY29uc3QgYXJyYXlCdWZmZXIgPSBhd2FpdCBib2R5LmFycmF5QnVmZmVyKCk7XG4gICAgICAgICAgICBjb25zdCByZXMgPSBhd2FpdCB0aGlzLmJhdGNoSW5nZXN0Q2FsbGVyLmNhbGwoX2dldEZldGNoSW1wbGVtZW50YXRpb24oKSwgYCR7dGhpcy5hcGlVcmx9L3J1bnMvbXVsdGlwYXJ0YCwge1xuICAgICAgICAgICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgICAgICAgICAuLi50aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgICAgIFwiQ29udGVudC1UeXBlXCI6IGBtdWx0aXBhcnQvZm9ybS1kYXRhOyBib3VuZGFyeT0ke2JvdW5kYXJ5fWAsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBib2R5OiBhcnJheUJ1ZmZlcixcbiAgICAgICAgICAgICAgICBzaWduYWw6IEFib3J0U2lnbmFsLnRpbWVvdXQodGhpcy50aW1lb3V0X21zKSxcbiAgICAgICAgICAgICAgICAuLi50aGlzLmZldGNoT3B0aW9ucyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYXdhaXQgcmFpc2VGb3JTdGF0dXMocmVzLCBcImluZ2VzdCBtdWx0aXBhcnQgcnVuc1wiLCB0cnVlKTtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihgJHtlLm1lc3NhZ2UudHJpbSgpfVxcblxcbkNvbnRleHQ6ICR7Y29udGV4dH1gKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyB1cGRhdGVSdW4ocnVuSWQsIHJ1bikge1xuICAgICAgICBhc3NlcnRVdWlkKHJ1bklkKTtcbiAgICAgICAgaWYgKHJ1bi5pbnB1dHMpIHtcbiAgICAgICAgICAgIHJ1bi5pbnB1dHMgPSB0aGlzLnByb2Nlc3NJbnB1dHMocnVuLmlucHV0cyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJ1bi5vdXRwdXRzKSB7XG4gICAgICAgICAgICBydW4ub3V0cHV0cyA9IHRoaXMucHJvY2Vzc091dHB1dHMocnVuLm91dHB1dHMpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRPRE86IFVudGFuZ2xlIHR5cGVzXG4gICAgICAgIGNvbnN0IGRhdGEgPSB7IC4uLnJ1biwgaWQ6IHJ1bklkIH07XG4gICAgICAgIGlmICghdGhpcy5fZmlsdGVyRm9yU2FtcGxpbmcoW2RhdGFdLCB0cnVlKS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5hdXRvQmF0Y2hUcmFjaW5nICYmXG4gICAgICAgICAgICBkYXRhLnRyYWNlX2lkICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIGRhdGEuZG90dGVkX29yZGVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGlmIChydW4uZW5kX3RpbWUgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgICAgIGRhdGEucGFyZW50X3J1bl9pZCA9PT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAgICAgdGhpcy5ibG9ja09uUm9vdFJ1bkZpbmFsaXphdGlvbiAmJlxuICAgICAgICAgICAgICAgICF0aGlzLm1hbnVhbEZsdXNoTW9kZSkge1xuICAgICAgICAgICAgICAgIC8vIFRyaWdnZXIgYmF0Y2hlcyBhcyBzb29uIGFzIGEgcm9vdCB0cmFjZSBlbmRzIGFuZCB3YWl0IHRvIGVuc3VyZSB0cmFjZSBmaW5pc2hlc1xuICAgICAgICAgICAgICAgIC8vIGluIHNlcnZlcmxlc3MgZW52aXJvbm1lbnRzLlxuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucHJvY2Vzc1J1bk9wZXJhdGlvbih7IGFjdGlvbjogXCJ1cGRhdGVcIiwgaXRlbTogZGF0YSB9KS5jYXRjaChjb25zb2xlLmVycm9yKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2b2lkIHRoaXMucHJvY2Vzc1J1bk9wZXJhdGlvbih7IGFjdGlvbjogXCJ1cGRhdGVcIiwgaXRlbTogZGF0YSB9KS5jYXRjaChjb25zb2xlLmVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBoZWFkZXJzID0geyAuLi50aGlzLmhlYWRlcnMsIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiIH07XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5jYWxsZXIuY2FsbChfZ2V0RmV0Y2hJbXBsZW1lbnRhdGlvbigpLCBgJHt0aGlzLmFwaVVybH0vcnVucy8ke3J1bklkfWAsIHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJQQVRDSFwiLFxuICAgICAgICAgICAgaGVhZGVycyxcbiAgICAgICAgICAgIGJvZHk6IHNlcmlhbGl6ZVBheWxvYWRGb3JUcmFjaW5nKHJ1biksXG4gICAgICAgICAgICBzaWduYWw6IEFib3J0U2lnbmFsLnRpbWVvdXQodGhpcy50aW1lb3V0X21zKSxcbiAgICAgICAgICAgIC4uLnRoaXMuZmV0Y2hPcHRpb25zLFxuICAgICAgICB9KTtcbiAgICAgICAgYXdhaXQgcmFpc2VGb3JTdGF0dXMocmVzcG9uc2UsIFwidXBkYXRlIHJ1blwiLCB0cnVlKTtcbiAgICB9XG4gICAgYXN5bmMgcmVhZFJ1bihydW5JZCwgeyBsb2FkQ2hpbGRSdW5zIH0gPSB7IGxvYWRDaGlsZFJ1bnM6IGZhbHNlIH0pIHtcbiAgICAgICAgYXNzZXJ0VXVpZChydW5JZCk7XG4gICAgICAgIGxldCBydW4gPSBhd2FpdCB0aGlzLl9nZXQoYC9ydW5zLyR7cnVuSWR9YCk7XG4gICAgICAgIGlmIChsb2FkQ2hpbGRSdW5zICYmIHJ1bi5jaGlsZF9ydW5faWRzKSB7XG4gICAgICAgICAgICBydW4gPSBhd2FpdCB0aGlzLl9sb2FkQ2hpbGRSdW5zKHJ1bik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJ1bjtcbiAgICB9XG4gICAgYXN5bmMgZ2V0UnVuVXJsKHsgcnVuSWQsIHJ1biwgcHJvamVjdE9wdHMsIH0pIHtcbiAgICAgICAgaWYgKHJ1biAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBsZXQgc2Vzc2lvbklkO1xuICAgICAgICAgICAgaWYgKHJ1bi5zZXNzaW9uX2lkKSB7XG4gICAgICAgICAgICAgICAgc2Vzc2lvbklkID0gcnVuLnNlc3Npb25faWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChwcm9qZWN0T3B0cz8ucHJvamVjdE5hbWUpIHtcbiAgICAgICAgICAgICAgICBzZXNzaW9uSWQgPSAoYXdhaXQgdGhpcy5yZWFkUHJvamVjdCh7IHByb2plY3ROYW1lOiBwcm9qZWN0T3B0cz8ucHJvamVjdE5hbWUgfSkpLmlkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocHJvamVjdE9wdHM/LnByb2plY3RJZCkge1xuICAgICAgICAgICAgICAgIHNlc3Npb25JZCA9IHByb2plY3RPcHRzPy5wcm9qZWN0SWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwcm9qZWN0ID0gYXdhaXQgdGhpcy5yZWFkUHJvamVjdCh7XG4gICAgICAgICAgICAgICAgICAgIHByb2plY3ROYW1lOiBnZXRMYW5nU21pdGhFbnZpcm9ubWVudFZhcmlhYmxlKFwiUFJPSkVDVFwiKSB8fCBcImRlZmF1bHRcIixcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBzZXNzaW9uSWQgPSBwcm9qZWN0LmlkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgdGVuYW50SWQgPSBhd2FpdCB0aGlzLl9nZXRUZW5hbnRJZCgpO1xuICAgICAgICAgICAgcmV0dXJuIGAke3RoaXMuZ2V0SG9zdFVybCgpfS9vLyR7dGVuYW50SWR9L3Byb2plY3RzL3AvJHtzZXNzaW9uSWR9L3IvJHtydW4uaWR9P3BvbGw9dHJ1ZWA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocnVuSWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29uc3QgcnVuXyA9IGF3YWl0IHRoaXMucmVhZFJ1bihydW5JZCk7XG4gICAgICAgICAgICBpZiAoIXJ1bl8uYXBwX3BhdGgpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFJ1biAke3J1bklkfSBoYXMgbm8gYXBwX3BhdGhgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGJhc2VVcmwgPSB0aGlzLmdldEhvc3RVcmwoKTtcbiAgICAgICAgICAgIHJldHVybiBgJHtiYXNlVXJsfSR7cnVuXy5hcHBfcGF0aH1gO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTXVzdCBwcm92aWRlIGVpdGhlciBydW5JZCBvciBydW5cIik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgX2xvYWRDaGlsZFJ1bnMocnVuKSB7XG4gICAgICAgIGNvbnN0IGNoaWxkUnVucyA9IGF3YWl0IHRvQXJyYXkodGhpcy5saXN0UnVucyh7IGlkOiBydW4uY2hpbGRfcnVuX2lkcyB9KSk7XG4gICAgICAgIGNvbnN0IHRyZWVtYXAgPSB7fTtcbiAgICAgICAgY29uc3QgcnVucyA9IHt9O1xuICAgICAgICAvLyBUT0RPOiBtYWtlIGRvdHRlZCBvcmRlciByZXF1aXJlZCB3aGVuIHRoZSBtaWdyYXRpb24gZmluaXNoZXNcbiAgICAgICAgY2hpbGRSdW5zLnNvcnQoKGEsIGIpID0+IChhPy5kb3R0ZWRfb3JkZXIgPz8gXCJcIikubG9jYWxlQ29tcGFyZShiPy5kb3R0ZWRfb3JkZXIgPz8gXCJcIikpO1xuICAgICAgICBmb3IgKGNvbnN0IGNoaWxkUnVuIG9mIGNoaWxkUnVucykge1xuICAgICAgICAgICAgaWYgKGNoaWxkUnVuLnBhcmVudF9ydW5faWQgPT09IG51bGwgfHxcbiAgICAgICAgICAgICAgICBjaGlsZFJ1bi5wYXJlbnRfcnVuX2lkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENoaWxkIHJ1biAke2NoaWxkUnVuLmlkfSBoYXMgbm8gcGFyZW50YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIShjaGlsZFJ1bi5wYXJlbnRfcnVuX2lkIGluIHRyZWVtYXApKSB7XG4gICAgICAgICAgICAgICAgdHJlZW1hcFtjaGlsZFJ1bi5wYXJlbnRfcnVuX2lkXSA9IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJlZW1hcFtjaGlsZFJ1bi5wYXJlbnRfcnVuX2lkXS5wdXNoKGNoaWxkUnVuKTtcbiAgICAgICAgICAgIHJ1bnNbY2hpbGRSdW4uaWRdID0gY2hpbGRSdW47XG4gICAgICAgIH1cbiAgICAgICAgcnVuLmNoaWxkX3J1bnMgPSB0cmVlbWFwW3J1bi5pZF0gfHwgW107XG4gICAgICAgIGZvciAoY29uc3QgcnVuSWQgaW4gdHJlZW1hcCkge1xuICAgICAgICAgICAgaWYgKHJ1bklkICE9PSBydW4uaWQpIHtcbiAgICAgICAgICAgICAgICBydW5zW3J1bklkXS5jaGlsZF9ydW5zID0gdHJlZW1hcFtydW5JZF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJ1bjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTGlzdCBydW5zIGZyb20gdGhlIExhbmdTbWl0aCBzZXJ2ZXIuXG4gICAgICogQHBhcmFtIHByb2plY3RJZCAtIFRoZSBJRCBvZiB0aGUgcHJvamVjdCB0byBmaWx0ZXIgYnkuXG4gICAgICogQHBhcmFtIHByb2plY3ROYW1lIC0gVGhlIG5hbWUgb2YgdGhlIHByb2plY3QgdG8gZmlsdGVyIGJ5LlxuICAgICAqIEBwYXJhbSBwYXJlbnRSdW5JZCAtIFRoZSBJRCBvZiB0aGUgcGFyZW50IHJ1biB0byBmaWx0ZXIgYnkuXG4gICAgICogQHBhcmFtIHRyYWNlSWQgLSBUaGUgSUQgb2YgdGhlIHRyYWNlIHRvIGZpbHRlciBieS5cbiAgICAgKiBAcGFyYW0gcmVmZXJlbmNlRXhhbXBsZUlkIC0gVGhlIElEIG9mIHRoZSByZWZlcmVuY2UgZXhhbXBsZSB0byBmaWx0ZXIgYnkuXG4gICAgICogQHBhcmFtIHN0YXJ0VGltZSAtIFRoZSBzdGFydCB0aW1lIHRvIGZpbHRlciBieS5cbiAgICAgKiBAcGFyYW0gaXNSb290IC0gSW5kaWNhdGVzIHdoZXRoZXIgdG8gb25seSByZXR1cm4gcm9vdCBydW5zLlxuICAgICAqIEBwYXJhbSBydW5UeXBlIC0gVGhlIHJ1biB0eXBlIHRvIGZpbHRlciBieS5cbiAgICAgKiBAcGFyYW0gZXJyb3IgLSBJbmRpY2F0ZXMgd2hldGhlciB0byBmaWx0ZXIgYnkgZXJyb3IgcnVucy5cbiAgICAgKiBAcGFyYW0gaWQgLSBUaGUgSUQgb2YgdGhlIHJ1biB0byBmaWx0ZXIgYnkuXG4gICAgICogQHBhcmFtIHF1ZXJ5IC0gVGhlIHF1ZXJ5IHN0cmluZyB0byBmaWx0ZXIgYnkuXG4gICAgICogQHBhcmFtIGZpbHRlciAtIFRoZSBmaWx0ZXIgc3RyaW5nIHRvIGFwcGx5IHRvIHRoZSBydW4gc3BhbnMuXG4gICAgICogQHBhcmFtIHRyYWNlRmlsdGVyIC0gVGhlIGZpbHRlciBzdHJpbmcgdG8gYXBwbHkgb24gdGhlIHJvb3QgcnVuIG9mIHRoZSB0cmFjZS5cbiAgICAgKiBAcGFyYW0gdHJlZUZpbHRlciAtIFRoZSBmaWx0ZXIgc3RyaW5nIHRvIGFwcGx5IG9uIG90aGVyIHJ1bnMgaW4gdGhlIHRyYWNlLlxuICAgICAqIEBwYXJhbSBsaW1pdCAtIFRoZSBtYXhpbXVtIG51bWJlciBvZiBydW5zIHRvIHJldHJpZXZlLlxuICAgICAqIEByZXR1cm5zIHtBc3luY0l0ZXJhYmxlPFJ1bj59IC0gVGhlIHJ1bnMuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIExpc3QgYWxsIHJ1bnMgaW4gYSBwcm9qZWN0XG4gICAgICogY29uc3QgcHJvamVjdFJ1bnMgPSBjbGllbnQubGlzdFJ1bnMoeyBwcm9qZWN0TmFtZTogXCI8eW91cl9wcm9qZWN0PlwiIH0pO1xuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBMaXN0IExMTSBhbmQgQ2hhdCBydW5zIGluIHRoZSBsYXN0IDI0IGhvdXJzXG4gICAgICogY29uc3QgdG9kYXlzTExNUnVucyA9IGNsaWVudC5saXN0UnVucyh7XG4gICAgICogICBwcm9qZWN0TmFtZTogXCI8eW91cl9wcm9qZWN0PlwiLFxuICAgICAqICAgc3RhcnRfdGltZTogbmV3IERhdGUoRGF0ZS5ub3coKSAtIDI0ICogNjAgKiA2MCAqIDEwMDApLFxuICAgICAqICAgcnVuX3R5cGU6IFwibGxtXCIsXG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIExpc3QgdHJhY2VzIGluIGEgcHJvamVjdFxuICAgICAqIGNvbnN0IHJvb3RSdW5zID0gY2xpZW50Lmxpc3RSdW5zKHtcbiAgICAgKiAgIHByb2plY3ROYW1lOiBcIjx5b3VyX3Byb2plY3Q+XCIsXG4gICAgICogICBleGVjdXRpb25fb3JkZXI6IDEsXG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIExpc3QgcnVucyB3aXRob3V0IGVycm9yc1xuICAgICAqIGNvbnN0IGNvcnJlY3RSdW5zID0gY2xpZW50Lmxpc3RSdW5zKHtcbiAgICAgKiAgIHByb2plY3ROYW1lOiBcIjx5b3VyX3Byb2plY3Q+XCIsXG4gICAgICogICBlcnJvcjogZmFsc2UsXG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIExpc3QgcnVucyBieSBydW4gSURcbiAgICAgKiBjb25zdCBydW5JZHMgPSBbXG4gICAgICogICBcImEzNjA5MmQyLTRhZDUtNGZiNC05YzBkLTBkYmE5YTJlZDgzNlwiLFxuICAgICAqICAgXCI5Mzk4ZTZiZS05NjRmLTRhYTQtOGFlOS1hZDc4Y2Q0YjcwNzRcIixcbiAgICAgKiBdO1xuICAgICAqIGNvbnN0IHNlbGVjdGVkUnVucyA9IGNsaWVudC5saXN0UnVucyh7IHJ1bl9pZHM6IHJ1bklkcyB9KTtcbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gTGlzdCBhbGwgXCJjaGFpblwiIHR5cGUgcnVucyB0aGF0IHRvb2sgbW9yZSB0aGFuIDEwIHNlY29uZHMgYW5kIGhhZCBgdG90YWxfdG9rZW5zYCBncmVhdGVyIHRoYW4gNTAwMFxuICAgICAqIGNvbnN0IGNoYWluUnVucyA9IGNsaWVudC5saXN0UnVucyh7XG4gICAgICogICBwcm9qZWN0TmFtZTogXCI8eW91cl9wcm9qZWN0PlwiLFxuICAgICAqICAgZmlsdGVyOiAnYW5kKGVxKHJ1bl90eXBlLCBcImNoYWluXCIpLCBndChsYXRlbmN5LCAxMCksIGd0KHRvdGFsX3Rva2VucywgNTAwMCkpJyxcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gTGlzdCBhbGwgcnVucyBjYWxsZWQgXCJleHRyYWN0b3JcIiB3aG9zZSByb290IG9mIHRoZSB0cmFjZSB3YXMgYXNzaWduZWQgZmVlZGJhY2sgXCJ1c2VyX3Njb3JlXCIgc2NvcmUgb2YgMVxuICAgICAqIGNvbnN0IGdvb2RFeHRyYWN0b3JSdW5zID0gY2xpZW50Lmxpc3RSdW5zKHtcbiAgICAgKiAgIHByb2plY3ROYW1lOiBcIjx5b3VyX3Byb2plY3Q+XCIsXG4gICAgICogICBmaWx0ZXI6ICdlcShuYW1lLCBcImV4dHJhY3RvclwiKScsXG4gICAgICogICB0cmFjZUZpbHRlcjogJ2FuZChlcShmZWVkYmFja19rZXksIFwidXNlcl9zY29yZVwiKSwgZXEoZmVlZGJhY2tfc2NvcmUsIDEpKScsXG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIExpc3QgYWxsIHJ1bnMgdGhhdCBzdGFydGVkIGFmdGVyIGEgc3BlY2lmaWMgdGltZXN0YW1wIGFuZCBlaXRoZXIgaGF2ZSBcImVycm9yXCIgbm90IGVxdWFsIHRvIG51bGwgb3IgYSBcIkNvcnJlY3RuZXNzXCIgZmVlZGJhY2sgc2NvcmUgZXF1YWwgdG8gMFxuICAgICAqIGNvbnN0IGNvbXBsZXhSdW5zID0gY2xpZW50Lmxpc3RSdW5zKHtcbiAgICAgKiAgIHByb2plY3ROYW1lOiBcIjx5b3VyX3Byb2plY3Q+XCIsXG4gICAgICogICBmaWx0ZXI6ICdhbmQoZ3Qoc3RhcnRfdGltZSwgXCIyMDIzLTA3LTE1VDEyOjM0OjU2WlwiKSwgb3IobmVxKGVycm9yLCBudWxsKSwgYW5kKGVxKGZlZWRiYWNrX2tleSwgXCJDb3JyZWN0bmVzc1wiKSwgZXEoZmVlZGJhY2tfc2NvcmUsIDAuMCkpKSknLFxuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBMaXN0IGFsbCBydW5zIHdoZXJlIGB0YWdzYCBpbmNsdWRlIFwiZXhwZXJpbWVudGFsXCIgb3IgXCJiZXRhXCIgYW5kIGBsYXRlbmN5YCBpcyBncmVhdGVyIHRoYW4gMiBzZWNvbmRzXG4gICAgICogY29uc3QgdGFnZ2VkUnVucyA9IGNsaWVudC5saXN0UnVucyh7XG4gICAgICogICBwcm9qZWN0TmFtZTogXCI8eW91cl9wcm9qZWN0PlwiLFxuICAgICAqICAgZmlsdGVyOiAnYW5kKG9yKGhhcyh0YWdzLCBcImV4cGVyaW1lbnRhbFwiKSwgaGFzKHRhZ3MsIFwiYmV0YVwiKSksIGd0KGxhdGVuY3ksIDIpKScsXG4gICAgICogfSk7XG4gICAgICovXG4gICAgYXN5bmMgKmxpc3RSdW5zKHByb3BzKSB7XG4gICAgICAgIGNvbnN0IHsgcHJvamVjdElkLCBwcm9qZWN0TmFtZSwgcGFyZW50UnVuSWQsIHRyYWNlSWQsIHJlZmVyZW5jZUV4YW1wbGVJZCwgc3RhcnRUaW1lLCBleGVjdXRpb25PcmRlciwgaXNSb290LCBydW5UeXBlLCBlcnJvciwgaWQsIHF1ZXJ5LCBmaWx0ZXIsIHRyYWNlRmlsdGVyLCB0cmVlRmlsdGVyLCBsaW1pdCwgc2VsZWN0LCB9ID0gcHJvcHM7XG4gICAgICAgIGxldCBwcm9qZWN0SWRzID0gW107XG4gICAgICAgIGlmIChwcm9qZWN0SWQpIHtcbiAgICAgICAgICAgIHByb2plY3RJZHMgPSBBcnJheS5pc0FycmF5KHByb2plY3RJZCkgPyBwcm9qZWN0SWQgOiBbcHJvamVjdElkXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJvamVjdE5hbWUpIHtcbiAgICAgICAgICAgIGNvbnN0IHByb2plY3ROYW1lcyA9IEFycmF5LmlzQXJyYXkocHJvamVjdE5hbWUpXG4gICAgICAgICAgICAgICAgPyBwcm9qZWN0TmFtZVxuICAgICAgICAgICAgICAgIDogW3Byb2plY3ROYW1lXTtcbiAgICAgICAgICAgIGNvbnN0IHByb2plY3RJZHNfID0gYXdhaXQgUHJvbWlzZS5hbGwocHJvamVjdE5hbWVzLm1hcCgobmFtZSkgPT4gdGhpcy5yZWFkUHJvamVjdCh7IHByb2plY3ROYW1lOiBuYW1lIH0pLnRoZW4oKHByb2plY3QpID0+IHByb2plY3QuaWQpKSk7XG4gICAgICAgICAgICBwcm9qZWN0SWRzLnB1c2goLi4ucHJvamVjdElkc18pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRlZmF1bHRfc2VsZWN0ID0gW1xuICAgICAgICAgICAgXCJhcHBfcGF0aFwiLFxuICAgICAgICAgICAgXCJjaGlsZF9ydW5faWRzXCIsXG4gICAgICAgICAgICBcImNvbXBsZXRpb25fY29zdFwiLFxuICAgICAgICAgICAgXCJjb21wbGV0aW9uX3Rva2Vuc1wiLFxuICAgICAgICAgICAgXCJkb3R0ZWRfb3JkZXJcIixcbiAgICAgICAgICAgIFwiZW5kX3RpbWVcIixcbiAgICAgICAgICAgIFwiZXJyb3JcIixcbiAgICAgICAgICAgIFwiZXZlbnRzXCIsXG4gICAgICAgICAgICBcImV4dHJhXCIsXG4gICAgICAgICAgICBcImZlZWRiYWNrX3N0YXRzXCIsXG4gICAgICAgICAgICBcImZpcnN0X3Rva2VuX3RpbWVcIixcbiAgICAgICAgICAgIFwiaWRcIixcbiAgICAgICAgICAgIFwiaW5wdXRzXCIsXG4gICAgICAgICAgICBcIm5hbWVcIixcbiAgICAgICAgICAgIFwib3V0cHV0c1wiLFxuICAgICAgICAgICAgXCJwYXJlbnRfcnVuX2lkXCIsXG4gICAgICAgICAgICBcInBhcmVudF9ydW5faWRzXCIsXG4gICAgICAgICAgICBcInByb21wdF9jb3N0XCIsXG4gICAgICAgICAgICBcInByb21wdF90b2tlbnNcIixcbiAgICAgICAgICAgIFwicmVmZXJlbmNlX2V4YW1wbGVfaWRcIixcbiAgICAgICAgICAgIFwicnVuX3R5cGVcIixcbiAgICAgICAgICAgIFwic2Vzc2lvbl9pZFwiLFxuICAgICAgICAgICAgXCJzdGFydF90aW1lXCIsXG4gICAgICAgICAgICBcInN0YXR1c1wiLFxuICAgICAgICAgICAgXCJ0YWdzXCIsXG4gICAgICAgICAgICBcInRvdGFsX2Nvc3RcIixcbiAgICAgICAgICAgIFwidG90YWxfdG9rZW5zXCIsXG4gICAgICAgICAgICBcInRyYWNlX2lkXCIsXG4gICAgICAgIF07XG4gICAgICAgIGNvbnN0IGJvZHkgPSB7XG4gICAgICAgICAgICBzZXNzaW9uOiBwcm9qZWN0SWRzLmxlbmd0aCA/IHByb2plY3RJZHMgOiBudWxsLFxuICAgICAgICAgICAgcnVuX3R5cGU6IHJ1blR5cGUsXG4gICAgICAgICAgICByZWZlcmVuY2VfZXhhbXBsZTogcmVmZXJlbmNlRXhhbXBsZUlkLFxuICAgICAgICAgICAgcXVlcnksXG4gICAgICAgICAgICBmaWx0ZXIsXG4gICAgICAgICAgICB0cmFjZV9maWx0ZXI6IHRyYWNlRmlsdGVyLFxuICAgICAgICAgICAgdHJlZV9maWx0ZXI6IHRyZWVGaWx0ZXIsXG4gICAgICAgICAgICBleGVjdXRpb25fb3JkZXI6IGV4ZWN1dGlvbk9yZGVyLFxuICAgICAgICAgICAgcGFyZW50X3J1bjogcGFyZW50UnVuSWQsXG4gICAgICAgICAgICBzdGFydF90aW1lOiBzdGFydFRpbWUgPyBzdGFydFRpbWUudG9JU09TdHJpbmcoKSA6IG51bGwsXG4gICAgICAgICAgICBlcnJvcixcbiAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgbGltaXQsXG4gICAgICAgICAgICB0cmFjZTogdHJhY2VJZCxcbiAgICAgICAgICAgIHNlbGVjdDogc2VsZWN0ID8gc2VsZWN0IDogZGVmYXVsdF9zZWxlY3QsXG4gICAgICAgICAgICBpc19yb290OiBpc1Jvb3QsXG4gICAgICAgIH07XG4gICAgICAgIGxldCBydW5zWWllbGRlZCA9IDA7XG4gICAgICAgIGZvciBhd2FpdCAoY29uc3QgcnVucyBvZiB0aGlzLl9nZXRDdXJzb3JQYWdpbmF0ZWRMaXN0KFwiL3J1bnMvcXVlcnlcIiwgYm9keSkpIHtcbiAgICAgICAgICAgIGlmIChsaW1pdCkge1xuICAgICAgICAgICAgICAgIGlmIChydW5zWWllbGRlZCA+PSBsaW1pdCkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHJ1bnMubGVuZ3RoICsgcnVuc1lpZWxkZWQgPiBsaW1pdCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXdSdW5zID0gcnVucy5zbGljZSgwLCBsaW1pdCAtIHJ1bnNZaWVsZGVkKTtcbiAgICAgICAgICAgICAgICAgICAgeWllbGQqIG5ld1J1bnM7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBydW5zWWllbGRlZCArPSBydW5zLmxlbmd0aDtcbiAgICAgICAgICAgICAgICB5aWVsZCogcnVucztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHlpZWxkKiBydW5zO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIGdldFJ1blN0YXRzKHsgaWQsIHRyYWNlLCBwYXJlbnRSdW4sIHJ1blR5cGUsIHByb2plY3ROYW1lcywgcHJvamVjdElkcywgcmVmZXJlbmNlRXhhbXBsZUlkcywgc3RhcnRUaW1lLCBlbmRUaW1lLCBlcnJvciwgcXVlcnksIGZpbHRlciwgdHJhY2VGaWx0ZXIsIHRyZWVGaWx0ZXIsIGlzUm9vdCwgZGF0YVNvdXJjZVR5cGUsIH0pIHtcbiAgICAgICAgbGV0IHByb2plY3RJZHNfID0gcHJvamVjdElkcyB8fCBbXTtcbiAgICAgICAgaWYgKHByb2plY3ROYW1lcykge1xuICAgICAgICAgICAgcHJvamVjdElkc18gPSBbXG4gICAgICAgICAgICAgICAgLi4uKHByb2plY3RJZHMgfHwgW10pLFxuICAgICAgICAgICAgICAgIC4uLihhd2FpdCBQcm9taXNlLmFsbChwcm9qZWN0TmFtZXMubWFwKChuYW1lKSA9PiB0aGlzLnJlYWRQcm9qZWN0KHsgcHJvamVjdE5hbWU6IG5hbWUgfSkudGhlbigocHJvamVjdCkgPT4gcHJvamVjdC5pZCkpKSksXG4gICAgICAgICAgICBdO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBheWxvYWQgPSB7XG4gICAgICAgICAgICBpZCxcbiAgICAgICAgICAgIHRyYWNlLFxuICAgICAgICAgICAgcGFyZW50X3J1bjogcGFyZW50UnVuLFxuICAgICAgICAgICAgcnVuX3R5cGU6IHJ1blR5cGUsXG4gICAgICAgICAgICBzZXNzaW9uOiBwcm9qZWN0SWRzXyxcbiAgICAgICAgICAgIHJlZmVyZW5jZV9leGFtcGxlOiByZWZlcmVuY2VFeGFtcGxlSWRzLFxuICAgICAgICAgICAgc3RhcnRfdGltZTogc3RhcnRUaW1lLFxuICAgICAgICAgICAgZW5kX3RpbWU6IGVuZFRpbWUsXG4gICAgICAgICAgICBlcnJvcixcbiAgICAgICAgICAgIHF1ZXJ5LFxuICAgICAgICAgICAgZmlsdGVyLFxuICAgICAgICAgICAgdHJhY2VfZmlsdGVyOiB0cmFjZUZpbHRlcixcbiAgICAgICAgICAgIHRyZWVfZmlsdGVyOiB0cmVlRmlsdGVyLFxuICAgICAgICAgICAgaXNfcm9vdDogaXNSb290LFxuICAgICAgICAgICAgZGF0YV9zb3VyY2VfdHlwZTogZGF0YVNvdXJjZVR5cGUsXG4gICAgICAgIH07XG4gICAgICAgIC8vIFJlbW92ZSB1bmRlZmluZWQgdmFsdWVzIGZyb20gdGhlIHBheWxvYWRcbiAgICAgICAgY29uc3QgZmlsdGVyZWRQYXlsb2FkID0gT2JqZWN0LmZyb21FbnRyaWVzKE9iamVjdC5lbnRyaWVzKHBheWxvYWQpLmZpbHRlcigoW18sIHZhbHVlXSkgPT4gdmFsdWUgIT09IHVuZGVmaW5lZCkpO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuY2FsbGVyLmNhbGwoX2dldEZldGNoSW1wbGVtZW50YXRpb24oKSwgYCR7dGhpcy5hcGlVcmx9L3J1bnMvc3RhdHNgLCB7XG4gICAgICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoZmlsdGVyZWRQYXlsb2FkKSxcbiAgICAgICAgICAgIHNpZ25hbDogQWJvcnRTaWduYWwudGltZW91dCh0aGlzLnRpbWVvdXRfbXMpLFxuICAgICAgICAgICAgLi4udGhpcy5mZXRjaE9wdGlvbnMsXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGFzeW5jIHNoYXJlUnVuKHJ1bklkLCB7IHNoYXJlSWQgfSA9IHt9KSB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSB7XG4gICAgICAgICAgICBydW5faWQ6IHJ1bklkLFxuICAgICAgICAgICAgc2hhcmVfdG9rZW46IHNoYXJlSWQgfHwgdXVpZC52NCgpLFxuICAgICAgICB9O1xuICAgICAgICBhc3NlcnRVdWlkKHJ1bklkKTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmNhbGxlci5jYWxsKF9nZXRGZXRjaEltcGxlbWVudGF0aW9uKCksIGAke3RoaXMuYXBpVXJsfS9ydW5zLyR7cnVuSWR9L3NoYXJlYCwge1xuICAgICAgICAgICAgbWV0aG9kOiBcIlBVVFwiLFxuICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoZGF0YSksXG4gICAgICAgICAgICBzaWduYWw6IEFib3J0U2lnbmFsLnRpbWVvdXQodGhpcy50aW1lb3V0X21zKSxcbiAgICAgICAgICAgIC4uLnRoaXMuZmV0Y2hPcHRpb25zLFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgICBpZiAocmVzdWx0ID09PSBudWxsIHx8ICEoXCJzaGFyZV90b2tlblwiIGluIHJlc3VsdCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgcmVzcG9uc2UgZnJvbSBzZXJ2ZXJcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGAke3RoaXMuZ2V0SG9zdFVybCgpfS9wdWJsaWMvJHtyZXN1bHRbXCJzaGFyZV90b2tlblwiXX0vcmA7XG4gICAgfVxuICAgIGFzeW5jIHVuc2hhcmVSdW4ocnVuSWQpIHtcbiAgICAgICAgYXNzZXJ0VXVpZChydW5JZCk7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5jYWxsZXIuY2FsbChfZ2V0RmV0Y2hJbXBsZW1lbnRhdGlvbigpLCBgJHt0aGlzLmFwaVVybH0vcnVucy8ke3J1bklkfS9zaGFyZWAsIHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJERUxFVEVcIixcbiAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgIHNpZ25hbDogQWJvcnRTaWduYWwudGltZW91dCh0aGlzLnRpbWVvdXRfbXMpLFxuICAgICAgICAgICAgLi4udGhpcy5mZXRjaE9wdGlvbnMsXG4gICAgICAgIH0pO1xuICAgICAgICBhd2FpdCByYWlzZUZvclN0YXR1cyhyZXNwb25zZSwgXCJ1bnNoYXJlIHJ1blwiLCB0cnVlKTtcbiAgICB9XG4gICAgYXN5bmMgcmVhZFJ1blNoYXJlZExpbmsocnVuSWQpIHtcbiAgICAgICAgYXNzZXJ0VXVpZChydW5JZCk7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5jYWxsZXIuY2FsbChfZ2V0RmV0Y2hJbXBsZW1lbnRhdGlvbigpLCBgJHt0aGlzLmFwaVVybH0vcnVucy8ke3J1bklkfS9zaGFyZWAsIHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJHRVRcIixcbiAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgIHNpZ25hbDogQWJvcnRTaWduYWwudGltZW91dCh0aGlzLnRpbWVvdXRfbXMpLFxuICAgICAgICAgICAgLi4udGhpcy5mZXRjaE9wdGlvbnMsXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgIGlmIChyZXN1bHQgPT09IG51bGwgfHwgIShcInNoYXJlX3Rva2VuXCIgaW4gcmVzdWx0KSkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYCR7dGhpcy5nZXRIb3N0VXJsKCl9L3B1YmxpYy8ke3Jlc3VsdFtcInNoYXJlX3Rva2VuXCJdfS9yYDtcbiAgICB9XG4gICAgYXN5bmMgbGlzdFNoYXJlZFJ1bnMoc2hhcmVUb2tlbiwgeyBydW5JZHMsIH0gPSB7fSkge1xuICAgICAgICBjb25zdCBxdWVyeVBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoe1xuICAgICAgICAgICAgc2hhcmVfdG9rZW46IHNoYXJlVG9rZW4sXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAocnVuSWRzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgcnVuSWQgb2YgcnVuSWRzKSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbXMuYXBwZW5kKFwiaWRcIiwgcnVuSWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGFzc2VydFV1aWQoc2hhcmVUb2tlbik7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5jYWxsZXIuY2FsbChfZ2V0RmV0Y2hJbXBsZW1lbnRhdGlvbigpLCBgJHt0aGlzLmFwaVVybH0vcHVibGljLyR7c2hhcmVUb2tlbn0vcnVucyR7cXVlcnlQYXJhbXN9YCwge1xuICAgICAgICAgICAgbWV0aG9kOiBcIkdFVFwiLFxuICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgc2lnbmFsOiBBYm9ydFNpZ25hbC50aW1lb3V0KHRoaXMudGltZW91dF9tcyksXG4gICAgICAgICAgICAuLi50aGlzLmZldGNoT3B0aW9ucyxcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHJ1bnMgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgIHJldHVybiBydW5zO1xuICAgIH1cbiAgICBhc3luYyByZWFkRGF0YXNldFNoYXJlZFNjaGVtYShkYXRhc2V0SWQsIGRhdGFzZXROYW1lKSB7XG4gICAgICAgIGlmICghZGF0YXNldElkICYmICFkYXRhc2V0TmFtZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRWl0aGVyIGRhdGFzZXRJZCBvciBkYXRhc2V0TmFtZSBtdXN0IGJlIGdpdmVuXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZGF0YXNldElkKSB7XG4gICAgICAgICAgICBjb25zdCBkYXRhc2V0ID0gYXdhaXQgdGhpcy5yZWFkRGF0YXNldCh7IGRhdGFzZXROYW1lIH0pO1xuICAgICAgICAgICAgZGF0YXNldElkID0gZGF0YXNldC5pZDtcbiAgICAgICAgfVxuICAgICAgICBhc3NlcnRVdWlkKGRhdGFzZXRJZCk7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5jYWxsZXIuY2FsbChfZ2V0RmV0Y2hJbXBsZW1lbnRhdGlvbigpLCBgJHt0aGlzLmFwaVVybH0vZGF0YXNldHMvJHtkYXRhc2V0SWR9L3NoYXJlYCwge1xuICAgICAgICAgICAgbWV0aG9kOiBcIkdFVFwiLFxuICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgc2lnbmFsOiBBYm9ydFNpZ25hbC50aW1lb3V0KHRoaXMudGltZW91dF9tcyksXG4gICAgICAgICAgICAuLi50aGlzLmZldGNoT3B0aW9ucyxcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHNoYXJlU2NoZW1hID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgICBzaGFyZVNjaGVtYS51cmwgPSBgJHt0aGlzLmdldEhvc3RVcmwoKX0vcHVibGljLyR7c2hhcmVTY2hlbWEuc2hhcmVfdG9rZW59L2RgO1xuICAgICAgICByZXR1cm4gc2hhcmVTY2hlbWE7XG4gICAgfVxuICAgIGFzeW5jIHNoYXJlRGF0YXNldChkYXRhc2V0SWQsIGRhdGFzZXROYW1lKSB7XG4gICAgICAgIGlmICghZGF0YXNldElkICYmICFkYXRhc2V0TmFtZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRWl0aGVyIGRhdGFzZXRJZCBvciBkYXRhc2V0TmFtZSBtdXN0IGJlIGdpdmVuXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZGF0YXNldElkKSB7XG4gICAgICAgICAgICBjb25zdCBkYXRhc2V0ID0gYXdhaXQgdGhpcy5yZWFkRGF0YXNldCh7IGRhdGFzZXROYW1lIH0pO1xuICAgICAgICAgICAgZGF0YXNldElkID0gZGF0YXNldC5pZDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkYXRhID0ge1xuICAgICAgICAgICAgZGF0YXNldF9pZDogZGF0YXNldElkLFxuICAgICAgICB9O1xuICAgICAgICBhc3NlcnRVdWlkKGRhdGFzZXRJZCk7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5jYWxsZXIuY2FsbChfZ2V0RmV0Y2hJbXBsZW1lbnRhdGlvbigpLCBgJHt0aGlzLmFwaVVybH0vZGF0YXNldHMvJHtkYXRhc2V0SWR9L3NoYXJlYCwge1xuICAgICAgICAgICAgbWV0aG9kOiBcIlBVVFwiLFxuICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoZGF0YSksXG4gICAgICAgICAgICBzaWduYWw6IEFib3J0U2lnbmFsLnRpbWVvdXQodGhpcy50aW1lb3V0X21zKSxcbiAgICAgICAgICAgIC4uLnRoaXMuZmV0Y2hPcHRpb25zLFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3Qgc2hhcmVTY2hlbWEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgIHNoYXJlU2NoZW1hLnVybCA9IGAke3RoaXMuZ2V0SG9zdFVybCgpfS9wdWJsaWMvJHtzaGFyZVNjaGVtYS5zaGFyZV90b2tlbn0vZGA7XG4gICAgICAgIHJldHVybiBzaGFyZVNjaGVtYTtcbiAgICB9XG4gICAgYXN5bmMgdW5zaGFyZURhdGFzZXQoZGF0YXNldElkKSB7XG4gICAgICAgIGFzc2VydFV1aWQoZGF0YXNldElkKTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmNhbGxlci5jYWxsKF9nZXRGZXRjaEltcGxlbWVudGF0aW9uKCksIGAke3RoaXMuYXBpVXJsfS9kYXRhc2V0cy8ke2RhdGFzZXRJZH0vc2hhcmVgLCB7XG4gICAgICAgICAgICBtZXRob2Q6IFwiREVMRVRFXCIsXG4gICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICBzaWduYWw6IEFib3J0U2lnbmFsLnRpbWVvdXQodGhpcy50aW1lb3V0X21zKSxcbiAgICAgICAgICAgIC4uLnRoaXMuZmV0Y2hPcHRpb25zLFxuICAgICAgICB9KTtcbiAgICAgICAgYXdhaXQgcmFpc2VGb3JTdGF0dXMocmVzcG9uc2UsIFwidW5zaGFyZSBkYXRhc2V0XCIsIHRydWUpO1xuICAgIH1cbiAgICBhc3luYyByZWFkU2hhcmVkRGF0YXNldChzaGFyZVRva2VuKSB7XG4gICAgICAgIGFzc2VydFV1aWQoc2hhcmVUb2tlbik7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5jYWxsZXIuY2FsbChfZ2V0RmV0Y2hJbXBsZW1lbnRhdGlvbigpLCBgJHt0aGlzLmFwaVVybH0vcHVibGljLyR7c2hhcmVUb2tlbn0vZGF0YXNldHNgLCB7XG4gICAgICAgICAgICBtZXRob2Q6IFwiR0VUXCIsXG4gICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICBzaWduYWw6IEFib3J0U2lnbmFsLnRpbWVvdXQodGhpcy50aW1lb3V0X21zKSxcbiAgICAgICAgICAgIC4uLnRoaXMuZmV0Y2hPcHRpb25zLFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgZGF0YXNldCA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgcmV0dXJuIGRhdGFzZXQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBzaGFyZWQgZXhhbXBsZXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc2hhcmVUb2tlbiBUaGUgc2hhcmUgdG9rZW4gdG8gZ2V0IGV4YW1wbGVzIGZvci4gQSBzaGFyZSB0b2tlbiBpcyB0aGUgVVVJRCAob3IgTGFuZ1NtaXRoIFVSTCwgaW5jbHVkaW5nIFVVSUQpIGdlbmVyYXRlZCB3aGVuIGV4cGxpY2l0bHkgbWFya2luZyBhbiBleGFtcGxlIGFzIHB1YmxpYy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIEFkZGl0aW9uYWwgb3B0aW9ucyBmb3IgbGlzdGluZyB0aGUgZXhhbXBsZXMuXG4gICAgICogQHBhcmFtIHtzdHJpbmdbXSB8IHVuZGVmaW5lZH0gW29wdGlvbnMuZXhhbXBsZUlkc10gQSBsaXN0IG9mIGV4YW1wbGUgSURzIHRvIGZpbHRlciBieS5cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxFeGFtcGxlW10+fSBUaGUgc2hhcmVkIGV4YW1wbGVzLlxuICAgICAqL1xuICAgIGFzeW5jIGxpc3RTaGFyZWRFeGFtcGxlcyhzaGFyZVRva2VuLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IHBhcmFtcyA9IHt9O1xuICAgICAgICBpZiAob3B0aW9ucz8uZXhhbXBsZUlkcykge1xuICAgICAgICAgICAgcGFyYW1zLmlkID0gb3B0aW9ucy5leGFtcGxlSWRzO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHVybFBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoKTtcbiAgICAgICAgT2JqZWN0LmVudHJpZXMocGFyYW1zKS5mb3JFYWNoKChba2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHZhbHVlLmZvckVhY2goKHYpID0+IHVybFBhcmFtcy5hcHBlbmQoa2V5LCB2KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB1cmxQYXJhbXMuYXBwZW5kKGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmNhbGxlci5jYWxsKF9nZXRGZXRjaEltcGxlbWVudGF0aW9uKCksIGAke3RoaXMuYXBpVXJsfS9wdWJsaWMvJHtzaGFyZVRva2VufS9leGFtcGxlcz8ke3VybFBhcmFtcy50b1N0cmluZygpfWAsIHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJHRVRcIixcbiAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgIHNpZ25hbDogQWJvcnRTaWduYWwudGltZW91dCh0aGlzLnRpbWVvdXRfbXMpLFxuICAgICAgICAgICAgLi4udGhpcy5mZXRjaE9wdGlvbnMsXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgICAgIGlmIChcImRldGFpbFwiIGluIHJlc3VsdCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGxpc3Qgc2hhcmVkIGV4YW1wbGVzLlxcblN0YXR1czogJHtyZXNwb25zZS5zdGF0dXN9XFxuTWVzc2FnZTogJHtyZXN1bHQuZGV0YWlsLmpvaW4oXCJcXG5cIil9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBsaXN0IHNoYXJlZCBleGFtcGxlczogJHtyZXNwb25zZS5zdGF0dXN9ICR7cmVzcG9uc2Uuc3RhdHVzVGV4dH1gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0Lm1hcCgoZXhhbXBsZSkgPT4gKHtcbiAgICAgICAgICAgIC4uLmV4YW1wbGUsXG4gICAgICAgICAgICBfaG9zdFVybDogdGhpcy5nZXRIb3N0VXJsKCksXG4gICAgICAgIH0pKTtcbiAgICB9XG4gICAgYXN5bmMgY3JlYXRlUHJvamVjdCh7IHByb2plY3ROYW1lLCBkZXNjcmlwdGlvbiA9IG51bGwsIG1ldGFkYXRhID0gbnVsbCwgdXBzZXJ0ID0gZmFsc2UsIHByb2plY3RFeHRyYSA9IG51bGwsIHJlZmVyZW5jZURhdGFzZXRJZCA9IG51bGwsIH0pIHtcbiAgICAgICAgY29uc3QgdXBzZXJ0XyA9IHVwc2VydCA/IGA/dXBzZXJ0PXRydWVgIDogXCJcIjtcbiAgICAgICAgY29uc3QgZW5kcG9pbnQgPSBgJHt0aGlzLmFwaVVybH0vc2Vzc2lvbnMke3Vwc2VydF99YDtcbiAgICAgICAgY29uc3QgZXh0cmEgPSBwcm9qZWN0RXh0cmEgfHwge307XG4gICAgICAgIGlmIChtZXRhZGF0YSkge1xuICAgICAgICAgICAgZXh0cmFbXCJtZXRhZGF0YVwiXSA9IG1ldGFkYXRhO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGJvZHkgPSB7XG4gICAgICAgICAgICBuYW1lOiBwcm9qZWN0TmFtZSxcbiAgICAgICAgICAgIGV4dHJhLFxuICAgICAgICAgICAgZGVzY3JpcHRpb24sXG4gICAgICAgIH07XG4gICAgICAgIGlmIChyZWZlcmVuY2VEYXRhc2V0SWQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGJvZHlbXCJyZWZlcmVuY2VfZGF0YXNldF9pZFwiXSA9IHJlZmVyZW5jZURhdGFzZXRJZDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuY2FsbGVyLmNhbGwoX2dldEZldGNoSW1wbGVtZW50YXRpb24oKSwgZW5kcG9pbnQsIHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgICAgICBoZWFkZXJzOiB7IC4uLnRoaXMuaGVhZGVycywgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIgfSxcbiAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgc2lnbmFsOiBBYm9ydFNpZ25hbC50aW1lb3V0KHRoaXMudGltZW91dF9tcyksXG4gICAgICAgICAgICAuLi50aGlzLmZldGNoT3B0aW9ucyxcbiAgICAgICAgfSk7XG4gICAgICAgIGF3YWl0IHJhaXNlRm9yU3RhdHVzKHJlc3BvbnNlLCBcImNyZWF0ZSBwcm9qZWN0XCIpO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGFzeW5jIHVwZGF0ZVByb2plY3QocHJvamVjdElkLCB7IG5hbWUgPSBudWxsLCBkZXNjcmlwdGlvbiA9IG51bGwsIG1ldGFkYXRhID0gbnVsbCwgcHJvamVjdEV4dHJhID0gbnVsbCwgZW5kVGltZSA9IG51bGwsIH0pIHtcbiAgICAgICAgY29uc3QgZW5kcG9pbnQgPSBgJHt0aGlzLmFwaVVybH0vc2Vzc2lvbnMvJHtwcm9qZWN0SWR9YDtcbiAgICAgICAgbGV0IGV4dHJhID0gcHJvamVjdEV4dHJhO1xuICAgICAgICBpZiAobWV0YWRhdGEpIHtcbiAgICAgICAgICAgIGV4dHJhID0geyAuLi4oZXh0cmEgfHwge30pLCBtZXRhZGF0YSB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGJvZHkgPSB7XG4gICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgZXh0cmEsXG4gICAgICAgICAgICBkZXNjcmlwdGlvbixcbiAgICAgICAgICAgIGVuZF90aW1lOiBlbmRUaW1lID8gbmV3IERhdGUoZW5kVGltZSkudG9JU09TdHJpbmcoKSA6IG51bGwsXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5jYWxsZXIuY2FsbChfZ2V0RmV0Y2hJbXBsZW1lbnRhdGlvbigpLCBlbmRwb2ludCwge1xuICAgICAgICAgICAgbWV0aG9kOiBcIlBBVENIXCIsXG4gICAgICAgICAgICBoZWFkZXJzOiB7IC4uLnRoaXMuaGVhZGVycywgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIgfSxcbiAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgc2lnbmFsOiBBYm9ydFNpZ25hbC50aW1lb3V0KHRoaXMudGltZW91dF9tcyksXG4gICAgICAgICAgICAuLi50aGlzLmZldGNoT3B0aW9ucyxcbiAgICAgICAgfSk7XG4gICAgICAgIGF3YWl0IHJhaXNlRm9yU3RhdHVzKHJlc3BvbnNlLCBcInVwZGF0ZSBwcm9qZWN0XCIpO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGFzeW5jIGhhc1Byb2plY3QoeyBwcm9qZWN0SWQsIHByb2plY3ROYW1lLCB9KSB7XG4gICAgICAgIC8vIFRPRE86IEFkZCBhIGhlYWQgcmVxdWVzdFxuICAgICAgICBsZXQgcGF0aCA9IFwiL3Nlc3Npb25zXCI7XG4gICAgICAgIGNvbnN0IHBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoKTtcbiAgICAgICAgaWYgKHByb2plY3RJZCAhPT0gdW5kZWZpbmVkICYmIHByb2plY3ROYW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk11c3QgcHJvdmlkZSBlaXRoZXIgcHJvamVjdE5hbWUgb3IgcHJvamVjdElkLCBub3QgYm90aFwiKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwcm9qZWN0SWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgYXNzZXJ0VXVpZChwcm9qZWN0SWQpO1xuICAgICAgICAgICAgcGF0aCArPSBgLyR7cHJvamVjdElkfWA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocHJvamVjdE5hbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcGFyYW1zLmFwcGVuZChcIm5hbWVcIiwgcHJvamVjdE5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTXVzdCBwcm92aWRlIHByb2plY3ROYW1lIG9yIHByb2plY3RJZFwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuY2FsbGVyLmNhbGwoX2dldEZldGNoSW1wbGVtZW50YXRpb24oKSwgYCR7dGhpcy5hcGlVcmx9JHtwYXRofT8ke3BhcmFtc31gLCB7XG4gICAgICAgICAgICBtZXRob2Q6IFwiR0VUXCIsXG4gICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICBzaWduYWw6IEFib3J0U2lnbmFsLnRpbWVvdXQodGhpcy50aW1lb3V0X21zKSxcbiAgICAgICAgICAgIC4uLnRoaXMuZmV0Y2hPcHRpb25zLFxuICAgICAgICB9KTtcbiAgICAgICAgLy8gY29uc3VtZSB0aGUgcmVzcG9uc2UgYm9keSB0byByZWxlYXNlIHRoZSBjb25uZWN0aW9uXG4gICAgICAgIC8vIGh0dHBzOi8vdW5kaWNpLm5vZGVqcy5vcmcvIy8/aWQ9Z2FyYmFnZS1jb2xsZWN0aW9uXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSWYgaXQncyBPSyBhbmQgd2UncmUgcXVlcnlpbmcgYnkgbmFtZSwgbmVlZCB0byBjaGVjayB0aGUgbGlzdCBpcyBub3QgZW1wdHlcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHJlc3VsdCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0Lmxlbmd0aCA+IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBwcm9qZWN0SWQgcXVlcnlpbmdcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgcmVhZFByb2plY3QoeyBwcm9qZWN0SWQsIHByb2plY3ROYW1lLCBpbmNsdWRlU3RhdHMsIH0pIHtcbiAgICAgICAgbGV0IHBhdGggPSBcIi9zZXNzaW9uc1wiO1xuICAgICAgICBjb25zdCBwYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKCk7XG4gICAgICAgIGlmIChwcm9qZWN0SWQgIT09IHVuZGVmaW5lZCAmJiBwcm9qZWN0TmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNdXN0IHByb3ZpZGUgZWl0aGVyIHByb2plY3ROYW1lIG9yIHByb2plY3RJZCwgbm90IGJvdGhcIik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocHJvamVjdElkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGFzc2VydFV1aWQocHJvamVjdElkKTtcbiAgICAgICAgICAgIHBhdGggKz0gYC8ke3Byb2plY3RJZH1gO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHByb2plY3ROYW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHBhcmFtcy5hcHBlbmQoXCJuYW1lXCIsIHByb2plY3ROYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk11c3QgcHJvdmlkZSBwcm9qZWN0TmFtZSBvciBwcm9qZWN0SWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGluY2x1ZGVTdGF0cyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBwYXJhbXMuYXBwZW5kKFwiaW5jbHVkZV9zdGF0c1wiLCBpbmNsdWRlU3RhdHMudG9TdHJpbmcoKSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLl9nZXQocGF0aCwgcGFyYW1zKTtcbiAgICAgICAgbGV0IHJlc3VsdDtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocmVzcG9uc2UpKSB7XG4gICAgICAgICAgICBpZiAocmVzcG9uc2UubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBQcm9qZWN0W2lkPSR7cHJvamVjdElkfSwgbmFtZT0ke3Byb2plY3ROYW1lfV0gbm90IGZvdW5kYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQgPSByZXNwb25zZVswXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHJlc3BvbnNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGFzeW5jIGdldFByb2plY3RVcmwoeyBwcm9qZWN0SWQsIHByb2plY3ROYW1lLCB9KSB7XG4gICAgICAgIGlmIChwcm9qZWN0SWQgPT09IHVuZGVmaW5lZCAmJiBwcm9qZWN0TmFtZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNdXN0IHByb3ZpZGUgZWl0aGVyIHByb2plY3ROYW1lIG9yIHByb2plY3RJZFwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwcm9qZWN0ID0gYXdhaXQgdGhpcy5yZWFkUHJvamVjdCh7IHByb2plY3RJZCwgcHJvamVjdE5hbWUgfSk7XG4gICAgICAgIGNvbnN0IHRlbmFudElkID0gYXdhaXQgdGhpcy5fZ2V0VGVuYW50SWQoKTtcbiAgICAgICAgcmV0dXJuIGAke3RoaXMuZ2V0SG9zdFVybCgpfS9vLyR7dGVuYW50SWR9L3Byb2plY3RzL3AvJHtwcm9qZWN0LmlkfWA7XG4gICAgfVxuICAgIGFzeW5jIGdldERhdGFzZXRVcmwoeyBkYXRhc2V0SWQsIGRhdGFzZXROYW1lLCB9KSB7XG4gICAgICAgIGlmIChkYXRhc2V0SWQgPT09IHVuZGVmaW5lZCAmJiBkYXRhc2V0TmFtZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNdXN0IHByb3ZpZGUgZWl0aGVyIGRhdGFzZXROYW1lIG9yIGRhdGFzZXRJZFwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkYXRhc2V0ID0gYXdhaXQgdGhpcy5yZWFkRGF0YXNldCh7IGRhdGFzZXRJZCwgZGF0YXNldE5hbWUgfSk7XG4gICAgICAgIGNvbnN0IHRlbmFudElkID0gYXdhaXQgdGhpcy5fZ2V0VGVuYW50SWQoKTtcbiAgICAgICAgcmV0dXJuIGAke3RoaXMuZ2V0SG9zdFVybCgpfS9vLyR7dGVuYW50SWR9L2RhdGFzZXRzLyR7ZGF0YXNldC5pZH1gO1xuICAgIH1cbiAgICBhc3luYyBfZ2V0VGVuYW50SWQoKSB7XG4gICAgICAgIGlmICh0aGlzLl90ZW5hbnRJZCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3RlbmFudElkO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHF1ZXJ5UGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcyh7IGxpbWl0OiBcIjFcIiB9KTtcbiAgICAgICAgZm9yIGF3YWl0IChjb25zdCBwcm9qZWN0cyBvZiB0aGlzLl9nZXRQYWdpbmF0ZWQoXCIvc2Vzc2lvbnNcIiwgcXVlcnlQYXJhbXMpKSB7XG4gICAgICAgICAgICB0aGlzLl90ZW5hbnRJZCA9IHByb2plY3RzWzBdLnRlbmFudF9pZDtcbiAgICAgICAgICAgIHJldHVybiBwcm9qZWN0c1swXS50ZW5hbnRfaWQ7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gcHJvamVjdHMgZm91bmQgdG8gcmVzb2x2ZSB0ZW5hbnQuXCIpO1xuICAgIH1cbiAgICBhc3luYyAqbGlzdFByb2plY3RzKHsgcHJvamVjdElkcywgbmFtZSwgbmFtZUNvbnRhaW5zLCByZWZlcmVuY2VEYXRhc2V0SWQsIHJlZmVyZW5jZURhdGFzZXROYW1lLCByZWZlcmVuY2VGcmVlLCBtZXRhZGF0YSwgfSA9IHt9KSB7XG4gICAgICAgIGNvbnN0IHBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoKTtcbiAgICAgICAgaWYgKHByb2plY3RJZHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBwcm9qZWN0SWQgb2YgcHJvamVjdElkcykge1xuICAgICAgICAgICAgICAgIHBhcmFtcy5hcHBlbmQoXCJpZFwiLCBwcm9qZWN0SWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChuYW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHBhcmFtcy5hcHBlbmQoXCJuYW1lXCIsIG5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChuYW1lQ29udGFpbnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcGFyYW1zLmFwcGVuZChcIm5hbWVfY29udGFpbnNcIiwgbmFtZUNvbnRhaW5zKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVmZXJlbmNlRGF0YXNldElkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHBhcmFtcy5hcHBlbmQoXCJyZWZlcmVuY2VfZGF0YXNldFwiLCByZWZlcmVuY2VEYXRhc2V0SWQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHJlZmVyZW5jZURhdGFzZXROYW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGRhdGFzZXQgPSBhd2FpdCB0aGlzLnJlYWREYXRhc2V0KHtcbiAgICAgICAgICAgICAgICBkYXRhc2V0TmFtZTogcmVmZXJlbmNlRGF0YXNldE5hbWUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHBhcmFtcy5hcHBlbmQoXCJyZWZlcmVuY2VfZGF0YXNldFwiLCBkYXRhc2V0LmlkKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVmZXJlbmNlRnJlZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBwYXJhbXMuYXBwZW5kKFwicmVmZXJlbmNlX2ZyZWVcIiwgcmVmZXJlbmNlRnJlZS50b1N0cmluZygpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWV0YWRhdGEgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcGFyYW1zLmFwcGVuZChcIm1ldGFkYXRhXCIsIEpTT04uc3RyaW5naWZ5KG1ldGFkYXRhKSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIGF3YWl0IChjb25zdCBwcm9qZWN0cyBvZiB0aGlzLl9nZXRQYWdpbmF0ZWQoXCIvc2Vzc2lvbnNcIiwgcGFyYW1zKSkge1xuICAgICAgICAgICAgeWllbGQqIHByb2plY3RzO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIGRlbGV0ZVByb2plY3QoeyBwcm9qZWN0SWQsIHByb2plY3ROYW1lLCB9KSB7XG4gICAgICAgIGxldCBwcm9qZWN0SWRfO1xuICAgICAgICBpZiAocHJvamVjdElkID09PSB1bmRlZmluZWQgJiYgcHJvamVjdE5hbWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTXVzdCBwcm92aWRlIHByb2plY3ROYW1lIG9yIHByb2plY3RJZFwiKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwcm9qZWN0SWQgIT09IHVuZGVmaW5lZCAmJiBwcm9qZWN0TmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNdXN0IHByb3ZpZGUgZWl0aGVyIHByb2plY3ROYW1lIG9yIHByb2plY3RJZCwgbm90IGJvdGhcIik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocHJvamVjdElkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHByb2plY3RJZF8gPSAoYXdhaXQgdGhpcy5yZWFkUHJvamVjdCh7IHByb2plY3ROYW1lIH0pKS5pZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHByb2plY3RJZF8gPSBwcm9qZWN0SWQ7XG4gICAgICAgIH1cbiAgICAgICAgYXNzZXJ0VXVpZChwcm9qZWN0SWRfKTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmNhbGxlci5jYWxsKF9nZXRGZXRjaEltcGxlbWVudGF0aW9uKCksIGAke3RoaXMuYXBpVXJsfS9zZXNzaW9ucy8ke3Byb2plY3RJZF99YCwge1xuICAgICAgICAgICAgbWV0aG9kOiBcIkRFTEVURVwiLFxuICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgc2lnbmFsOiBBYm9ydFNpZ25hbC50aW1lb3V0KHRoaXMudGltZW91dF9tcyksXG4gICAgICAgICAgICAuLi50aGlzLmZldGNoT3B0aW9ucyxcbiAgICAgICAgfSk7XG4gICAgICAgIGF3YWl0IHJhaXNlRm9yU3RhdHVzKHJlc3BvbnNlLCBgZGVsZXRlIHNlc3Npb24gJHtwcm9qZWN0SWRffSAoJHtwcm9qZWN0TmFtZX0pYCwgdHJ1ZSk7XG4gICAgfVxuICAgIGFzeW5jIHVwbG9hZENzdih7IGNzdkZpbGUsIGZpbGVOYW1lLCBpbnB1dEtleXMsIG91dHB1dEtleXMsIGRlc2NyaXB0aW9uLCBkYXRhVHlwZSwgbmFtZSwgfSkge1xuICAgICAgICBjb25zdCB1cmwgPSBgJHt0aGlzLmFwaVVybH0vZGF0YXNldHMvdXBsb2FkYDtcbiAgICAgICAgY29uc3QgZm9ybURhdGEgPSBuZXcgRm9ybURhdGEoKTtcbiAgICAgICAgZm9ybURhdGEuYXBwZW5kKFwiZmlsZVwiLCBjc3ZGaWxlLCBmaWxlTmFtZSk7XG4gICAgICAgIGlucHV0S2V5cy5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgICAgIGZvcm1EYXRhLmFwcGVuZChcImlucHV0X2tleXNcIiwga2V5KTtcbiAgICAgICAgfSk7XG4gICAgICAgIG91dHB1dEtleXMuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAgICAgICBmb3JtRGF0YS5hcHBlbmQoXCJvdXRwdXRfa2V5c1wiLCBrZXkpO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGRlc2NyaXB0aW9uKSB7XG4gICAgICAgICAgICBmb3JtRGF0YS5hcHBlbmQoXCJkZXNjcmlwdGlvblwiLCBkZXNjcmlwdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRhdGFUeXBlKSB7XG4gICAgICAgICAgICBmb3JtRGF0YS5hcHBlbmQoXCJkYXRhX3R5cGVcIiwgZGF0YVR5cGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChuYW1lKSB7XG4gICAgICAgICAgICBmb3JtRGF0YS5hcHBlbmQoXCJuYW1lXCIsIG5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5jYWxsZXIuY2FsbChfZ2V0RmV0Y2hJbXBsZW1lbnRhdGlvbigpLCB1cmwsIHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICBib2R5OiBmb3JtRGF0YSxcbiAgICAgICAgICAgIHNpZ25hbDogQWJvcnRTaWduYWwudGltZW91dCh0aGlzLnRpbWVvdXRfbXMpLFxuICAgICAgICAgICAgLi4udGhpcy5mZXRjaE9wdGlvbnMsXG4gICAgICAgIH0pO1xuICAgICAgICBhd2FpdCByYWlzZUZvclN0YXR1cyhyZXNwb25zZSwgXCJ1cGxvYWQgQ1NWXCIpO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGFzeW5jIGNyZWF0ZURhdGFzZXQobmFtZSwgeyBkZXNjcmlwdGlvbiwgZGF0YVR5cGUsIGlucHV0c1NjaGVtYSwgb3V0cHV0c1NjaGVtYSwgbWV0YWRhdGEsIH0gPSB7fSkge1xuICAgICAgICBjb25zdCBib2R5ID0ge1xuICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uLFxuICAgICAgICAgICAgZXh0cmE6IG1ldGFkYXRhID8geyBtZXRhZGF0YSB9IDogdW5kZWZpbmVkLFxuICAgICAgICB9O1xuICAgICAgICBpZiAoZGF0YVR5cGUpIHtcbiAgICAgICAgICAgIGJvZHkuZGF0YV90eXBlID0gZGF0YVR5cGU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlucHV0c1NjaGVtYSkge1xuICAgICAgICAgICAgYm9keS5pbnB1dHNfc2NoZW1hX2RlZmluaXRpb24gPSBpbnB1dHNTY2hlbWE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG91dHB1dHNTY2hlbWEpIHtcbiAgICAgICAgICAgIGJvZHkub3V0cHV0c19zY2hlbWFfZGVmaW5pdGlvbiA9IG91dHB1dHNTY2hlbWE7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmNhbGxlci5jYWxsKF9nZXRGZXRjaEltcGxlbWVudGF0aW9uKCksIGAke3RoaXMuYXBpVXJsfS9kYXRhc2V0c2AsIHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgICAgICBoZWFkZXJzOiB7IC4uLnRoaXMuaGVhZGVycywgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIgfSxcbiAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgc2lnbmFsOiBBYm9ydFNpZ25hbC50aW1lb3V0KHRoaXMudGltZW91dF9tcyksXG4gICAgICAgICAgICAuLi50aGlzLmZldGNoT3B0aW9ucyxcbiAgICAgICAgfSk7XG4gICAgICAgIGF3YWl0IHJhaXNlRm9yU3RhdHVzKHJlc3BvbnNlLCBcImNyZWF0ZSBkYXRhc2V0XCIpO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGFzeW5jIHJlYWREYXRhc2V0KHsgZGF0YXNldElkLCBkYXRhc2V0TmFtZSwgfSkge1xuICAgICAgICBsZXQgcGF0aCA9IFwiL2RhdGFzZXRzXCI7XG4gICAgICAgIC8vIGxpbWl0IHRvIDEgcmVzdWx0XG4gICAgICAgIGNvbnN0IHBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoeyBsaW1pdDogXCIxXCIgfSk7XG4gICAgICAgIGlmIChkYXRhc2V0SWQgIT09IHVuZGVmaW5lZCAmJiBkYXRhc2V0TmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNdXN0IHByb3ZpZGUgZWl0aGVyIGRhdGFzZXROYW1lIG9yIGRhdGFzZXRJZCwgbm90IGJvdGhcIik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZGF0YXNldElkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGFzc2VydFV1aWQoZGF0YXNldElkKTtcbiAgICAgICAgICAgIHBhdGggKz0gYC8ke2RhdGFzZXRJZH1gO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGRhdGFzZXROYW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHBhcmFtcy5hcHBlbmQoXCJuYW1lXCIsIGRhdGFzZXROYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk11c3QgcHJvdmlkZSBkYXRhc2V0TmFtZSBvciBkYXRhc2V0SWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLl9nZXQocGF0aCwgcGFyYW1zKTtcbiAgICAgICAgbGV0IHJlc3VsdDtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocmVzcG9uc2UpKSB7XG4gICAgICAgICAgICBpZiAocmVzcG9uc2UubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBEYXRhc2V0W2lkPSR7ZGF0YXNldElkfSwgbmFtZT0ke2RhdGFzZXROYW1lfV0gbm90IGZvdW5kYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQgPSByZXNwb25zZVswXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHJlc3BvbnNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGFzeW5jIGhhc0RhdGFzZXQoeyBkYXRhc2V0SWQsIGRhdGFzZXROYW1lLCB9KSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLnJlYWREYXRhc2V0KHsgZGF0YXNldElkLCBkYXRhc2V0TmFtZSB9KTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8taW5zdGFuY2VvZi9uby1pbnN0YW5jZW9mXG4gICAgICAgICAgICBlIGluc3RhbmNlb2YgRXJyb3IgJiZcbiAgICAgICAgICAgICAgICBlLm1lc3NhZ2UudG9Mb2NhbGVMb3dlckNhc2UoKS5pbmNsdWRlcyhcIm5vdCBmb3VuZFwiKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgZGlmZkRhdGFzZXRWZXJzaW9ucyh7IGRhdGFzZXRJZCwgZGF0YXNldE5hbWUsIGZyb21WZXJzaW9uLCB0b1ZlcnNpb24sIH0pIHtcbiAgICAgICAgbGV0IGRhdGFzZXRJZF8gPSBkYXRhc2V0SWQ7XG4gICAgICAgIGlmIChkYXRhc2V0SWRfID09PSB1bmRlZmluZWQgJiYgZGF0YXNldE5hbWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTXVzdCBwcm92aWRlIGVpdGhlciBkYXRhc2V0TmFtZSBvciBkYXRhc2V0SWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZGF0YXNldElkXyAhPT0gdW5kZWZpbmVkICYmIGRhdGFzZXROYW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk11c3QgcHJvdmlkZSBlaXRoZXIgZGF0YXNldE5hbWUgb3IgZGF0YXNldElkLCBub3QgYm90aFwiKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChkYXRhc2V0SWRfID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGRhdGFzZXQgPSBhd2FpdCB0aGlzLnJlYWREYXRhc2V0KHsgZGF0YXNldE5hbWUgfSk7XG4gICAgICAgICAgICBkYXRhc2V0SWRfID0gZGF0YXNldC5pZDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB1cmxQYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKHtcbiAgICAgICAgICAgIGZyb21fdmVyc2lvbjogdHlwZW9mIGZyb21WZXJzaW9uID09PSBcInN0cmluZ1wiXG4gICAgICAgICAgICAgICAgPyBmcm9tVmVyc2lvblxuICAgICAgICAgICAgICAgIDogZnJvbVZlcnNpb24udG9JU09TdHJpbmcoKSxcbiAgICAgICAgICAgIHRvX3ZlcnNpb246IHR5cGVvZiB0b1ZlcnNpb24gPT09IFwic3RyaW5nXCIgPyB0b1ZlcnNpb24gOiB0b1ZlcnNpb24udG9JU09TdHJpbmcoKSxcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5fZ2V0KGAvZGF0YXNldHMvJHtkYXRhc2V0SWRffS92ZXJzaW9ucy9kaWZmYCwgdXJsUGFyYW1zKTtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgIH1cbiAgICBhc3luYyByZWFkRGF0YXNldE9wZW5haUZpbmV0dW5pbmcoeyBkYXRhc2V0SWQsIGRhdGFzZXROYW1lLCB9KSB7XG4gICAgICAgIGNvbnN0IHBhdGggPSBcIi9kYXRhc2V0c1wiO1xuICAgICAgICBpZiAoZGF0YXNldElkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIC8vIGRvIG5vdGhpbmdcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChkYXRhc2V0TmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBkYXRhc2V0SWQgPSAoYXdhaXQgdGhpcy5yZWFkRGF0YXNldCh7IGRhdGFzZXROYW1lIH0pKS5pZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk11c3QgcHJvdmlkZSBlaXRoZXIgZGF0YXNldE5hbWUgb3IgZGF0YXNldElkXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5fZ2V0UmVzcG9uc2UoYCR7cGF0aH0vJHtkYXRhc2V0SWR9L29wZW5haV9mdGApO1xuICAgICAgICBjb25zdCBkYXRhc2V0VGV4dCA9IGF3YWl0IHJlc3BvbnNlLnRleHQoKTtcbiAgICAgICAgY29uc3QgZGF0YXNldCA9IGRhdGFzZXRUZXh0XG4gICAgICAgICAgICAudHJpbSgpXG4gICAgICAgICAgICAuc3BsaXQoXCJcXG5cIilcbiAgICAgICAgICAgIC5tYXAoKGxpbmUpID0+IEpTT04ucGFyc2UobGluZSkpO1xuICAgICAgICByZXR1cm4gZGF0YXNldDtcbiAgICB9XG4gICAgYXN5bmMgKmxpc3REYXRhc2V0cyh7IGxpbWl0ID0gMTAwLCBvZmZzZXQgPSAwLCBkYXRhc2V0SWRzLCBkYXRhc2V0TmFtZSwgZGF0YXNldE5hbWVDb250YWlucywgbWV0YWRhdGEsIH0gPSB7fSkge1xuICAgICAgICBjb25zdCBwYXRoID0gXCIvZGF0YXNldHNcIjtcbiAgICAgICAgY29uc3QgcGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcyh7XG4gICAgICAgICAgICBsaW1pdDogbGltaXQudG9TdHJpbmcoKSxcbiAgICAgICAgICAgIG9mZnNldDogb2Zmc2V0LnRvU3RyaW5nKCksXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoZGF0YXNldElkcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGlkXyBvZiBkYXRhc2V0SWRzKSB7XG4gICAgICAgICAgICAgICAgcGFyYW1zLmFwcGVuZChcImlkXCIsIGlkXyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRhdGFzZXROYW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHBhcmFtcy5hcHBlbmQoXCJuYW1lXCIsIGRhdGFzZXROYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF0YXNldE5hbWVDb250YWlucyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBwYXJhbXMuYXBwZW5kKFwibmFtZV9jb250YWluc1wiLCBkYXRhc2V0TmFtZUNvbnRhaW5zKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWV0YWRhdGEgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcGFyYW1zLmFwcGVuZChcIm1ldGFkYXRhXCIsIEpTT04uc3RyaW5naWZ5KG1ldGFkYXRhKSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIGF3YWl0IChjb25zdCBkYXRhc2V0cyBvZiB0aGlzLl9nZXRQYWdpbmF0ZWQocGF0aCwgcGFyYW1zKSkge1xuICAgICAgICAgICAgeWllbGQqIGRhdGFzZXRzO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSBhIGRhdGFzZXRcbiAgICAgKiBAcGFyYW0gcHJvcHMgVGhlIGRhdGFzZXQgZGV0YWlscyB0byB1cGRhdGVcbiAgICAgKiBAcmV0dXJucyBUaGUgdXBkYXRlZCBkYXRhc2V0XG4gICAgICovXG4gICAgYXN5bmMgdXBkYXRlRGF0YXNldChwcm9wcykge1xuICAgICAgICBjb25zdCB7IGRhdGFzZXRJZCwgZGF0YXNldE5hbWUsIC4uLnVwZGF0ZSB9ID0gcHJvcHM7XG4gICAgICAgIGlmICghZGF0YXNldElkICYmICFkYXRhc2V0TmFtZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTXVzdCBwcm92aWRlIGVpdGhlciBkYXRhc2V0TmFtZSBvciBkYXRhc2V0SWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgX2RhdGFzZXRJZCA9IGRhdGFzZXRJZCA/PyAoYXdhaXQgdGhpcy5yZWFkRGF0YXNldCh7IGRhdGFzZXROYW1lIH0pKS5pZDtcbiAgICAgICAgYXNzZXJ0VXVpZChfZGF0YXNldElkKTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmNhbGxlci5jYWxsKF9nZXRGZXRjaEltcGxlbWVudGF0aW9uKCksIGAke3RoaXMuYXBpVXJsfS9kYXRhc2V0cy8ke19kYXRhc2V0SWR9YCwge1xuICAgICAgICAgICAgbWV0aG9kOiBcIlBBVENIXCIsXG4gICAgICAgICAgICBoZWFkZXJzOiB7IC4uLnRoaXMuaGVhZGVycywgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIgfSxcbiAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHVwZGF0ZSksXG4gICAgICAgICAgICBzaWduYWw6IEFib3J0U2lnbmFsLnRpbWVvdXQodGhpcy50aW1lb3V0X21zKSxcbiAgICAgICAgICAgIC4uLnRoaXMuZmV0Y2hPcHRpb25zLFxuICAgICAgICB9KTtcbiAgICAgICAgYXdhaXQgcmFpc2VGb3JTdGF0dXMocmVzcG9uc2UsIFwidXBkYXRlIGRhdGFzZXRcIik7XG4gICAgICAgIHJldHVybiAoYXdhaXQgcmVzcG9uc2UuanNvbigpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBkYXRlcyBhIHRhZyBvbiBhIGRhdGFzZXQuXG4gICAgICpcbiAgICAgKiBJZiB0aGUgdGFnIGlzIGFscmVhZHkgYXNzaWduZWQgdG8gYSBkaWZmZXJlbnQgdmVyc2lvbiBvZiB0aGlzIGRhdGFzZXQsXG4gICAgICogdGhlIHRhZyB3aWxsIGJlIG1vdmVkIHRvIHRoZSBuZXcgdmVyc2lvbi4gVGhlIGFzX29mIHBhcmFtZXRlciBpcyB1c2VkIHRvXG4gICAgICogZGV0ZXJtaW5lIHdoaWNoIHZlcnNpb24gb2YgdGhlIGRhdGFzZXQgdG8gYXBwbHkgdGhlIG5ldyB0YWdzIHRvLlxuICAgICAqXG4gICAgICogSXQgbXVzdCBiZSBhbiBleGFjdCB2ZXJzaW9uIG9mIHRoZSBkYXRhc2V0IHRvIHN1Y2NlZWQuIFlvdSBjYW5cbiAgICAgKiB1c2UgdGhlIFwicmVhZERhdGFzZXRWZXJzaW9uXCIgbWV0aG9kIHRvIGZpbmQgdGhlIGV4YWN0IHZlcnNpb25cbiAgICAgKiB0byBhcHBseSB0aGUgdGFncyB0by5cbiAgICAgKiBAcGFyYW0gcGFyYW1zLmRhdGFzZXRJZCBUaGUgSUQgb2YgdGhlIGRhdGFzZXQgdG8gdXBkYXRlLiBNdXN0IGJlIHByb3ZpZGVkIGlmIFwiZGF0YXNldE5hbWVcIiBpcyBub3QgcHJvdmlkZWQuXG4gICAgICogQHBhcmFtIHBhcmFtcy5kYXRhc2V0TmFtZSBUaGUgbmFtZSBvZiB0aGUgZGF0YXNldCB0byB1cGRhdGUuIE11c3QgYmUgcHJvdmlkZWQgaWYgXCJkYXRhc2V0SWRcIiBpcyBub3QgcHJvdmlkZWQuXG4gICAgICogQHBhcmFtIHBhcmFtcy5hc09mIFRoZSB0aW1lc3RhbXAgb2YgdGhlIGRhdGFzZXQgdG8gYXBwbHkgdGhlIG5ldyB0YWdzIHRvLlxuICAgICAqIEBwYXJhbSBwYXJhbXMudGFnIFRoZSBuZXcgdGFnIHRvIGFwcGx5IHRvIHRoZSBkYXRhc2V0LlxuICAgICAqL1xuICAgIGFzeW5jIHVwZGF0ZURhdGFzZXRUYWcocHJvcHMpIHtcbiAgICAgICAgY29uc3QgeyBkYXRhc2V0SWQsIGRhdGFzZXROYW1lLCBhc09mLCB0YWcgfSA9IHByb3BzO1xuICAgICAgICBpZiAoIWRhdGFzZXRJZCAmJiAhZGF0YXNldE5hbWUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk11c3QgcHJvdmlkZSBlaXRoZXIgZGF0YXNldE5hbWUgb3IgZGF0YXNldElkXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IF9kYXRhc2V0SWQgPSBkYXRhc2V0SWQgPz8gKGF3YWl0IHRoaXMucmVhZERhdGFzZXQoeyBkYXRhc2V0TmFtZSB9KSkuaWQ7XG4gICAgICAgIGFzc2VydFV1aWQoX2RhdGFzZXRJZCk7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5jYWxsZXIuY2FsbChfZ2V0RmV0Y2hJbXBsZW1lbnRhdGlvbigpLCBgJHt0aGlzLmFwaVVybH0vZGF0YXNldHMvJHtfZGF0YXNldElkfS90YWdzYCwge1xuICAgICAgICAgICAgbWV0aG9kOiBcIlBVVFwiLFxuICAgICAgICAgICAgaGVhZGVyczogeyAuLi50aGlzLmhlYWRlcnMsIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiIH0sXG4gICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICAgICAgYXNfb2Y6IHR5cGVvZiBhc09mID09PSBcInN0cmluZ1wiID8gYXNPZiA6IGFzT2YudG9JU09TdHJpbmcoKSxcbiAgICAgICAgICAgICAgICB0YWcsXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIHNpZ25hbDogQWJvcnRTaWduYWwudGltZW91dCh0aGlzLnRpbWVvdXRfbXMpLFxuICAgICAgICAgICAgLi4udGhpcy5mZXRjaE9wdGlvbnMsXG4gICAgICAgIH0pO1xuICAgICAgICBhd2FpdCByYWlzZUZvclN0YXR1cyhyZXNwb25zZSwgXCJ1cGRhdGUgZGF0YXNldCB0YWdzXCIpO1xuICAgIH1cbiAgICBhc3luYyBkZWxldGVEYXRhc2V0KHsgZGF0YXNldElkLCBkYXRhc2V0TmFtZSwgfSkge1xuICAgICAgICBsZXQgcGF0aCA9IFwiL2RhdGFzZXRzXCI7XG4gICAgICAgIGxldCBkYXRhc2V0SWRfID0gZGF0YXNldElkO1xuICAgICAgICBpZiAoZGF0YXNldElkICE9PSB1bmRlZmluZWQgJiYgZGF0YXNldE5hbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTXVzdCBwcm92aWRlIGVpdGhlciBkYXRhc2V0TmFtZSBvciBkYXRhc2V0SWQsIG5vdCBib3RoXCIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGRhdGFzZXROYW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGRhdGFzZXQgPSBhd2FpdCB0aGlzLnJlYWREYXRhc2V0KHsgZGF0YXNldE5hbWUgfSk7XG4gICAgICAgICAgICBkYXRhc2V0SWRfID0gZGF0YXNldC5pZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF0YXNldElkXyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBhc3NlcnRVdWlkKGRhdGFzZXRJZF8pO1xuICAgICAgICAgICAgcGF0aCArPSBgLyR7ZGF0YXNldElkX31gO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTXVzdCBwcm92aWRlIGRhdGFzZXROYW1lIG9yIGRhdGFzZXRJZFwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuY2FsbGVyLmNhbGwoX2dldEZldGNoSW1wbGVtZW50YXRpb24oKSwgdGhpcy5hcGlVcmwgKyBwYXRoLCB7XG4gICAgICAgICAgICBtZXRob2Q6IFwiREVMRVRFXCIsXG4gICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICBzaWduYWw6IEFib3J0U2lnbmFsLnRpbWVvdXQodGhpcy50aW1lb3V0X21zKSxcbiAgICAgICAgICAgIC4uLnRoaXMuZmV0Y2hPcHRpb25zLFxuICAgICAgICB9KTtcbiAgICAgICAgYXdhaXQgcmFpc2VGb3JTdGF0dXMocmVzcG9uc2UsIGBkZWxldGUgJHtwYXRofWApO1xuICAgICAgICBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgfVxuICAgIGFzeW5jIGluZGV4RGF0YXNldCh7IGRhdGFzZXRJZCwgZGF0YXNldE5hbWUsIHRhZywgfSkge1xuICAgICAgICBsZXQgZGF0YXNldElkXyA9IGRhdGFzZXRJZDtcbiAgICAgICAgaWYgKCFkYXRhc2V0SWRfICYmICFkYXRhc2V0TmFtZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTXVzdCBwcm92aWRlIGVpdGhlciBkYXRhc2V0TmFtZSBvciBkYXRhc2V0SWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZGF0YXNldElkXyAmJiBkYXRhc2V0TmFtZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTXVzdCBwcm92aWRlIGVpdGhlciBkYXRhc2V0TmFtZSBvciBkYXRhc2V0SWQsIG5vdCBib3RoXCIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCFkYXRhc2V0SWRfKSB7XG4gICAgICAgICAgICBjb25zdCBkYXRhc2V0ID0gYXdhaXQgdGhpcy5yZWFkRGF0YXNldCh7IGRhdGFzZXROYW1lIH0pO1xuICAgICAgICAgICAgZGF0YXNldElkXyA9IGRhdGFzZXQuaWQ7XG4gICAgICAgIH1cbiAgICAgICAgYXNzZXJ0VXVpZChkYXRhc2V0SWRfKTtcbiAgICAgICAgY29uc3QgZGF0YSA9IHtcbiAgICAgICAgICAgIHRhZzogdGFnLFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuY2FsbGVyLmNhbGwoX2dldEZldGNoSW1wbGVtZW50YXRpb24oKSwgYCR7dGhpcy5hcGlVcmx9L2RhdGFzZXRzLyR7ZGF0YXNldElkX30vaW5kZXhgLCB7XG4gICAgICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICAgICAgaGVhZGVyczogeyAuLi50aGlzLmhlYWRlcnMsIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiIH0sXG4gICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShkYXRhKSxcbiAgICAgICAgICAgIHNpZ25hbDogQWJvcnRTaWduYWwudGltZW91dCh0aGlzLnRpbWVvdXRfbXMpLFxuICAgICAgICAgICAgLi4udGhpcy5mZXRjaE9wdGlvbnMsXG4gICAgICAgIH0pO1xuICAgICAgICBhd2FpdCByYWlzZUZvclN0YXR1cyhyZXNwb25zZSwgXCJpbmRleCBkYXRhc2V0XCIpO1xuICAgICAgICBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExldHMgeW91IHJ1biBhIHNpbWlsYXJpdHkgc2VhcmNoIHF1ZXJ5IG9uIGEgZGF0YXNldC5cbiAgICAgKlxuICAgICAqIFJlcXVpcmVzIHRoZSBkYXRhc2V0IHRvIGJlIGluZGV4ZWQuIFBsZWFzZSBzZWUgdGhlIGBpbmRleERhdGFzZXRgIG1ldGhvZCB0byBzZXQgdXAgaW5kZXhpbmcuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gaW5wdXRzICAgICAgVGhlIGlucHV0IG9uIHdoaWNoIHRvIHJ1biB0aGUgc2ltaWxhcml0eSBzZWFyY2guIE11c3QgaGF2ZSB0aGVcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgc2FtZSBzY2hlbWEgYXMgdGhlIGRhdGFzZXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZGF0YXNldElkICAgVGhlIGRhdGFzZXQgdG8gc2VhcmNoIGZvciBzaW1pbGFyIGV4YW1wbGVzLlxuICAgICAqXG4gICAgICogQHBhcmFtIGxpbWl0ICAgICAgIFRoZSBtYXhpbXVtIG51bWJlciBvZiBleGFtcGxlcyB0byByZXR1cm4uIFdpbGwgcmV0dXJuIHRoZSB0b3AgYGxpbWl0YCBtb3N0XG4gICAgICogICAgICAgICAgICAgICAgICAgIHNpbWlsYXIgZXhhbXBsZXMgaW4gb3JkZXIgb2YgbW9zdCBzaW1pbGFyIHRvIGxlYXN0IHNpbWlsYXIuIElmIG5vIHNpbWlsYXJcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgZXhhbXBsZXMgYXJlIGZvdW5kLCByYW5kb20gZXhhbXBsZXMgd2lsbCBiZSByZXR1cm5lZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBmaWx0ZXIgICAgICBBIGZpbHRlciBzdHJpbmcgdG8gYXBwbHkgdG8gdGhlIHNlYXJjaC4gT25seSBleGFtcGxlcyB3aWxsIGJlIHJldHVybmVkIHRoYXRcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgbWF0Y2ggdGhlIGZpbHRlciBzdHJpbmcuIFNvbWUgZXhhbXBsZXMgb2YgZmlsdGVyc1xuICAgICAqXG4gICAgICogICAgICAgICAgICAgICAgICAgIC0gZXEobWV0YWRhdGEubXlrZXksIFwidmFsdWVcIilcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgLSBhbmQobmVxKG1ldGFkYXRhLm15Lm5lc3RlZC5rZXksIFwidmFsdWVcIiksIG5lcShtZXRhZGF0YS5teWtleSwgXCJ2YWx1ZVwiKSlcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgLSBvcihlcShtZXRhZGF0YS5teWtleSwgXCJ2YWx1ZVwiKSwgZXEobWV0YWRhdGEubXlrZXksIFwib3RoZXJ2YWx1ZVwiKSlcbiAgICAgKlxuICAgICAqIEByZXR1cm5zICAgICAgICAgICBBIGxpc3Qgb2Ygc2ltaWxhciBleGFtcGxlcy5cbiAgICAgKlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBkYXRhc2V0X2lkID0gXCIxMjNlNDU2Ny1lODliLTEyZDMtYTQ1Ni00MjY2MTQxNzQwMDBcIlxuICAgICAqIGlucHV0cyA9IHtcInRleHRcIjogXCJIb3cgbWFueSBwZW9wbGUgbGl2ZSBpbiBCZXJsaW4/XCJ9XG4gICAgICogbGltaXQgPSA1XG4gICAgICogZXhhbXBsZXMgPSBhd2FpdCBjbGllbnQuc2ltaWxhckV4YW1wbGVzKGlucHV0cywgZGF0YXNldF9pZCwgbGltaXQpXG4gICAgICovXG4gICAgYXN5bmMgc2ltaWxhckV4YW1wbGVzKGlucHV0cywgZGF0YXNldElkLCBsaW1pdCwgeyBmaWx0ZXIsIH0gPSB7fSkge1xuICAgICAgICBjb25zdCBkYXRhID0ge1xuICAgICAgICAgICAgbGltaXQ6IGxpbWl0LFxuICAgICAgICAgICAgaW5wdXRzOiBpbnB1dHMsXG4gICAgICAgIH07XG4gICAgICAgIGlmIChmaWx0ZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZGF0YVtcImZpbHRlclwiXSA9IGZpbHRlcjtcbiAgICAgICAgfVxuICAgICAgICBhc3NlcnRVdWlkKGRhdGFzZXRJZCk7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5jYWxsZXIuY2FsbChfZ2V0RmV0Y2hJbXBsZW1lbnRhdGlvbigpLCBgJHt0aGlzLmFwaVVybH0vZGF0YXNldHMvJHtkYXRhc2V0SWR9L3NlYXJjaGAsIHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgICAgICBoZWFkZXJzOiB7IC4uLnRoaXMuaGVhZGVycywgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIgfSxcbiAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGRhdGEpLFxuICAgICAgICAgICAgc2lnbmFsOiBBYm9ydFNpZ25hbC50aW1lb3V0KHRoaXMudGltZW91dF9tcyksXG4gICAgICAgICAgICAuLi50aGlzLmZldGNoT3B0aW9ucyxcbiAgICAgICAgfSk7XG4gICAgICAgIGF3YWl0IHJhaXNlRm9yU3RhdHVzKHJlc3BvbnNlLCBcImZldGNoIHNpbWlsYXIgZXhhbXBsZXNcIik7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdFtcImV4YW1wbGVzXCJdO1xuICAgIH1cbiAgICBhc3luYyBjcmVhdGVFeGFtcGxlKGlucHV0c09yVXBkYXRlLCBvdXRwdXRzLCBvcHRpb25zKSB7XG4gICAgICAgIGlmIChpc0V4YW1wbGVDcmVhdGUoaW5wdXRzT3JVcGRhdGUpKSB7XG4gICAgICAgICAgICBpZiAob3V0cHV0cyAhPT0gdW5kZWZpbmVkIHx8IG9wdGlvbnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBwcm92aWRlIG91dHB1dHMgb3Igb3B0aW9ucyB3aGVuIHVzaW5nIEV4YW1wbGVDcmVhdGUgb2JqZWN0XCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCBkYXRhc2V0SWRfID0gb3V0cHV0cyA/IG9wdGlvbnM/LmRhdGFzZXRJZCA6IGlucHV0c09yVXBkYXRlLmRhdGFzZXRfaWQ7XG4gICAgICAgIGNvbnN0IGRhdGFzZXROYW1lXyA9IG91dHB1dHNcbiAgICAgICAgICAgID8gb3B0aW9ucz8uZGF0YXNldE5hbWVcbiAgICAgICAgICAgIDogaW5wdXRzT3JVcGRhdGUuZGF0YXNldF9uYW1lO1xuICAgICAgICBpZiAoZGF0YXNldElkXyA9PT0gdW5kZWZpbmVkICYmIGRhdGFzZXROYW1lXyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNdXN0IHByb3ZpZGUgZWl0aGVyIGRhdGFzZXROYW1lIG9yIGRhdGFzZXRJZFwiKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChkYXRhc2V0SWRfICE9PSB1bmRlZmluZWQgJiYgZGF0YXNldE5hbWVfICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk11c3QgcHJvdmlkZSBlaXRoZXIgZGF0YXNldE5hbWUgb3IgZGF0YXNldElkLCBub3QgYm90aFwiKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChkYXRhc2V0SWRfID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGRhdGFzZXQgPSBhd2FpdCB0aGlzLnJlYWREYXRhc2V0KHsgZGF0YXNldE5hbWU6IGRhdGFzZXROYW1lXyB9KTtcbiAgICAgICAgICAgIGRhdGFzZXRJZF8gPSBkYXRhc2V0LmlkO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNyZWF0ZWRBdF8gPSAob3V0cHV0cyA/IG9wdGlvbnM/LmNyZWF0ZWRBdCA6IGlucHV0c09yVXBkYXRlLmNyZWF0ZWRfYXQpIHx8IG5ldyBEYXRlKCk7XG4gICAgICAgIGxldCBkYXRhO1xuICAgICAgICBpZiAoIWlzRXhhbXBsZUNyZWF0ZShpbnB1dHNPclVwZGF0ZSkpIHtcbiAgICAgICAgICAgIGRhdGEgPSB7XG4gICAgICAgICAgICAgICAgaW5wdXRzOiBpbnB1dHNPclVwZGF0ZSxcbiAgICAgICAgICAgICAgICBvdXRwdXRzLFxuICAgICAgICAgICAgICAgIGNyZWF0ZWRfYXQ6IGNyZWF0ZWRBdF8/LnRvSVNPU3RyaW5nKCksXG4gICAgICAgICAgICAgICAgaWQ6IG9wdGlvbnM/LmV4YW1wbGVJZCxcbiAgICAgICAgICAgICAgICBtZXRhZGF0YTogb3B0aW9ucz8ubWV0YWRhdGEsXG4gICAgICAgICAgICAgICAgc3BsaXQ6IG9wdGlvbnM/LnNwbGl0LFxuICAgICAgICAgICAgICAgIHNvdXJjZV9ydW5faWQ6IG9wdGlvbnM/LnNvdXJjZVJ1bklkLFxuICAgICAgICAgICAgICAgIHVzZV9zb3VyY2VfcnVuX2lvOiBvcHRpb25zPy51c2VTb3VyY2VSdW5JTyxcbiAgICAgICAgICAgICAgICB1c2Vfc291cmNlX3J1bl9hdHRhY2htZW50czogb3B0aW9ucz8udXNlU291cmNlUnVuQXR0YWNobWVudHMsXG4gICAgICAgICAgICAgICAgYXR0YWNobWVudHM6IG9wdGlvbnM/LmF0dGFjaG1lbnRzLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGRhdGEgPSBpbnB1dHNPclVwZGF0ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuX3VwbG9hZEV4YW1wbGVzTXVsdGlwYXJ0KGRhdGFzZXRJZF8sIFtkYXRhXSk7XG4gICAgICAgIGNvbnN0IGV4YW1wbGUgPSBhd2FpdCB0aGlzLnJlYWRFeGFtcGxlKHJlc3BvbnNlLmV4YW1wbGVfaWRzPy5bMF0gPz8gdXVpZC52NCgpKTtcbiAgICAgICAgcmV0dXJuIGV4YW1wbGU7XG4gICAgfVxuICAgIGFzeW5jIGNyZWF0ZUV4YW1wbGVzKHByb3BzT3JVcGxvYWRzKSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHByb3BzT3JVcGxvYWRzKSkge1xuICAgICAgICAgICAgaWYgKHByb3BzT3JVcGxvYWRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHVwbG9hZHMgPSBwcm9wc09yVXBsb2FkcztcbiAgICAgICAgICAgIGxldCBkYXRhc2V0SWRfID0gdXBsb2Fkc1swXS5kYXRhc2V0X2lkO1xuICAgICAgICAgICAgY29uc3QgZGF0YXNldE5hbWVfID0gdXBsb2Fkc1swXS5kYXRhc2V0X25hbWU7XG4gICAgICAgICAgICBpZiAoZGF0YXNldElkXyA9PT0gdW5kZWZpbmVkICYmIGRhdGFzZXROYW1lXyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTXVzdCBwcm92aWRlIGVpdGhlciBkYXRhc2V0TmFtZSBvciBkYXRhc2V0SWRcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChkYXRhc2V0SWRfICE9PSB1bmRlZmluZWQgJiYgZGF0YXNldE5hbWVfICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNdXN0IHByb3ZpZGUgZWl0aGVyIGRhdGFzZXROYW1lIG9yIGRhdGFzZXRJZCwgbm90IGJvdGhcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChkYXRhc2V0SWRfID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBkYXRhc2V0ID0gYXdhaXQgdGhpcy5yZWFkRGF0YXNldCh7IGRhdGFzZXROYW1lOiBkYXRhc2V0TmFtZV8gfSk7XG4gICAgICAgICAgICAgICAgZGF0YXNldElkXyA9IGRhdGFzZXQuaWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuX3VwbG9hZEV4YW1wbGVzTXVsdGlwYXJ0KGRhdGFzZXRJZF8sIHVwbG9hZHMpO1xuICAgICAgICAgICAgY29uc3QgZXhhbXBsZXMgPSBhd2FpdCBQcm9taXNlLmFsbChyZXNwb25zZS5leGFtcGxlX2lkcy5tYXAoKGlkKSA9PiB0aGlzLnJlYWRFeGFtcGxlKGlkKSkpO1xuICAgICAgICAgICAgcmV0dXJuIGV4YW1wbGVzO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgaW5wdXRzLCBvdXRwdXRzLCBtZXRhZGF0YSwgc3BsaXRzLCBzb3VyY2VSdW5JZHMsIHVzZVNvdXJjZVJ1bklPcywgdXNlU291cmNlUnVuQXR0YWNobWVudHMsIGF0dGFjaG1lbnRzLCBleGFtcGxlSWRzLCBkYXRhc2V0SWQsIGRhdGFzZXROYW1lLCB9ID0gcHJvcHNPclVwbG9hZHM7XG4gICAgICAgIGlmIChpbnB1dHMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTXVzdCBwcm92aWRlIGlucHV0cyB3aGVuIHVzaW5nIGxlZ2FjeSBwYXJhbWV0ZXJzXCIpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBkYXRhc2V0SWRfID0gZGF0YXNldElkO1xuICAgICAgICBjb25zdCBkYXRhc2V0TmFtZV8gPSBkYXRhc2V0TmFtZTtcbiAgICAgICAgaWYgKGRhdGFzZXRJZF8gPT09IHVuZGVmaW5lZCAmJiBkYXRhc2V0TmFtZV8gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTXVzdCBwcm92aWRlIGVpdGhlciBkYXRhc2V0TmFtZSBvciBkYXRhc2V0SWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZGF0YXNldElkXyAhPT0gdW5kZWZpbmVkICYmIGRhdGFzZXROYW1lXyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNdXN0IHByb3ZpZGUgZWl0aGVyIGRhdGFzZXROYW1lIG9yIGRhdGFzZXRJZCwgbm90IGJvdGhcIik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZGF0YXNldElkXyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25zdCBkYXRhc2V0ID0gYXdhaXQgdGhpcy5yZWFkRGF0YXNldCh7IGRhdGFzZXROYW1lOiBkYXRhc2V0TmFtZV8gfSk7XG4gICAgICAgICAgICBkYXRhc2V0SWRfID0gZGF0YXNldC5pZDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBmb3JtYXR0ZWRFeGFtcGxlcyA9IGlucHV0cy5tYXAoKGlucHV0LCBpZHgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZGF0YXNldF9pZDogZGF0YXNldElkXyxcbiAgICAgICAgICAgICAgICBpbnB1dHM6IGlucHV0LFxuICAgICAgICAgICAgICAgIG91dHB1dHM6IG91dHB1dHM/LltpZHhdLFxuICAgICAgICAgICAgICAgIG1ldGFkYXRhOiBtZXRhZGF0YT8uW2lkeF0sXG4gICAgICAgICAgICAgICAgc3BsaXQ6IHNwbGl0cz8uW2lkeF0sXG4gICAgICAgICAgICAgICAgaWQ6IGV4YW1wbGVJZHM/LltpZHhdLFxuICAgICAgICAgICAgICAgIGF0dGFjaG1lbnRzOiBhdHRhY2htZW50cz8uW2lkeF0sXG4gICAgICAgICAgICAgICAgc291cmNlX3J1bl9pZDogc291cmNlUnVuSWRzPy5baWR4XSxcbiAgICAgICAgICAgICAgICB1c2Vfc291cmNlX3J1bl9pbzogdXNlU291cmNlUnVuSU9zPy5baWR4XSxcbiAgICAgICAgICAgICAgICB1c2Vfc291cmNlX3J1bl9hdHRhY2htZW50czogdXNlU291cmNlUnVuQXR0YWNobWVudHM/LltpZHhdLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5fdXBsb2FkRXhhbXBsZXNNdWx0aXBhcnQoZGF0YXNldElkXywgZm9ybWF0dGVkRXhhbXBsZXMpO1xuICAgICAgICBjb25zdCBleGFtcGxlcyA9IGF3YWl0IFByb21pc2UuYWxsKHJlc3BvbnNlLmV4YW1wbGVfaWRzLm1hcCgoaWQpID0+IHRoaXMucmVhZEV4YW1wbGUoaWQpKSk7XG4gICAgICAgIHJldHVybiBleGFtcGxlcztcbiAgICB9XG4gICAgYXN5bmMgY3JlYXRlTExNRXhhbXBsZShpbnB1dCwgZ2VuZXJhdGlvbiwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVFeGFtcGxlKHsgaW5wdXQgfSwgeyBvdXRwdXQ6IGdlbmVyYXRpb24gfSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGFzeW5jIGNyZWF0ZUNoYXRFeGFtcGxlKGlucHV0LCBnZW5lcmF0aW9ucywgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBmaW5hbElucHV0ID0gaW5wdXQubWFwKChtZXNzYWdlKSA9PiB7XG4gICAgICAgICAgICBpZiAoaXNMYW5nQ2hhaW5NZXNzYWdlKG1lc3NhZ2UpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbnZlcnRMYW5nQ2hhaW5NZXNzYWdlVG9FeGFtcGxlKG1lc3NhZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBmaW5hbE91dHB1dCA9IGlzTGFuZ0NoYWluTWVzc2FnZShnZW5lcmF0aW9ucylcbiAgICAgICAgICAgID8gY29udmVydExhbmdDaGFpbk1lc3NhZ2VUb0V4YW1wbGUoZ2VuZXJhdGlvbnMpXG4gICAgICAgICAgICA6IGdlbmVyYXRpb25zO1xuICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVFeGFtcGxlKHsgaW5wdXQ6IGZpbmFsSW5wdXQgfSwgeyBvdXRwdXQ6IGZpbmFsT3V0cHV0IH0sIG9wdGlvbnMpO1xuICAgIH1cbiAgICBhc3luYyByZWFkRXhhbXBsZShleGFtcGxlSWQpIHtcbiAgICAgICAgYXNzZXJ0VXVpZChleGFtcGxlSWQpO1xuICAgICAgICBjb25zdCBwYXRoID0gYC9leGFtcGxlcy8ke2V4YW1wbGVJZH1gO1xuICAgICAgICBjb25zdCByYXdFeGFtcGxlID0gYXdhaXQgdGhpcy5fZ2V0KHBhdGgpO1xuICAgICAgICBjb25zdCB7IGF0dGFjaG1lbnRfdXJscywgLi4ucmVzdCB9ID0gcmF3RXhhbXBsZTtcbiAgICAgICAgY29uc3QgZXhhbXBsZSA9IHJlc3Q7XG4gICAgICAgIGlmIChhdHRhY2htZW50X3VybHMpIHtcbiAgICAgICAgICAgIGV4YW1wbGUuYXR0YWNobWVudHMgPSBPYmplY3QuZW50cmllcyhhdHRhY2htZW50X3VybHMpLnJlZHVjZSgoYWNjLCBba2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgICAgICAgICAgICBhY2Nba2V5LnNsaWNlKFwiYXR0YWNobWVudC5cIi5sZW5ndGgpXSA9IHtcbiAgICAgICAgICAgICAgICAgICAgcHJlc2lnbmVkX3VybDogdmFsdWUucHJlc2lnbmVkX3VybCxcbiAgICAgICAgICAgICAgICAgICAgbWltZV90eXBlOiB2YWx1ZS5taW1lX3R5cGUsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICAgICAgfSwge30pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBleGFtcGxlO1xuICAgIH1cbiAgICBhc3luYyAqbGlzdEV4YW1wbGVzKHsgZGF0YXNldElkLCBkYXRhc2V0TmFtZSwgZXhhbXBsZUlkcywgYXNPZiwgc3BsaXRzLCBpbmxpbmVTM1VybHMsIG1ldGFkYXRhLCBsaW1pdCwgb2Zmc2V0LCBmaWx0ZXIsIGluY2x1ZGVBdHRhY2htZW50cywgfSA9IHt9KSB7XG4gICAgICAgIGxldCBkYXRhc2V0SWRfO1xuICAgICAgICBpZiAoZGF0YXNldElkICE9PSB1bmRlZmluZWQgJiYgZGF0YXNldE5hbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTXVzdCBwcm92aWRlIGVpdGhlciBkYXRhc2V0TmFtZSBvciBkYXRhc2V0SWQsIG5vdCBib3RoXCIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGRhdGFzZXRJZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBkYXRhc2V0SWRfID0gZGF0YXNldElkO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGRhdGFzZXROYW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGRhdGFzZXQgPSBhd2FpdCB0aGlzLnJlYWREYXRhc2V0KHsgZGF0YXNldE5hbWUgfSk7XG4gICAgICAgICAgICBkYXRhc2V0SWRfID0gZGF0YXNldC5pZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk11c3QgcHJvdmlkZSBhIGRhdGFzZXROYW1lIG9yIGRhdGFzZXRJZFwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKHsgZGF0YXNldDogZGF0YXNldElkXyB9KTtcbiAgICAgICAgY29uc3QgZGF0YXNldF92ZXJzaW9uID0gYXNPZlxuICAgICAgICAgICAgPyB0eXBlb2YgYXNPZiA9PT0gXCJzdHJpbmdcIlxuICAgICAgICAgICAgICAgID8gYXNPZlxuICAgICAgICAgICAgICAgIDogYXNPZj8udG9JU09TdHJpbmcoKVxuICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICAgIGlmIChkYXRhc2V0X3ZlcnNpb24pIHtcbiAgICAgICAgICAgIHBhcmFtcy5hcHBlbmQoXCJhc19vZlwiLCBkYXRhc2V0X3ZlcnNpb24pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGlubGluZVMzVXJsc18gPSBpbmxpbmVTM1VybHMgPz8gdHJ1ZTtcbiAgICAgICAgcGFyYW1zLmFwcGVuZChcImlubGluZV9zM191cmxzXCIsIGlubGluZVMzVXJsc18udG9TdHJpbmcoKSk7XG4gICAgICAgIGlmIChleGFtcGxlSWRzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgaWRfIG9mIGV4YW1wbGVJZHMpIHtcbiAgICAgICAgICAgICAgICBwYXJhbXMuYXBwZW5kKFwiaWRcIiwgaWRfKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoc3BsaXRzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3Qgc3BsaXQgb2Ygc3BsaXRzKSB7XG4gICAgICAgICAgICAgICAgcGFyYW1zLmFwcGVuZChcInNwbGl0c1wiLCBzcGxpdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1ldGFkYXRhICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IHNlcmlhbGl6ZWRNZXRhZGF0YSA9IEpTT04uc3RyaW5naWZ5KG1ldGFkYXRhKTtcbiAgICAgICAgICAgIHBhcmFtcy5hcHBlbmQoXCJtZXRhZGF0YVwiLCBzZXJpYWxpemVkTWV0YWRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsaW1pdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBwYXJhbXMuYXBwZW5kKFwibGltaXRcIiwgbGltaXQudG9TdHJpbmcoKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9mZnNldCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBwYXJhbXMuYXBwZW5kKFwib2Zmc2V0XCIsIG9mZnNldC50b1N0cmluZygpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZmlsdGVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHBhcmFtcy5hcHBlbmQoXCJmaWx0ZXJcIiwgZmlsdGVyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW5jbHVkZUF0dGFjaG1lbnRzID09PSB0cnVlKSB7XG4gICAgICAgICAgICBbXCJhdHRhY2htZW50X3VybHNcIiwgXCJvdXRwdXRzXCIsIFwibWV0YWRhdGFcIl0uZm9yRWFjaCgoZmllbGQpID0+IHBhcmFtcy5hcHBlbmQoXCJzZWxlY3RcIiwgZmllbGQpKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgaSA9IDA7XG4gICAgICAgIGZvciBhd2FpdCAoY29uc3QgcmF3RXhhbXBsZXMgb2YgdGhpcy5fZ2V0UGFnaW5hdGVkKFwiL2V4YW1wbGVzXCIsIHBhcmFtcykpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgcmF3RXhhbXBsZSBvZiByYXdFeGFtcGxlcykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgYXR0YWNobWVudF91cmxzLCAuLi5yZXN0IH0gPSByYXdFeGFtcGxlO1xuICAgICAgICAgICAgICAgIGNvbnN0IGV4YW1wbGUgPSByZXN0O1xuICAgICAgICAgICAgICAgIGlmIChhdHRhY2htZW50X3VybHMpIHtcbiAgICAgICAgICAgICAgICAgICAgZXhhbXBsZS5hdHRhY2htZW50cyA9IE9iamVjdC5lbnRyaWVzKGF0dGFjaG1lbnRfdXJscykucmVkdWNlKChhY2MsIFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWNjW2tleS5zbGljZShcImF0dGFjaG1lbnQuXCIubGVuZ3RoKV0gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJlc2lnbmVkX3VybDogdmFsdWUucHJlc2lnbmVkX3VybCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtaW1lX3R5cGU6IHZhbHVlLm1pbWVfdHlwZSB8fCB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgICAgICAgICAgICAgICAgfSwge30pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB5aWVsZCBleGFtcGxlO1xuICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChsaW1pdCAhPT0gdW5kZWZpbmVkICYmIGkgPj0gbGltaXQpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBkZWxldGVFeGFtcGxlKGV4YW1wbGVJZCkge1xuICAgICAgICBhc3NlcnRVdWlkKGV4YW1wbGVJZCk7XG4gICAgICAgIGNvbnN0IHBhdGggPSBgL2V4YW1wbGVzLyR7ZXhhbXBsZUlkfWA7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5jYWxsZXIuY2FsbChfZ2V0RmV0Y2hJbXBsZW1lbnRhdGlvbigpLCB0aGlzLmFwaVVybCArIHBhdGgsIHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJERUxFVEVcIixcbiAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgIHNpZ25hbDogQWJvcnRTaWduYWwudGltZW91dCh0aGlzLnRpbWVvdXRfbXMpLFxuICAgICAgICAgICAgLi4udGhpcy5mZXRjaE9wdGlvbnMsXG4gICAgICAgIH0pO1xuICAgICAgICBhd2FpdCByYWlzZUZvclN0YXR1cyhyZXNwb25zZSwgYGRlbGV0ZSAke3BhdGh9YCk7XG4gICAgICAgIGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICB9XG4gICAgYXN5bmMgdXBkYXRlRXhhbXBsZShleGFtcGxlSWRPclVwZGF0ZSwgdXBkYXRlKSB7XG4gICAgICAgIGxldCBleGFtcGxlSWQ7XG4gICAgICAgIGlmICh1cGRhdGUpIHtcbiAgICAgICAgICAgIGV4YW1wbGVJZCA9IGV4YW1wbGVJZE9yVXBkYXRlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZXhhbXBsZUlkID0gZXhhbXBsZUlkT3JVcGRhdGUuaWQ7XG4gICAgICAgIH1cbiAgICAgICAgYXNzZXJ0VXVpZChleGFtcGxlSWQpO1xuICAgICAgICBsZXQgdXBkYXRlVG9Vc2U7XG4gICAgICAgIGlmICh1cGRhdGUpIHtcbiAgICAgICAgICAgIHVwZGF0ZVRvVXNlID0geyBpZDogZXhhbXBsZUlkLCAuLi51cGRhdGUgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHVwZGF0ZVRvVXNlID0gZXhhbXBsZUlkT3JVcGRhdGU7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGRhdGFzZXRJZDtcbiAgICAgICAgaWYgKHVwZGF0ZVRvVXNlLmRhdGFzZXRfaWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZGF0YXNldElkID0gdXBkYXRlVG9Vc2UuZGF0YXNldF9pZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGV4YW1wbGUgPSBhd2FpdCB0aGlzLnJlYWRFeGFtcGxlKGV4YW1wbGVJZCk7XG4gICAgICAgICAgICBkYXRhc2V0SWQgPSBleGFtcGxlLmRhdGFzZXRfaWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3VwZGF0ZUV4YW1wbGVzTXVsdGlwYXJ0KGRhdGFzZXRJZCwgW3VwZGF0ZVRvVXNlXSk7XG4gICAgfVxuICAgIGFzeW5jIHVwZGF0ZUV4YW1wbGVzKHVwZGF0ZSkge1xuICAgICAgICAvLyBXZSB3aWxsIG5haXZlbHkgZ2V0IGRhdGFzZXQgaWQgZnJvbSBmaXJzdCBleGFtcGxlIGFuZCBhc3N1bWUgaXQgd29ya3MgZm9yIGFsbFxuICAgICAgICBsZXQgZGF0YXNldElkO1xuICAgICAgICBpZiAodXBkYXRlWzBdLmRhdGFzZXRfaWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29uc3QgZXhhbXBsZSA9IGF3YWl0IHRoaXMucmVhZEV4YW1wbGUodXBkYXRlWzBdLmlkKTtcbiAgICAgICAgICAgIGRhdGFzZXRJZCA9IGV4YW1wbGUuZGF0YXNldF9pZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGRhdGFzZXRJZCA9IHVwZGF0ZVswXS5kYXRhc2V0X2lkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl91cGRhdGVFeGFtcGxlc011bHRpcGFydChkYXRhc2V0SWQsIHVwZGF0ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBkYXRhc2V0IHZlcnNpb24gYnkgY2xvc2VzdCBkYXRlIG9yIGV4YWN0IHRhZy5cbiAgICAgKlxuICAgICAqIFVzZSB0aGlzIHRvIHJlc29sdmUgdGhlIG5lYXJlc3QgdmVyc2lvbiB0byBhIGdpdmVuIHRpbWVzdGFtcCBvciBmb3IgYSBnaXZlbiB0YWcuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBUaGUgb3B0aW9ucyBmb3IgZ2V0dGluZyB0aGUgZGF0YXNldCB2ZXJzaW9uXG4gICAgICogQHBhcmFtIG9wdGlvbnMuZGF0YXNldElkIFRoZSBJRCBvZiB0aGUgZGF0YXNldFxuICAgICAqIEBwYXJhbSBvcHRpb25zLmRhdGFzZXROYW1lIFRoZSBuYW1lIG9mIHRoZSBkYXRhc2V0XG4gICAgICogQHBhcmFtIG9wdGlvbnMuYXNPZiBUaGUgdGltZXN0YW1wIG9mIHRoZSBkYXRhc2V0IHRvIHJldHJpZXZlXG4gICAgICogQHBhcmFtIG9wdGlvbnMudGFnIFRoZSB0YWcgb2YgdGhlIGRhdGFzZXQgdG8gcmV0cmlldmVcbiAgICAgKiBAcmV0dXJucyBUaGUgZGF0YXNldCB2ZXJzaW9uXG4gICAgICovXG4gICAgYXN5bmMgcmVhZERhdGFzZXRWZXJzaW9uKHsgZGF0YXNldElkLCBkYXRhc2V0TmFtZSwgYXNPZiwgdGFnLCB9KSB7XG4gICAgICAgIGxldCByZXNvbHZlZERhdGFzZXRJZDtcbiAgICAgICAgaWYgKCFkYXRhc2V0SWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGRhdGFzZXQgPSBhd2FpdCB0aGlzLnJlYWREYXRhc2V0KHsgZGF0YXNldE5hbWUgfSk7XG4gICAgICAgICAgICByZXNvbHZlZERhdGFzZXRJZCA9IGRhdGFzZXQuaWQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXNvbHZlZERhdGFzZXRJZCA9IGRhdGFzZXRJZDtcbiAgICAgICAgfVxuICAgICAgICBhc3NlcnRVdWlkKHJlc29sdmVkRGF0YXNldElkKTtcbiAgICAgICAgaWYgKChhc09mICYmIHRhZykgfHwgKCFhc09mICYmICF0YWcpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFeGFjdGx5IG9uZSBvZiBhc09mIGFuZCB0YWcgbXVzdCBiZSBzcGVjaWZpZWQuXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoKTtcbiAgICAgICAgaWYgKGFzT2YgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcGFyYW1zLmFwcGVuZChcImFzX29mXCIsIHR5cGVvZiBhc09mID09PSBcInN0cmluZ1wiID8gYXNPZiA6IGFzT2YudG9JU09TdHJpbmcoKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRhZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBwYXJhbXMuYXBwZW5kKFwidGFnXCIsIHRhZyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmNhbGxlci5jYWxsKF9nZXRGZXRjaEltcGxlbWVudGF0aW9uKCksIGAke3RoaXMuYXBpVXJsfS9kYXRhc2V0cy8ke3Jlc29sdmVkRGF0YXNldElkfS92ZXJzaW9uPyR7cGFyYW1zLnRvU3RyaW5nKCl9YCwge1xuICAgICAgICAgICAgbWV0aG9kOiBcIkdFVFwiLFxuICAgICAgICAgICAgaGVhZGVyczogeyAuLi50aGlzLmhlYWRlcnMgfSxcbiAgICAgICAgICAgIHNpZ25hbDogQWJvcnRTaWduYWwudGltZW91dCh0aGlzLnRpbWVvdXRfbXMpLFxuICAgICAgICAgICAgLi4udGhpcy5mZXRjaE9wdGlvbnMsXG4gICAgICAgIH0pO1xuICAgICAgICBhd2FpdCByYWlzZUZvclN0YXR1cyhyZXNwb25zZSwgXCJyZWFkIGRhdGFzZXQgdmVyc2lvblwiKTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICB9XG4gICAgYXN5bmMgbGlzdERhdGFzZXRTcGxpdHMoeyBkYXRhc2V0SWQsIGRhdGFzZXROYW1lLCBhc09mLCB9KSB7XG4gICAgICAgIGxldCBkYXRhc2V0SWRfO1xuICAgICAgICBpZiAoZGF0YXNldElkID09PSB1bmRlZmluZWQgJiYgZGF0YXNldE5hbWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTXVzdCBwcm92aWRlIGRhdGFzZXQgbmFtZSBvciBJRFwiKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChkYXRhc2V0SWQgIT09IHVuZGVmaW5lZCAmJiBkYXRhc2V0TmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNdXN0IHByb3ZpZGUgZWl0aGVyIGRhdGFzZXROYW1lIG9yIGRhdGFzZXRJZCwgbm90IGJvdGhcIik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZGF0YXNldElkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGRhdGFzZXQgPSBhd2FpdCB0aGlzLnJlYWREYXRhc2V0KHsgZGF0YXNldE5hbWUgfSk7XG4gICAgICAgICAgICBkYXRhc2V0SWRfID0gZGF0YXNldC5pZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGRhdGFzZXRJZF8gPSBkYXRhc2V0SWQ7XG4gICAgICAgIH1cbiAgICAgICAgYXNzZXJ0VXVpZChkYXRhc2V0SWRfKTtcbiAgICAgICAgY29uc3QgcGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcygpO1xuICAgICAgICBjb25zdCBkYXRhc2V0X3ZlcnNpb24gPSBhc09mXG4gICAgICAgICAgICA/IHR5cGVvZiBhc09mID09PSBcInN0cmluZ1wiXG4gICAgICAgICAgICAgICAgPyBhc09mXG4gICAgICAgICAgICAgICAgOiBhc09mPy50b0lTT1N0cmluZygpXG4gICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKGRhdGFzZXRfdmVyc2lvbikge1xuICAgICAgICAgICAgcGFyYW1zLmFwcGVuZChcImFzX29mXCIsIGRhdGFzZXRfdmVyc2lvbik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLl9nZXQoYC9kYXRhc2V0cy8ke2RhdGFzZXRJZF99L3NwbGl0c2AsIHBhcmFtcyk7XG4gICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICB9XG4gICAgYXN5bmMgdXBkYXRlRGF0YXNldFNwbGl0cyh7IGRhdGFzZXRJZCwgZGF0YXNldE5hbWUsIHNwbGl0TmFtZSwgZXhhbXBsZUlkcywgcmVtb3ZlID0gZmFsc2UsIH0pIHtcbiAgICAgICAgbGV0IGRhdGFzZXRJZF87XG4gICAgICAgIGlmIChkYXRhc2V0SWQgPT09IHVuZGVmaW5lZCAmJiBkYXRhc2V0TmFtZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNdXN0IHByb3ZpZGUgZGF0YXNldCBuYW1lIG9yIElEXCIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGRhdGFzZXRJZCAhPT0gdW5kZWZpbmVkICYmIGRhdGFzZXROYW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk11c3QgcHJvdmlkZSBlaXRoZXIgZGF0YXNldE5hbWUgb3IgZGF0YXNldElkLCBub3QgYm90aFwiKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChkYXRhc2V0SWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29uc3QgZGF0YXNldCA9IGF3YWl0IHRoaXMucmVhZERhdGFzZXQoeyBkYXRhc2V0TmFtZSB9KTtcbiAgICAgICAgICAgIGRhdGFzZXRJZF8gPSBkYXRhc2V0LmlkO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZGF0YXNldElkXyA9IGRhdGFzZXRJZDtcbiAgICAgICAgfVxuICAgICAgICBhc3NlcnRVdWlkKGRhdGFzZXRJZF8pO1xuICAgICAgICBjb25zdCBkYXRhID0ge1xuICAgICAgICAgICAgc3BsaXRfbmFtZTogc3BsaXROYW1lLFxuICAgICAgICAgICAgZXhhbXBsZXM6IGV4YW1wbGVJZHMubWFwKChpZCkgPT4ge1xuICAgICAgICAgICAgICAgIGFzc2VydFV1aWQoaWQpO1xuICAgICAgICAgICAgICAgIHJldHVybiBpZDtcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgcmVtb3ZlLFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuY2FsbGVyLmNhbGwoX2dldEZldGNoSW1wbGVtZW50YXRpb24oKSwgYCR7dGhpcy5hcGlVcmx9L2RhdGFzZXRzLyR7ZGF0YXNldElkX30vc3BsaXRzYCwge1xuICAgICAgICAgICAgbWV0aG9kOiBcIlBVVFwiLFxuICAgICAgICAgICAgaGVhZGVyczogeyAuLi50aGlzLmhlYWRlcnMsIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiIH0sXG4gICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShkYXRhKSxcbiAgICAgICAgICAgIHNpZ25hbDogQWJvcnRTaWduYWwudGltZW91dCh0aGlzLnRpbWVvdXRfbXMpLFxuICAgICAgICAgICAgLi4udGhpcy5mZXRjaE9wdGlvbnMsXG4gICAgICAgIH0pO1xuICAgICAgICBhd2FpdCByYWlzZUZvclN0YXR1cyhyZXNwb25zZSwgXCJ1cGRhdGUgZGF0YXNldCBzcGxpdHNcIiwgdHJ1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBkZXByZWNhdGVkIFRoaXMgbWV0aG9kIGlzIGRlcHJlY2F0ZWQgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiBmdXR1cmUgTGFuZ1NtaXRoIHZlcnNpb25zLCB1c2UgYGV2YWx1YXRlYCBmcm9tIGBsYW5nc21pdGgvZXZhbHVhdGlvbmAgaW5zdGVhZC5cbiAgICAgKi9cbiAgICBhc3luYyBldmFsdWF0ZVJ1bihydW4sIGV2YWx1YXRvciwgeyBzb3VyY2VJbmZvLCBsb2FkQ2hpbGRSdW5zLCByZWZlcmVuY2VFeGFtcGxlLCB9ID0geyBsb2FkQ2hpbGRSdW5zOiBmYWxzZSB9KSB7XG4gICAgICAgIHdhcm5PbmNlKFwiVGhpcyBtZXRob2QgaXMgZGVwcmVjYXRlZCBhbmQgd2lsbCBiZSByZW1vdmVkIGluIGZ1dHVyZSBMYW5nU21pdGggdmVyc2lvbnMsIHVzZSBgZXZhbHVhdGVgIGZyb20gYGxhbmdzbWl0aC9ldmFsdWF0aW9uYCBpbnN0ZWFkLlwiKTtcbiAgICAgICAgbGV0IHJ1bl87XG4gICAgICAgIGlmICh0eXBlb2YgcnVuID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBydW5fID0gYXdhaXQgdGhpcy5yZWFkUnVuKHJ1biwgeyBsb2FkQ2hpbGRSdW5zIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBydW4gPT09IFwib2JqZWN0XCIgJiYgXCJpZFwiIGluIHJ1bikge1xuICAgICAgICAgICAgcnVuXyA9IHJ1bjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBydW4gdHlwZTogJHt0eXBlb2YgcnVufWApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChydW5fLnJlZmVyZW5jZV9leGFtcGxlX2lkICE9PSBudWxsICYmXG4gICAgICAgICAgICBydW5fLnJlZmVyZW5jZV9leGFtcGxlX2lkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJlZmVyZW5jZUV4YW1wbGUgPSBhd2FpdCB0aGlzLnJlYWRFeGFtcGxlKHJ1bl8ucmVmZXJlbmNlX2V4YW1wbGVfaWQpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGZlZWRiYWNrUmVzdWx0ID0gYXdhaXQgZXZhbHVhdG9yLmV2YWx1YXRlUnVuKHJ1bl8sIHJlZmVyZW5jZUV4YW1wbGUpO1xuICAgICAgICBjb25zdCBbXywgZmVlZGJhY2tzXSA9IGF3YWl0IHRoaXMuX2xvZ0V2YWx1YXRpb25GZWVkYmFjayhmZWVkYmFja1Jlc3VsdCwgcnVuXywgc291cmNlSW5mbyk7XG4gICAgICAgIHJldHVybiBmZWVkYmFja3NbMF07XG4gICAgfVxuICAgIGFzeW5jIGNyZWF0ZUZlZWRiYWNrKHJ1bklkLCBrZXksIHsgc2NvcmUsIHZhbHVlLCBjb3JyZWN0aW9uLCBjb21tZW50LCBzb3VyY2VJbmZvLCBmZWVkYmFja1NvdXJjZVR5cGUgPSBcImFwaVwiLCBzb3VyY2VSdW5JZCwgZmVlZGJhY2tJZCwgZmVlZGJhY2tDb25maWcsIHByb2plY3RJZCwgY29tcGFyYXRpdmVFeHBlcmltZW50SWQsIH0pIHtcbiAgICAgICAgaWYgKCFydW5JZCAmJiAhcHJvamVjdElkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJPbmUgb2YgcnVuSWQgb3IgcHJvamVjdElkIG11c3QgYmUgcHJvdmlkZWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJ1bklkICYmIHByb2plY3RJZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiT25seSBvbmUgb2YgcnVuSWQgb3IgcHJvamVjdElkIGNhbiBiZSBwcm92aWRlZFwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBmZWVkYmFja19zb3VyY2UgPSB7XG4gICAgICAgICAgICB0eXBlOiBmZWVkYmFja1NvdXJjZVR5cGUgPz8gXCJhcGlcIixcbiAgICAgICAgICAgIG1ldGFkYXRhOiBzb3VyY2VJbmZvID8/IHt9LFxuICAgICAgICB9O1xuICAgICAgICBpZiAoc291cmNlUnVuSWQgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgZmVlZGJhY2tfc291cmNlPy5tZXRhZGF0YSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAhZmVlZGJhY2tfc291cmNlLm1ldGFkYXRhW1wiX19ydW5cIl0pIHtcbiAgICAgICAgICAgIGZlZWRiYWNrX3NvdXJjZS5tZXRhZGF0YVtcIl9fcnVuXCJdID0geyBydW5faWQ6IHNvdXJjZVJ1bklkIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZlZWRiYWNrX3NvdXJjZT8ubWV0YWRhdGEgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgZmVlZGJhY2tfc291cmNlLm1ldGFkYXRhW1wiX19ydW5cIl0/LnJ1bl9pZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBhc3NlcnRVdWlkKGZlZWRiYWNrX3NvdXJjZS5tZXRhZGF0YVtcIl9fcnVuXCJdLnJ1bl9pZCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZmVlZGJhY2sgPSB7XG4gICAgICAgICAgICBpZDogZmVlZGJhY2tJZCA/PyB1dWlkLnY0KCksXG4gICAgICAgICAgICBydW5faWQ6IHJ1bklkLFxuICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgc2NvcmU6IF9mb3JtYXRGZWVkYmFja1Njb3JlKHNjb3JlKSxcbiAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgY29ycmVjdGlvbixcbiAgICAgICAgICAgIGNvbW1lbnQsXG4gICAgICAgICAgICBmZWVkYmFja19zb3VyY2U6IGZlZWRiYWNrX3NvdXJjZSxcbiAgICAgICAgICAgIGNvbXBhcmF0aXZlX2V4cGVyaW1lbnRfaWQ6IGNvbXBhcmF0aXZlRXhwZXJpbWVudElkLFxuICAgICAgICAgICAgZmVlZGJhY2tDb25maWcsXG4gICAgICAgICAgICBzZXNzaW9uX2lkOiBwcm9qZWN0SWQsXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHVybCA9IGAke3RoaXMuYXBpVXJsfS9mZWVkYmFja2A7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5jYWxsZXIuY2FsbChfZ2V0RmV0Y2hJbXBsZW1lbnRhdGlvbigpLCB1cmwsIHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgICAgICBoZWFkZXJzOiB7IC4uLnRoaXMuaGVhZGVycywgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIgfSxcbiAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGZlZWRiYWNrKSxcbiAgICAgICAgICAgIHNpZ25hbDogQWJvcnRTaWduYWwudGltZW91dCh0aGlzLnRpbWVvdXRfbXMpLFxuICAgICAgICAgICAgLi4udGhpcy5mZXRjaE9wdGlvbnMsXG4gICAgICAgIH0pO1xuICAgICAgICBhd2FpdCByYWlzZUZvclN0YXR1cyhyZXNwb25zZSwgXCJjcmVhdGUgZmVlZGJhY2tcIiwgdHJ1ZSk7XG4gICAgICAgIHJldHVybiBmZWVkYmFjaztcbiAgICB9XG4gICAgYXN5bmMgdXBkYXRlRmVlZGJhY2soZmVlZGJhY2tJZCwgeyBzY29yZSwgdmFsdWUsIGNvcnJlY3Rpb24sIGNvbW1lbnQsIH0pIHtcbiAgICAgICAgY29uc3QgZmVlZGJhY2tVcGRhdGUgPSB7fTtcbiAgICAgICAgaWYgKHNjb3JlICE9PSB1bmRlZmluZWQgJiYgc2NvcmUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGZlZWRiYWNrVXBkYXRlW1wic2NvcmVcIl0gPSBfZm9ybWF0RmVlZGJhY2tTY29yZShzY29yZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGZlZWRiYWNrVXBkYXRlW1widmFsdWVcIl0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29ycmVjdGlvbiAhPT0gdW5kZWZpbmVkICYmIGNvcnJlY3Rpb24gIT09IG51bGwpIHtcbiAgICAgICAgICAgIGZlZWRiYWNrVXBkYXRlW1wiY29ycmVjdGlvblwiXSA9IGNvcnJlY3Rpb247XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbW1lbnQgIT09IHVuZGVmaW5lZCAmJiBjb21tZW50ICE9PSBudWxsKSB7XG4gICAgICAgICAgICBmZWVkYmFja1VwZGF0ZVtcImNvbW1lbnRcIl0gPSBjb21tZW50O1xuICAgICAgICB9XG4gICAgICAgIGFzc2VydFV1aWQoZmVlZGJhY2tJZCk7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5jYWxsZXIuY2FsbChfZ2V0RmV0Y2hJbXBsZW1lbnRhdGlvbigpLCBgJHt0aGlzLmFwaVVybH0vZmVlZGJhY2svJHtmZWVkYmFja0lkfWAsIHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJQQVRDSFwiLFxuICAgICAgICAgICAgaGVhZGVyczogeyAuLi50aGlzLmhlYWRlcnMsIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiIH0sXG4gICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShmZWVkYmFja1VwZGF0ZSksXG4gICAgICAgICAgICBzaWduYWw6IEFib3J0U2lnbmFsLnRpbWVvdXQodGhpcy50aW1lb3V0X21zKSxcbiAgICAgICAgICAgIC4uLnRoaXMuZmV0Y2hPcHRpb25zLFxuICAgICAgICB9KTtcbiAgICAgICAgYXdhaXQgcmFpc2VGb3JTdGF0dXMocmVzcG9uc2UsIFwidXBkYXRlIGZlZWRiYWNrXCIsIHRydWUpO1xuICAgIH1cbiAgICBhc3luYyByZWFkRmVlZGJhY2soZmVlZGJhY2tJZCkge1xuICAgICAgICBhc3NlcnRVdWlkKGZlZWRiYWNrSWQpO1xuICAgICAgICBjb25zdCBwYXRoID0gYC9mZWVkYmFjay8ke2ZlZWRiYWNrSWR9YDtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLl9nZXQocGF0aCk7XG4gICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICB9XG4gICAgYXN5bmMgZGVsZXRlRmVlZGJhY2soZmVlZGJhY2tJZCkge1xuICAgICAgICBhc3NlcnRVdWlkKGZlZWRiYWNrSWQpO1xuICAgICAgICBjb25zdCBwYXRoID0gYC9mZWVkYmFjay8ke2ZlZWRiYWNrSWR9YDtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmNhbGxlci5jYWxsKF9nZXRGZXRjaEltcGxlbWVudGF0aW9uKCksIHRoaXMuYXBpVXJsICsgcGF0aCwge1xuICAgICAgICAgICAgbWV0aG9kOiBcIkRFTEVURVwiLFxuICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgc2lnbmFsOiBBYm9ydFNpZ25hbC50aW1lb3V0KHRoaXMudGltZW91dF9tcyksXG4gICAgICAgICAgICAuLi50aGlzLmZldGNoT3B0aW9ucyxcbiAgICAgICAgfSk7XG4gICAgICAgIGF3YWl0IHJhaXNlRm9yU3RhdHVzKHJlc3BvbnNlLCBgZGVsZXRlICR7cGF0aH1gKTtcbiAgICAgICAgYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgIH1cbiAgICBhc3luYyAqbGlzdEZlZWRiYWNrKHsgcnVuSWRzLCBmZWVkYmFja0tleXMsIGZlZWRiYWNrU291cmNlVHlwZXMsIH0gPSB7fSkge1xuICAgICAgICBjb25zdCBxdWVyeVBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoKTtcbiAgICAgICAgaWYgKHJ1bklkcykge1xuICAgICAgICAgICAgcXVlcnlQYXJhbXMuYXBwZW5kKFwicnVuXCIsIHJ1bklkcy5qb2luKFwiLFwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZlZWRiYWNrS2V5cykge1xuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgZmVlZGJhY2tLZXlzKSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbXMuYXBwZW5kKFwia2V5XCIsIGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZlZWRiYWNrU291cmNlVHlwZXMpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgdHlwZSBvZiBmZWVkYmFja1NvdXJjZVR5cGVzKSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbXMuYXBwZW5kKFwic291cmNlXCIsIHR5cGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciBhd2FpdCAoY29uc3QgZmVlZGJhY2tzIG9mIHRoaXMuX2dldFBhZ2luYXRlZChcIi9mZWVkYmFja1wiLCBxdWVyeVBhcmFtcykpIHtcbiAgICAgICAgICAgIHlpZWxkKiBmZWVkYmFja3M7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHByZXNpZ25lZCBmZWVkYmFjayB0b2tlbiBhbmQgVVJMLlxuICAgICAqXG4gICAgICogVGhlIHRva2VuIGNhbiBiZSB1c2VkIHRvIGF1dGhvcml6ZSBmZWVkYmFjayBtZXRyaWNzIHdpdGhvdXRcbiAgICAgKiBuZWVkaW5nIGFuIEFQSSBrZXkuIFRoaXMgaXMgdXNlZnVsIGZvciBnaXZpbmcgYnJvd3Nlci1iYXNlZFxuICAgICAqIGFwcGxpY2F0aW9ucyB0aGUgYWJpbGl0eSB0byBzdWJtaXQgZmVlZGJhY2sgd2l0aG91dCBuZWVkaW5nXG4gICAgICogdG8gZXhwb3NlIGFuIEFQSSBrZXkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcnVuSWQgVGhlIElEIG9mIHRoZSBydW4uXG4gICAgICogQHBhcmFtIGZlZWRiYWNrS2V5IFRoZSBmZWVkYmFjayBrZXkuXG4gICAgICogQHBhcmFtIG9wdGlvbnMgQWRkaXRpb25hbCBvcHRpb25zIGZvciB0aGUgdG9rZW4uXG4gICAgICogQHBhcmFtIG9wdGlvbnMuZXhwaXJhdGlvbiBUaGUgZXhwaXJhdGlvbiB0aW1lIGZvciB0aGUgdG9rZW4uXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIEZlZWRiYWNrSW5nZXN0VG9rZW4uXG4gICAgICovXG4gICAgYXN5bmMgY3JlYXRlUHJlc2lnbmVkRmVlZGJhY2tUb2tlbihydW5JZCwgZmVlZGJhY2tLZXksIHsgZXhwaXJhdGlvbiwgZmVlZGJhY2tDb25maWcsIH0gPSB7fSkge1xuICAgICAgICBjb25zdCBib2R5ID0ge1xuICAgICAgICAgICAgcnVuX2lkOiBydW5JZCxcbiAgICAgICAgICAgIGZlZWRiYWNrX2tleTogZmVlZGJhY2tLZXksXG4gICAgICAgICAgICBmZWVkYmFja19jb25maWc6IGZlZWRiYWNrQ29uZmlnLFxuICAgICAgICB9O1xuICAgICAgICBpZiAoZXhwaXJhdGlvbikge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBleHBpcmF0aW9uID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgYm9keVtcImV4cGlyZXNfYXRcIl0gPSBleHBpcmF0aW9uO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZXhwaXJhdGlvbj8uaG91cnMgfHwgZXhwaXJhdGlvbj8ubWludXRlcyB8fCBleHBpcmF0aW9uPy5kYXlzKSB7XG4gICAgICAgICAgICAgICAgYm9keVtcImV4cGlyZXNfaW5cIl0gPSBleHBpcmF0aW9uO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYm9keVtcImV4cGlyZXNfaW5cIl0gPSB7XG4gICAgICAgICAgICAgICAgaG91cnM6IDMsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5jYWxsZXIuY2FsbChfZ2V0RmV0Y2hJbXBsZW1lbnRhdGlvbigpLCBgJHt0aGlzLmFwaVVybH0vZmVlZGJhY2svdG9rZW5zYCwge1xuICAgICAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgICAgIGhlYWRlcnM6IHsgLi4udGhpcy5oZWFkZXJzLCBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIiB9LFxuICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgICAgICAgICBzaWduYWw6IEFib3J0U2lnbmFsLnRpbWVvdXQodGhpcy50aW1lb3V0X21zKSxcbiAgICAgICAgICAgIC4uLnRoaXMuZmV0Y2hPcHRpb25zLFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBhc3luYyBjcmVhdGVDb21wYXJhdGl2ZUV4cGVyaW1lbnQoeyBuYW1lLCBleHBlcmltZW50SWRzLCByZWZlcmVuY2VEYXRhc2V0SWQsIGNyZWF0ZWRBdCwgZGVzY3JpcHRpb24sIG1ldGFkYXRhLCBpZCwgfSkge1xuICAgICAgICBpZiAoZXhwZXJpbWVudElkcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkF0IGxlYXN0IG9uZSBleHBlcmltZW50IGlzIHJlcXVpcmVkXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghcmVmZXJlbmNlRGF0YXNldElkKSB7XG4gICAgICAgICAgICByZWZlcmVuY2VEYXRhc2V0SWQgPSAoYXdhaXQgdGhpcy5yZWFkUHJvamVjdCh7XG4gICAgICAgICAgICAgICAgcHJvamVjdElkOiBleHBlcmltZW50SWRzWzBdLFxuICAgICAgICAgICAgfSkpLnJlZmVyZW5jZV9kYXRhc2V0X2lkO1xuICAgICAgICB9XG4gICAgICAgIGlmICghcmVmZXJlbmNlRGF0YXNldElkID09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkEgcmVmZXJlbmNlIGRhdGFzZXQgaXMgcmVxdWlyZWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYm9keSA9IHtcbiAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgIGV4cGVyaW1lbnRfaWRzOiBleHBlcmltZW50SWRzLFxuICAgICAgICAgICAgcmVmZXJlbmNlX2RhdGFzZXRfaWQ6IHJlZmVyZW5jZURhdGFzZXRJZCxcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uLFxuICAgICAgICAgICAgY3JlYXRlZF9hdDogKGNyZWF0ZWRBdCA/PyBuZXcgRGF0ZSgpKT8udG9JU09TdHJpbmcoKSxcbiAgICAgICAgICAgIGV4dHJhOiB7fSxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKG1ldGFkYXRhKVxuICAgICAgICAgICAgYm9keS5leHRyYVtcIm1ldGFkYXRhXCJdID0gbWV0YWRhdGE7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5jYWxsZXIuY2FsbChfZ2V0RmV0Y2hJbXBsZW1lbnRhdGlvbigpLCBgJHt0aGlzLmFwaVVybH0vZGF0YXNldHMvY29tcGFyYXRpdmVgLCB7XG4gICAgICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICAgICAgaGVhZGVyczogeyAuLi50aGlzLmhlYWRlcnMsIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiIH0sXG4gICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KSxcbiAgICAgICAgICAgIHNpZ25hbDogQWJvcnRTaWduYWwudGltZW91dCh0aGlzLnRpbWVvdXRfbXMpLFxuICAgICAgICAgICAgLi4udGhpcy5mZXRjaE9wdGlvbnMsXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgYSBsaXN0IG9mIHByZXNpZ25lZCBmZWVkYmFjayB0b2tlbnMgZm9yIGEgZ2l2ZW4gcnVuIElELlxuICAgICAqIEBwYXJhbSBydW5JZCBUaGUgSUQgb2YgdGhlIHJ1bi5cbiAgICAgKiBAcmV0dXJucyBBbiBhc3luYyBpdGVyYWJsZSBvZiBGZWVkYmFja0luZ2VzdFRva2VuIG9iamVjdHMuXG4gICAgICovXG4gICAgYXN5bmMgKmxpc3RQcmVzaWduZWRGZWVkYmFja1Rva2VucyhydW5JZCkge1xuICAgICAgICBhc3NlcnRVdWlkKHJ1bklkKTtcbiAgICAgICAgY29uc3QgcGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcyh7IHJ1bl9pZDogcnVuSWQgfSk7XG4gICAgICAgIGZvciBhd2FpdCAoY29uc3QgdG9rZW5zIG9mIHRoaXMuX2dldFBhZ2luYXRlZChcIi9mZWVkYmFjay90b2tlbnNcIiwgcGFyYW1zKSkge1xuICAgICAgICAgICAgeWllbGQqIHRva2VucztcbiAgICAgICAgfVxuICAgIH1cbiAgICBfc2VsZWN0RXZhbFJlc3VsdHMocmVzdWx0cykge1xuICAgICAgICBsZXQgcmVzdWx0c187XG4gICAgICAgIGlmIChcInJlc3VsdHNcIiBpbiByZXN1bHRzKSB7XG4gICAgICAgICAgICByZXN1bHRzXyA9IHJlc3VsdHMucmVzdWx0cztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KHJlc3VsdHMpKSB7XG4gICAgICAgICAgICByZXN1bHRzXyA9IHJlc3VsdHM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXN1bHRzXyA9IFtyZXN1bHRzXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0c187XG4gICAgfVxuICAgIGFzeW5jIF9sb2dFdmFsdWF0aW9uRmVlZGJhY2soZXZhbHVhdG9yUmVzcG9uc2UsIHJ1biwgc291cmNlSW5mbykge1xuICAgICAgICBjb25zdCBldmFsUmVzdWx0cyA9IHRoaXMuX3NlbGVjdEV2YWxSZXN1bHRzKGV2YWx1YXRvclJlc3BvbnNlKTtcbiAgICAgICAgY29uc3QgZmVlZGJhY2tzID0gW107XG4gICAgICAgIGZvciAoY29uc3QgcmVzIG9mIGV2YWxSZXN1bHRzKSB7XG4gICAgICAgICAgICBsZXQgc291cmNlSW5mb18gPSBzb3VyY2VJbmZvIHx8IHt9O1xuICAgICAgICAgICAgaWYgKHJlcy5ldmFsdWF0b3JJbmZvKSB7XG4gICAgICAgICAgICAgICAgc291cmNlSW5mb18gPSB7IC4uLnJlcy5ldmFsdWF0b3JJbmZvLCAuLi5zb3VyY2VJbmZvXyB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHJ1bklkXyA9IG51bGw7XG4gICAgICAgICAgICBpZiAocmVzLnRhcmdldFJ1bklkKSB7XG4gICAgICAgICAgICAgICAgcnVuSWRfID0gcmVzLnRhcmdldFJ1bklkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocnVuKSB7XG4gICAgICAgICAgICAgICAgcnVuSWRfID0gcnVuLmlkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmVlZGJhY2tzLnB1c2goYXdhaXQgdGhpcy5jcmVhdGVGZWVkYmFjayhydW5JZF8sIHJlcy5rZXksIHtcbiAgICAgICAgICAgICAgICBzY29yZTogcmVzLnNjb3JlLFxuICAgICAgICAgICAgICAgIHZhbHVlOiByZXMudmFsdWUsXG4gICAgICAgICAgICAgICAgY29tbWVudDogcmVzLmNvbW1lbnQsXG4gICAgICAgICAgICAgICAgY29ycmVjdGlvbjogcmVzLmNvcnJlY3Rpb24sXG4gICAgICAgICAgICAgICAgc291cmNlSW5mbzogc291cmNlSW5mb18sXG4gICAgICAgICAgICAgICAgc291cmNlUnVuSWQ6IHJlcy5zb3VyY2VSdW5JZCxcbiAgICAgICAgICAgICAgICBmZWVkYmFja0NvbmZpZzogcmVzLmZlZWRiYWNrQ29uZmlnLFxuICAgICAgICAgICAgICAgIGZlZWRiYWNrU291cmNlVHlwZTogXCJtb2RlbFwiLFxuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbZXZhbFJlc3VsdHMsIGZlZWRiYWNrc107XG4gICAgfVxuICAgIGFzeW5jIGxvZ0V2YWx1YXRpb25GZWVkYmFjayhldmFsdWF0b3JSZXNwb25zZSwgcnVuLCBzb3VyY2VJbmZvKSB7XG4gICAgICAgIGNvbnN0IFtyZXN1bHRzXSA9IGF3YWl0IHRoaXMuX2xvZ0V2YWx1YXRpb25GZWVkYmFjayhldmFsdWF0b3JSZXNwb25zZSwgcnVuLCBzb3VyY2VJbmZvKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFQSSBmb3IgbWFuYWdpbmcgYW5ub3RhdGlvbiBxdWV1ZXNcbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiBMaXN0IHRoZSBhbm5vdGF0aW9uIHF1ZXVlcyBvbiB0aGUgTGFuZ1NtaXRoIEFQSS5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIFRoZSBvcHRpb25zIGZvciBsaXN0aW5nIGFubm90YXRpb24gcXVldWVzXG4gICAgICogQHBhcmFtIG9wdGlvbnMucXVldWVJZHMgLSBUaGUgSURzIG9mIHRoZSBxdWV1ZXMgdG8gZmlsdGVyIGJ5XG4gICAgICogQHBhcmFtIG9wdGlvbnMubmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBxdWV1ZSB0byBmaWx0ZXIgYnlcbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5uYW1lQ29udGFpbnMgLSBUaGUgc3Vic3RyaW5nIHRoYXQgdGhlIHF1ZXVlIG5hbWUgc2hvdWxkIGNvbnRhaW5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5saW1pdCAtIFRoZSBtYXhpbXVtIG51bWJlciBvZiBxdWV1ZXMgdG8gcmV0dXJuXG4gICAgICogQHJldHVybnMgQW4gaXRlcmF0b3Igb2YgQW5ub3RhdGlvblF1ZXVlIG9iamVjdHNcbiAgICAgKi9cbiAgICBhc3luYyAqbGlzdEFubm90YXRpb25RdWV1ZXMob3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIGNvbnN0IHsgcXVldWVJZHMsIG5hbWUsIG5hbWVDb250YWlucywgbGltaXQgfSA9IG9wdGlvbnM7XG4gICAgICAgIGNvbnN0IHBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoKTtcbiAgICAgICAgaWYgKHF1ZXVlSWRzKSB7XG4gICAgICAgICAgICBxdWV1ZUlkcy5mb3JFYWNoKChpZCwgaSkgPT4ge1xuICAgICAgICAgICAgICAgIGFzc2VydFV1aWQoaWQsIGBxdWV1ZUlkc1ske2l9XWApO1xuICAgICAgICAgICAgICAgIHBhcmFtcy5hcHBlbmQoXCJpZHNcIiwgaWQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5hbWUpXG4gICAgICAgICAgICBwYXJhbXMuYXBwZW5kKFwibmFtZVwiLCBuYW1lKTtcbiAgICAgICAgaWYgKG5hbWVDb250YWlucylcbiAgICAgICAgICAgIHBhcmFtcy5hcHBlbmQoXCJuYW1lX2NvbnRhaW5zXCIsIG5hbWVDb250YWlucyk7XG4gICAgICAgIHBhcmFtcy5hcHBlbmQoXCJsaW1pdFwiLCAobGltaXQgIT09IHVuZGVmaW5lZCA/IE1hdGgubWluKGxpbWl0LCAxMDApIDogMTAwKS50b1N0cmluZygpKTtcbiAgICAgICAgbGV0IGNvdW50ID0gMDtcbiAgICAgICAgZm9yIGF3YWl0IChjb25zdCBxdWV1ZXMgb2YgdGhpcy5fZ2V0UGFnaW5hdGVkKFwiL2Fubm90YXRpb24tcXVldWVzXCIsIHBhcmFtcykpIHtcbiAgICAgICAgICAgIHlpZWxkKiBxdWV1ZXM7XG4gICAgICAgICAgICBjb3VudCsrO1xuICAgICAgICAgICAgaWYgKGxpbWl0ICE9PSB1bmRlZmluZWQgJiYgY291bnQgPj0gbGltaXQpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGFuIGFubm90YXRpb24gcXVldWUgb24gdGhlIExhbmdTbWl0aCBBUEkuXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBUaGUgb3B0aW9ucyBmb3IgY3JlYXRpbmcgYW4gYW5ub3RhdGlvbiBxdWV1ZVxuICAgICAqIEBwYXJhbSBvcHRpb25zLm5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgYW5ub3RhdGlvbiBxdWV1ZVxuICAgICAqIEBwYXJhbSBvcHRpb25zLmRlc2NyaXB0aW9uIC0gVGhlIGRlc2NyaXB0aW9uIG9mIHRoZSBhbm5vdGF0aW9uIHF1ZXVlXG4gICAgICogQHBhcmFtIG9wdGlvbnMucXVldWVJZCAtIFRoZSBJRCBvZiB0aGUgYW5ub3RhdGlvbiBxdWV1ZVxuICAgICAqIEByZXR1cm5zIFRoZSBjcmVhdGVkIEFubm90YXRpb25RdWV1ZSBvYmplY3RcbiAgICAgKi9cbiAgICBhc3luYyBjcmVhdGVBbm5vdGF0aW9uUXVldWUob3B0aW9ucykge1xuICAgICAgICBjb25zdCB7IG5hbWUsIGRlc2NyaXB0aW9uLCBxdWV1ZUlkIH0gPSBvcHRpb25zO1xuICAgICAgICBjb25zdCBib2R5ID0ge1xuICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uLFxuICAgICAgICAgICAgaWQ6IHF1ZXVlSWQgfHwgdXVpZC52NCgpLFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuY2FsbGVyLmNhbGwoX2dldEZldGNoSW1wbGVtZW50YXRpb24oKSwgYCR7dGhpcy5hcGlVcmx9L2Fubm90YXRpb24tcXVldWVzYCwge1xuICAgICAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgICAgIGhlYWRlcnM6IHsgLi4udGhpcy5oZWFkZXJzLCBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIiB9LFxuICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoT2JqZWN0LmZyb21FbnRyaWVzKE9iamVjdC5lbnRyaWVzKGJvZHkpLmZpbHRlcigoW18sIHZdKSA9PiB2ICE9PSB1bmRlZmluZWQpKSksXG4gICAgICAgICAgICBzaWduYWw6IEFib3J0U2lnbmFsLnRpbWVvdXQodGhpcy50aW1lb3V0X21zKSxcbiAgICAgICAgICAgIC4uLnRoaXMuZmV0Y2hPcHRpb25zLFxuICAgICAgICB9KTtcbiAgICAgICAgYXdhaXQgcmFpc2VGb3JTdGF0dXMocmVzcG9uc2UsIFwiY3JlYXRlIGFubm90YXRpb24gcXVldWVcIik7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWFkIGFuIGFubm90YXRpb24gcXVldWUgd2l0aCB0aGUgc3BlY2lmaWVkIHF1ZXVlIElELlxuICAgICAqIEBwYXJhbSBxdWV1ZUlkIC0gVGhlIElEIG9mIHRoZSBhbm5vdGF0aW9uIHF1ZXVlIHRvIHJlYWRcbiAgICAgKiBAcmV0dXJucyBUaGUgQW5ub3RhdGlvblF1ZXVlIG9iamVjdFxuICAgICAqL1xuICAgIGFzeW5jIHJlYWRBbm5vdGF0aW9uUXVldWUocXVldWVJZCkge1xuICAgICAgICAvLyBUT0RPOiBSZXBsYWNlIHdoZW4gYWN0dWFsIGVuZHBvaW50IGlzIGFkZGVkXG4gICAgICAgIGNvbnN0IHF1ZXVlSXRlcmF0b3JSZXN1bHQgPSBhd2FpdCB0aGlzLmxpc3RBbm5vdGF0aW9uUXVldWVzKHtcbiAgICAgICAgICAgIHF1ZXVlSWRzOiBbcXVldWVJZF0sXG4gICAgICAgIH0pLm5leHQoKTtcbiAgICAgICAgaWYgKHF1ZXVlSXRlcmF0b3JSZXN1bHQuZG9uZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBBbm5vdGF0aW9uIHF1ZXVlIHdpdGggSUQgJHtxdWV1ZUlkfSBub3QgZm91bmRgKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcXVldWVJdGVyYXRvclJlc3VsdC52YWx1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBkYXRlIGFuIGFubm90YXRpb24gcXVldWUgd2l0aCB0aGUgc3BlY2lmaWVkIHF1ZXVlIElELlxuICAgICAqIEBwYXJhbSBxdWV1ZUlkIC0gVGhlIElEIG9mIHRoZSBhbm5vdGF0aW9uIHF1ZXVlIHRvIHVwZGF0ZVxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gVGhlIG9wdGlvbnMgZm9yIHVwZGF0aW5nIHRoZSBhbm5vdGF0aW9uIHF1ZXVlXG4gICAgICogQHBhcmFtIG9wdGlvbnMubmFtZSAtIFRoZSBuZXcgbmFtZSBmb3IgdGhlIGFubm90YXRpb24gcXVldWVcbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5kZXNjcmlwdGlvbiAtIFRoZSBuZXcgZGVzY3JpcHRpb24gZm9yIHRoZSBhbm5vdGF0aW9uIHF1ZXVlXG4gICAgICovXG4gICAgYXN5bmMgdXBkYXRlQW5ub3RhdGlvblF1ZXVlKHF1ZXVlSWQsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgeyBuYW1lLCBkZXNjcmlwdGlvbiB9ID0gb3B0aW9ucztcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmNhbGxlci5jYWxsKF9nZXRGZXRjaEltcGxlbWVudGF0aW9uKCksIGAke3RoaXMuYXBpVXJsfS9hbm5vdGF0aW9uLXF1ZXVlcy8ke2Fzc2VydFV1aWQocXVldWVJZCwgXCJxdWV1ZUlkXCIpfWAsIHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJQQVRDSFwiLFxuICAgICAgICAgICAgaGVhZGVyczogeyAuLi50aGlzLmhlYWRlcnMsIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiIH0sXG4gICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7IG5hbWUsIGRlc2NyaXB0aW9uIH0pLFxuICAgICAgICAgICAgc2lnbmFsOiBBYm9ydFNpZ25hbC50aW1lb3V0KHRoaXMudGltZW91dF9tcyksXG4gICAgICAgICAgICAuLi50aGlzLmZldGNoT3B0aW9ucyxcbiAgICAgICAgfSk7XG4gICAgICAgIGF3YWl0IHJhaXNlRm9yU3RhdHVzKHJlc3BvbnNlLCBcInVwZGF0ZSBhbm5vdGF0aW9uIHF1ZXVlXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZWxldGUgYW4gYW5ub3RhdGlvbiBxdWV1ZSB3aXRoIHRoZSBzcGVjaWZpZWQgcXVldWUgSUQuXG4gICAgICogQHBhcmFtIHF1ZXVlSWQgLSBUaGUgSUQgb2YgdGhlIGFubm90YXRpb24gcXVldWUgdG8gZGVsZXRlXG4gICAgICovXG4gICAgYXN5bmMgZGVsZXRlQW5ub3RhdGlvblF1ZXVlKHF1ZXVlSWQpIHtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmNhbGxlci5jYWxsKF9nZXRGZXRjaEltcGxlbWVudGF0aW9uKCksIGAke3RoaXMuYXBpVXJsfS9hbm5vdGF0aW9uLXF1ZXVlcy8ke2Fzc2VydFV1aWQocXVldWVJZCwgXCJxdWV1ZUlkXCIpfWAsIHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJERUxFVEVcIixcbiAgICAgICAgICAgIGhlYWRlcnM6IHsgLi4udGhpcy5oZWFkZXJzLCBBY2NlcHQ6IFwiYXBwbGljYXRpb24vanNvblwiIH0sXG4gICAgICAgICAgICBzaWduYWw6IEFib3J0U2lnbmFsLnRpbWVvdXQodGhpcy50aW1lb3V0X21zKSxcbiAgICAgICAgICAgIC4uLnRoaXMuZmV0Y2hPcHRpb25zLFxuICAgICAgICB9KTtcbiAgICAgICAgYXdhaXQgcmFpc2VGb3JTdGF0dXMocmVzcG9uc2UsIFwiZGVsZXRlIGFubm90YXRpb24gcXVldWVcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZCBydW5zIHRvIGFuIGFubm90YXRpb24gcXVldWUgd2l0aCB0aGUgc3BlY2lmaWVkIHF1ZXVlIElELlxuICAgICAqIEBwYXJhbSBxdWV1ZUlkIC0gVGhlIElEIG9mIHRoZSBhbm5vdGF0aW9uIHF1ZXVlXG4gICAgICogQHBhcmFtIHJ1bklkcyAtIFRoZSBJRHMgb2YgdGhlIHJ1bnMgdG8gYmUgYWRkZWQgdG8gdGhlIGFubm90YXRpb24gcXVldWVcbiAgICAgKi9cbiAgICBhc3luYyBhZGRSdW5zVG9Bbm5vdGF0aW9uUXVldWUocXVldWVJZCwgcnVuSWRzKSB7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5jYWxsZXIuY2FsbChfZ2V0RmV0Y2hJbXBsZW1lbnRhdGlvbigpLCBgJHt0aGlzLmFwaVVybH0vYW5ub3RhdGlvbi1xdWV1ZXMvJHthc3NlcnRVdWlkKHF1ZXVlSWQsIFwicXVldWVJZFwiKX0vcnVuc2AsIHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgICAgICBoZWFkZXJzOiB7IC4uLnRoaXMuaGVhZGVycywgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIgfSxcbiAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHJ1bklkcy5tYXAoKGlkLCBpKSA9PiBhc3NlcnRVdWlkKGlkLCBgcnVuSWRzWyR7aX1dYCkudG9TdHJpbmcoKSkpLFxuICAgICAgICAgICAgc2lnbmFsOiBBYm9ydFNpZ25hbC50aW1lb3V0KHRoaXMudGltZW91dF9tcyksXG4gICAgICAgICAgICAuLi50aGlzLmZldGNoT3B0aW9ucyxcbiAgICAgICAgfSk7XG4gICAgICAgIGF3YWl0IHJhaXNlRm9yU3RhdHVzKHJlc3BvbnNlLCBcImFkZCBydW5zIHRvIGFubm90YXRpb24gcXVldWVcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBhIHJ1biBmcm9tIGFuIGFubm90YXRpb24gcXVldWUgYXQgdGhlIHNwZWNpZmllZCBpbmRleC5cbiAgICAgKiBAcGFyYW0gcXVldWVJZCAtIFRoZSBJRCBvZiB0aGUgYW5ub3RhdGlvbiBxdWV1ZVxuICAgICAqIEBwYXJhbSBpbmRleCAtIFRoZSBpbmRleCBvZiB0aGUgcnVuIHRvIHJldHJpZXZlXG4gICAgICogQHJldHVybnMgQSBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBSdW5XaXRoQW5ub3RhdGlvblF1ZXVlSW5mbyBvYmplY3RcbiAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIHJ1biBpcyBub3QgZm91bmQgYXQgdGhlIGdpdmVuIGluZGV4IG9yIGZvciBvdGhlciBBUEktcmVsYXRlZCBlcnJvcnNcbiAgICAgKi9cbiAgICBhc3luYyBnZXRSdW5Gcm9tQW5ub3RhdGlvblF1ZXVlKHF1ZXVlSWQsIGluZGV4KSB7XG4gICAgICAgIGNvbnN0IGJhc2VVcmwgPSBgL2Fubm90YXRpb24tcXVldWVzLyR7YXNzZXJ0VXVpZChxdWV1ZUlkLCBcInF1ZXVlSWRcIil9L3J1bmA7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5jYWxsZXIuY2FsbChfZ2V0RmV0Y2hJbXBsZW1lbnRhdGlvbigpLCBgJHt0aGlzLmFwaVVybH0ke2Jhc2VVcmx9LyR7aW5kZXh9YCwge1xuICAgICAgICAgICAgbWV0aG9kOiBcIkdFVFwiLFxuICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgc2lnbmFsOiBBYm9ydFNpZ25hbC50aW1lb3V0KHRoaXMudGltZW91dF9tcyksXG4gICAgICAgICAgICAuLi50aGlzLmZldGNoT3B0aW9ucyxcbiAgICAgICAgfSk7XG4gICAgICAgIGF3YWl0IHJhaXNlRm9yU3RhdHVzKHJlc3BvbnNlLCBcImdldCBydW4gZnJvbSBhbm5vdGF0aW9uIHF1ZXVlXCIpO1xuICAgICAgICByZXR1cm4gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZWxldGUgYSBydW4gZnJvbSBhbiBhbiBhbm5vdGF0aW9uIHF1ZXVlLlxuICAgICAqIEBwYXJhbSBxdWV1ZUlkIC0gVGhlIElEIG9mIHRoZSBhbm5vdGF0aW9uIHF1ZXVlIHRvIGRlbGV0ZSB0aGUgcnVuIGZyb21cbiAgICAgKiBAcGFyYW0gcXVldWVSdW5JZCAtIFRoZSBJRCBvZiB0aGUgcnVuIHRvIGRlbGV0ZSBmcm9tIHRoZSBhbm5vdGF0aW9uIHF1ZXVlXG4gICAgICovXG4gICAgYXN5bmMgZGVsZXRlUnVuRnJvbUFubm90YXRpb25RdWV1ZShxdWV1ZUlkLCBxdWV1ZVJ1bklkKSB7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5jYWxsZXIuY2FsbChfZ2V0RmV0Y2hJbXBsZW1lbnRhdGlvbigpLCBgJHt0aGlzLmFwaVVybH0vYW5ub3RhdGlvbi1xdWV1ZXMvJHthc3NlcnRVdWlkKHF1ZXVlSWQsIFwicXVldWVJZFwiKX0vcnVucy8ke2Fzc2VydFV1aWQocXVldWVSdW5JZCwgXCJxdWV1ZVJ1bklkXCIpfWAsIHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJERUxFVEVcIixcbiAgICAgICAgICAgIGhlYWRlcnM6IHsgLi4udGhpcy5oZWFkZXJzLCBBY2NlcHQ6IFwiYXBwbGljYXRpb24vanNvblwiIH0sXG4gICAgICAgICAgICBzaWduYWw6IEFib3J0U2lnbmFsLnRpbWVvdXQodGhpcy50aW1lb3V0X21zKSxcbiAgICAgICAgICAgIC4uLnRoaXMuZmV0Y2hPcHRpb25zLFxuICAgICAgICB9KTtcbiAgICAgICAgYXdhaXQgcmFpc2VGb3JTdGF0dXMocmVzcG9uc2UsIFwiZGVsZXRlIHJ1biBmcm9tIGFubm90YXRpb24gcXVldWVcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgc2l6ZSBvZiBhbiBhbm5vdGF0aW9uIHF1ZXVlLlxuICAgICAqIEBwYXJhbSBxdWV1ZUlkIC0gVGhlIElEIG9mIHRoZSBhbm5vdGF0aW9uIHF1ZXVlXG4gICAgICovXG4gICAgYXN5bmMgZ2V0U2l6ZUZyb21Bbm5vdGF0aW9uUXVldWUocXVldWVJZCkge1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuY2FsbGVyLmNhbGwoX2dldEZldGNoSW1wbGVtZW50YXRpb24oKSwgYCR7dGhpcy5hcGlVcmx9L2Fubm90YXRpb24tcXVldWVzLyR7YXNzZXJ0VXVpZChxdWV1ZUlkLCBcInF1ZXVlSWRcIil9L3NpemVgLCB7XG4gICAgICAgICAgICBtZXRob2Q6IFwiR0VUXCIsXG4gICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICBzaWduYWw6IEFib3J0U2lnbmFsLnRpbWVvdXQodGhpcy50aW1lb3V0X21zKSxcbiAgICAgICAgICAgIC4uLnRoaXMuZmV0Y2hPcHRpb25zLFxuICAgICAgICB9KTtcbiAgICAgICAgYXdhaXQgcmFpc2VGb3JTdGF0dXMocmVzcG9uc2UsIFwiZ2V0IHNpemUgZnJvbSBhbm5vdGF0aW9uIHF1ZXVlXCIpO1xuICAgICAgICByZXR1cm4gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgIH1cbiAgICBhc3luYyBfY3VycmVudFRlbmFudElzT3duZXIob3duZXIpIHtcbiAgICAgICAgY29uc3Qgc2V0dGluZ3MgPSBhd2FpdCB0aGlzLl9nZXRTZXR0aW5ncygpO1xuICAgICAgICByZXR1cm4gb3duZXIgPT0gXCItXCIgfHwgc2V0dGluZ3MudGVuYW50X2hhbmRsZSA9PT0gb3duZXI7XG4gICAgfVxuICAgIGFzeW5jIF9vd25lckNvbmZsaWN0RXJyb3IoYWN0aW9uLCBvd25lcikge1xuICAgICAgICBjb25zdCBzZXR0aW5ncyA9IGF3YWl0IHRoaXMuX2dldFNldHRpbmdzKCk7XG4gICAgICAgIHJldHVybiBuZXcgRXJyb3IoYENhbm5vdCAke2FjdGlvbn0gZm9yIGFub3RoZXIgdGVuYW50LlxcblxuICAgICAgQ3VycmVudCB0ZW5hbnQ6ICR7c2V0dGluZ3MudGVuYW50X2hhbmRsZX1cXG5cbiAgICAgIFJlcXVlc3RlZCB0ZW5hbnQ6ICR7b3duZXJ9YCk7XG4gICAgfVxuICAgIGFzeW5jIF9nZXRMYXRlc3RDb21taXRIYXNoKHByb21wdE93bmVyQW5kTmFtZSkge1xuICAgICAgICBjb25zdCByZXMgPSBhd2FpdCB0aGlzLmNhbGxlci5jYWxsKF9nZXRGZXRjaEltcGxlbWVudGF0aW9uKCksIGAke3RoaXMuYXBpVXJsfS9jb21taXRzLyR7cHJvbXB0T3duZXJBbmROYW1lfS8/bGltaXQ9JHsxfSZvZmZzZXQ9JHswfWAsIHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJHRVRcIixcbiAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgIHNpZ25hbDogQWJvcnRTaWduYWwudGltZW91dCh0aGlzLnRpbWVvdXRfbXMpLFxuICAgICAgICAgICAgLi4udGhpcy5mZXRjaE9wdGlvbnMsXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBqc29uID0gYXdhaXQgcmVzLmpzb24oKTtcbiAgICAgICAgaWYgKCFyZXMub2spIHtcbiAgICAgICAgICAgIGNvbnN0IGRldGFpbCA9IHR5cGVvZiBqc29uLmRldGFpbCA9PT0gXCJzdHJpbmdcIlxuICAgICAgICAgICAgICAgID8ganNvbi5kZXRhaWxcbiAgICAgICAgICAgICAgICA6IEpTT04uc3RyaW5naWZ5KGpzb24uZGV0YWlsKTtcbiAgICAgICAgICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKGBFcnJvciAke3Jlcy5zdGF0dXN9OiAke3Jlcy5zdGF0dXNUZXh0fVxcbiR7ZGV0YWlsfWApO1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgICAgIGVycm9yLnN0YXR1c0NvZGUgPSByZXMuc3RhdHVzO1xuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGpzb24uY29tbWl0cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGpzb24uY29tbWl0c1swXS5jb21taXRfaGFzaDtcbiAgICB9XG4gICAgYXN5bmMgX2xpa2VPclVubGlrZVByb21wdChwcm9tcHRJZGVudGlmaWVyLCBsaWtlKSB7XG4gICAgICAgIGNvbnN0IFtvd25lciwgcHJvbXB0TmFtZSwgX10gPSBwYXJzZVByb21wdElkZW50aWZpZXIocHJvbXB0SWRlbnRpZmllcik7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5jYWxsZXIuY2FsbChfZ2V0RmV0Y2hJbXBsZW1lbnRhdGlvbigpLCBgJHt0aGlzLmFwaVVybH0vbGlrZXMvJHtvd25lcn0vJHtwcm9tcHROYW1lfWAsIHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7IGxpa2U6IGxpa2UgfSksXG4gICAgICAgICAgICBoZWFkZXJzOiB7IC4uLnRoaXMuaGVhZGVycywgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIgfSxcbiAgICAgICAgICAgIHNpZ25hbDogQWJvcnRTaWduYWwudGltZW91dCh0aGlzLnRpbWVvdXRfbXMpLFxuICAgICAgICAgICAgLi4udGhpcy5mZXRjaE9wdGlvbnMsXG4gICAgICAgIH0pO1xuICAgICAgICBhd2FpdCByYWlzZUZvclN0YXR1cyhyZXNwb25zZSwgYCR7bGlrZSA/IFwibGlrZVwiIDogXCJ1bmxpa2VcIn0gcHJvbXB0YCk7XG4gICAgICAgIHJldHVybiBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgfVxuICAgIGFzeW5jIF9nZXRQcm9tcHRVcmwocHJvbXB0SWRlbnRpZmllcikge1xuICAgICAgICBjb25zdCBbb3duZXIsIHByb21wdE5hbWUsIGNvbW1pdEhhc2hdID0gcGFyc2VQcm9tcHRJZGVudGlmaWVyKHByb21wdElkZW50aWZpZXIpO1xuICAgICAgICBpZiAoIShhd2FpdCB0aGlzLl9jdXJyZW50VGVuYW50SXNPd25lcihvd25lcikpKSB7XG4gICAgICAgICAgICBpZiAoY29tbWl0SGFzaCAhPT0gXCJsYXRlc3RcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiBgJHt0aGlzLmdldEhvc3RVcmwoKX0vaHViLyR7b3duZXJ9LyR7cHJvbXB0TmFtZX0vJHtjb21taXRIYXNoLnN1YnN0cmluZygwLCA4KX1gO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGAke3RoaXMuZ2V0SG9zdFVybCgpfS9odWIvJHtvd25lcn0vJHtwcm9tcHROYW1lfWA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBzZXR0aW5ncyA9IGF3YWl0IHRoaXMuX2dldFNldHRpbmdzKCk7XG4gICAgICAgICAgICBpZiAoY29tbWl0SGFzaCAhPT0gXCJsYXRlc3RcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiBgJHt0aGlzLmdldEhvc3RVcmwoKX0vcHJvbXB0cy8ke3Byb21wdE5hbWV9LyR7Y29tbWl0SGFzaC5zdWJzdHJpbmcoMCwgOCl9P29yZ2FuaXphdGlvbklkPSR7c2V0dGluZ3MuaWR9YDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBgJHt0aGlzLmdldEhvc3RVcmwoKX0vcHJvbXB0cy8ke3Byb21wdE5hbWV9P29yZ2FuaXphdGlvbklkPSR7c2V0dGluZ3MuaWR9YDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBwcm9tcHRFeGlzdHMocHJvbXB0SWRlbnRpZmllcikge1xuICAgICAgICBjb25zdCBwcm9tcHQgPSBhd2FpdCB0aGlzLmdldFByb21wdChwcm9tcHRJZGVudGlmaWVyKTtcbiAgICAgICAgcmV0dXJuICEhcHJvbXB0O1xuICAgIH1cbiAgICBhc3luYyBsaWtlUHJvbXB0KHByb21wdElkZW50aWZpZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xpa2VPclVubGlrZVByb21wdChwcm9tcHRJZGVudGlmaWVyLCB0cnVlKTtcbiAgICB9XG4gICAgYXN5bmMgdW5saWtlUHJvbXB0KHByb21wdElkZW50aWZpZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xpa2VPclVubGlrZVByb21wdChwcm9tcHRJZGVudGlmaWVyLCBmYWxzZSk7XG4gICAgfVxuICAgIGFzeW5jICpsaXN0Q29tbWl0cyhwcm9tcHRPd25lckFuZE5hbWUpIHtcbiAgICAgICAgZm9yIGF3YWl0IChjb25zdCBjb21taXRzIG9mIHRoaXMuX2dldFBhZ2luYXRlZChgL2NvbW1pdHMvJHtwcm9tcHRPd25lckFuZE5hbWV9L2AsIG5ldyBVUkxTZWFyY2hQYXJhbXMoKSwgKHJlcykgPT4gcmVzLmNvbW1pdHMpKSB7XG4gICAgICAgICAgICB5aWVsZCogY29tbWl0cztcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyAqbGlzdFByb21wdHMob3B0aW9ucykge1xuICAgICAgICBjb25zdCBwYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKCk7XG4gICAgICAgIHBhcmFtcy5hcHBlbmQoXCJzb3J0X2ZpZWxkXCIsIG9wdGlvbnM/LnNvcnRGaWVsZCA/PyBcInVwZGF0ZWRfYXRcIik7XG4gICAgICAgIHBhcmFtcy5hcHBlbmQoXCJzb3J0X2RpcmVjdGlvblwiLCBcImRlc2NcIik7XG4gICAgICAgIHBhcmFtcy5hcHBlbmQoXCJpc19hcmNoaXZlZFwiLCAoISFvcHRpb25zPy5pc0FyY2hpdmVkKS50b1N0cmluZygpKTtcbiAgICAgICAgaWYgKG9wdGlvbnM/LmlzUHVibGljICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHBhcmFtcy5hcHBlbmQoXCJpc19wdWJsaWNcIiwgb3B0aW9ucy5pc1B1YmxpYy50b1N0cmluZygpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucz8ucXVlcnkpIHtcbiAgICAgICAgICAgIHBhcmFtcy5hcHBlbmQoXCJxdWVyeVwiLCBvcHRpb25zLnF1ZXJ5KTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IHByb21wdHMgb2YgdGhpcy5fZ2V0UGFnaW5hdGVkKFwiL3JlcG9zXCIsIHBhcmFtcywgKHJlcykgPT4gcmVzLnJlcG9zKSkge1xuICAgICAgICAgICAgeWllbGQqIHByb21wdHM7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgZ2V0UHJvbXB0KHByb21wdElkZW50aWZpZXIpIHtcbiAgICAgICAgY29uc3QgW293bmVyLCBwcm9tcHROYW1lLCBfXSA9IHBhcnNlUHJvbXB0SWRlbnRpZmllcihwcm9tcHRJZGVudGlmaWVyKTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmNhbGxlci5jYWxsKF9nZXRGZXRjaEltcGxlbWVudGF0aW9uKCksIGAke3RoaXMuYXBpVXJsfS9yZXBvcy8ke293bmVyfS8ke3Byb21wdE5hbWV9YCwge1xuICAgICAgICAgICAgbWV0aG9kOiBcIkdFVFwiLFxuICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgc2lnbmFsOiBBYm9ydFNpZ25hbC50aW1lb3V0KHRoaXMudGltZW91dF9tcyksXG4gICAgICAgICAgICAuLi50aGlzLmZldGNoT3B0aW9ucyxcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChyZXNwb25zZS5zdGF0dXMgPT09IDQwNCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgcmFpc2VGb3JTdGF0dXMocmVzcG9uc2UsIFwiZ2V0IHByb21wdFwiKTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgICBpZiAocmVzdWx0LnJlcG8pIHtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQucmVwbztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIGNyZWF0ZVByb21wdChwcm9tcHRJZGVudGlmaWVyLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IHNldHRpbmdzID0gYXdhaXQgdGhpcy5fZ2V0U2V0dGluZ3MoKTtcbiAgICAgICAgaWYgKG9wdGlvbnM/LmlzUHVibGljICYmICFzZXR0aW5ncy50ZW5hbnRfaGFuZGxlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCBjcmVhdGUgYSBwdWJsaWMgcHJvbXB0IHdpdGhvdXQgZmlyc3RcXG5cbiAgICAgICAgY3JlYXRpbmcgYSBMYW5nQ2hhaW4gSHViIGhhbmRsZS4gXG4gICAgICAgIFlvdSBjYW4gYWRkIGEgaGFuZGxlIGJ5IGNyZWF0aW5nIGEgcHVibGljIHByb21wdCBhdDpcXG5cbiAgICAgICAgaHR0cHM6Ly9zbWl0aC5sYW5nY2hhaW4uY29tL3Byb21wdHNgKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBbb3duZXIsIHByb21wdE5hbWUsIF9dID0gcGFyc2VQcm9tcHRJZGVudGlmaWVyKHByb21wdElkZW50aWZpZXIpO1xuICAgICAgICBpZiAoIShhd2FpdCB0aGlzLl9jdXJyZW50VGVuYW50SXNPd25lcihvd25lcikpKSB7XG4gICAgICAgICAgICB0aHJvdyBhd2FpdCB0aGlzLl9vd25lckNvbmZsaWN0RXJyb3IoXCJjcmVhdGUgYSBwcm9tcHRcIiwgb3duZXIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRhdGEgPSB7XG4gICAgICAgICAgICByZXBvX2hhbmRsZTogcHJvbXB0TmFtZSxcbiAgICAgICAgICAgIC4uLihvcHRpb25zPy5kZXNjcmlwdGlvbiAmJiB7IGRlc2NyaXB0aW9uOiBvcHRpb25zLmRlc2NyaXB0aW9uIH0pLFxuICAgICAgICAgICAgLi4uKG9wdGlvbnM/LnJlYWRtZSAmJiB7IHJlYWRtZTogb3B0aW9ucy5yZWFkbWUgfSksXG4gICAgICAgICAgICAuLi4ob3B0aW9ucz8udGFncyAmJiB7IHRhZ3M6IG9wdGlvbnMudGFncyB9KSxcbiAgICAgICAgICAgIGlzX3B1YmxpYzogISFvcHRpb25zPy5pc1B1YmxpYyxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmNhbGxlci5jYWxsKF9nZXRGZXRjaEltcGxlbWVudGF0aW9uKCksIGAke3RoaXMuYXBpVXJsfS9yZXBvcy9gLCB7XG4gICAgICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICAgICAgaGVhZGVyczogeyAuLi50aGlzLmhlYWRlcnMsIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiIH0sXG4gICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShkYXRhKSxcbiAgICAgICAgICAgIHNpZ25hbDogQWJvcnRTaWduYWwudGltZW91dCh0aGlzLnRpbWVvdXRfbXMpLFxuICAgICAgICAgICAgLi4udGhpcy5mZXRjaE9wdGlvbnMsXG4gICAgICAgIH0pO1xuICAgICAgICBhd2FpdCByYWlzZUZvclN0YXR1cyhyZXNwb25zZSwgXCJjcmVhdGUgcHJvbXB0XCIpO1xuICAgICAgICBjb25zdCB7IHJlcG8gfSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgcmV0dXJuIHJlcG87XG4gICAgfVxuICAgIGFzeW5jIGNyZWF0ZUNvbW1pdChwcm9tcHRJZGVudGlmaWVyLCBvYmplY3QsIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKCEoYXdhaXQgdGhpcy5wcm9tcHRFeGlzdHMocHJvbXB0SWRlbnRpZmllcikpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQcm9tcHQgZG9lcyBub3QgZXhpc3QsIHlvdSBtdXN0IGNyZWF0ZSBpdCBmaXJzdC5cIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgW293bmVyLCBwcm9tcHROYW1lLCBfXSA9IHBhcnNlUHJvbXB0SWRlbnRpZmllcihwcm9tcHRJZGVudGlmaWVyKTtcbiAgICAgICAgY29uc3QgcmVzb2x2ZWRQYXJlbnRDb21taXRIYXNoID0gb3B0aW9ucz8ucGFyZW50Q29tbWl0SGFzaCA9PT0gXCJsYXRlc3RcIiB8fCAhb3B0aW9ucz8ucGFyZW50Q29tbWl0SGFzaFxuICAgICAgICAgICAgPyBhd2FpdCB0aGlzLl9nZXRMYXRlc3RDb21taXRIYXNoKGAke293bmVyfS8ke3Byb21wdE5hbWV9YClcbiAgICAgICAgICAgIDogb3B0aW9ucz8ucGFyZW50Q29tbWl0SGFzaDtcbiAgICAgICAgY29uc3QgcGF5bG9hZCA9IHtcbiAgICAgICAgICAgIG1hbmlmZXN0OiBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KG9iamVjdCkpLFxuICAgICAgICAgICAgcGFyZW50X2NvbW1pdDogcmVzb2x2ZWRQYXJlbnRDb21taXRIYXNoLFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuY2FsbGVyLmNhbGwoX2dldEZldGNoSW1wbGVtZW50YXRpb24oKSwgYCR7dGhpcy5hcGlVcmx9L2NvbW1pdHMvJHtvd25lcn0vJHtwcm9tcHROYW1lfWAsIHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgICAgICBoZWFkZXJzOiB7IC4uLnRoaXMuaGVhZGVycywgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIgfSxcbiAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHBheWxvYWQpLFxuICAgICAgICAgICAgc2lnbmFsOiBBYm9ydFNpZ25hbC50aW1lb3V0KHRoaXMudGltZW91dF9tcyksXG4gICAgICAgICAgICAuLi50aGlzLmZldGNoT3B0aW9ucyxcbiAgICAgICAgfSk7XG4gICAgICAgIGF3YWl0IHJhaXNlRm9yU3RhdHVzKHJlc3BvbnNlLCBcImNyZWF0ZSBjb21taXRcIik7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dldFByb21wdFVybChgJHtvd25lcn0vJHtwcm9tcHROYW1lfSR7cmVzdWx0LmNvbW1pdF9oYXNoID8gYDoke3Jlc3VsdC5jb21taXRfaGFzaH1gIDogXCJcIn1gKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBkYXRlIGV4YW1wbGVzIHdpdGggYXR0YWNobWVudHMgdXNpbmcgbXVsdGlwYXJ0IGZvcm0gZGF0YS5cbiAgICAgKiBAcGFyYW0gdXBkYXRlcyBMaXN0IG9mIEV4YW1wbGVVcGRhdGVXaXRoQXR0YWNobWVudHMgb2JqZWN0cyB0byB1cHNlcnRcbiAgICAgKiBAcmV0dXJucyBQcm9taXNlIHdpdGggdGhlIHVwZGF0ZSByZXNwb25zZVxuICAgICAqL1xuICAgIGFzeW5jIHVwZGF0ZUV4YW1wbGVzTXVsdGlwYXJ0KGRhdGFzZXRJZCwgdXBkYXRlcyA9IFtdKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl91cGRhdGVFeGFtcGxlc011bHRpcGFydChkYXRhc2V0SWQsIHVwZGF0ZXMpO1xuICAgIH1cbiAgICBhc3luYyBfdXBkYXRlRXhhbXBsZXNNdWx0aXBhcnQoZGF0YXNldElkLCB1cGRhdGVzID0gW10pIHtcbiAgICAgICAgaWYgKCEoYXdhaXQgdGhpcy5fZ2V0TXVsdGlQYXJ0U3VwcG9ydCgpKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiWW91ciBMYW5nU21pdGggdmVyc2lvbiBkb2VzIG5vdCBhbGxvdyB1c2luZyB0aGUgbXVsdGlwYXJ0IGV4YW1wbGVzIGVuZHBvaW50LCBwbGVhc2UgdXBkYXRlIHRvIHRoZSBsYXRlc3QgdmVyc2lvbi5cIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZm9ybURhdGEgPSBuZXcgRm9ybURhdGEoKTtcbiAgICAgICAgZm9yIChjb25zdCBleGFtcGxlIG9mIHVwZGF0ZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IGV4YW1wbGVJZCA9IGV4YW1wbGUuaWQ7XG4gICAgICAgICAgICAvLyBQcmVwYXJlIHRoZSBtYWluIGV4YW1wbGUgYm9keVxuICAgICAgICAgICAgY29uc3QgZXhhbXBsZUJvZHkgPSB7XG4gICAgICAgICAgICAgICAgLi4uKGV4YW1wbGUubWV0YWRhdGEgJiYgeyBtZXRhZGF0YTogZXhhbXBsZS5tZXRhZGF0YSB9KSxcbiAgICAgICAgICAgICAgICAuLi4oZXhhbXBsZS5zcGxpdCAmJiB7IHNwbGl0OiBleGFtcGxlLnNwbGl0IH0pLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIC8vIEFkZCBtYWluIGV4YW1wbGUgZGF0YVxuICAgICAgICAgICAgY29uc3Qgc3RyaW5naWZpZWRFeGFtcGxlID0gc2VyaWFsaXplUGF5bG9hZEZvclRyYWNpbmcoZXhhbXBsZUJvZHkpO1xuICAgICAgICAgICAgY29uc3QgZXhhbXBsZUJsb2IgPSBuZXcgQmxvYihbc3RyaW5naWZpZWRFeGFtcGxlXSwge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBmb3JtRGF0YS5hcHBlbmQoZXhhbXBsZUlkLCBleGFtcGxlQmxvYik7XG4gICAgICAgICAgICAvLyBBZGQgaW5wdXRzIGlmIHByZXNlbnRcbiAgICAgICAgICAgIGlmIChleGFtcGxlLmlucHV0cykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHN0cmluZ2lmaWVkSW5wdXRzID0gc2VyaWFsaXplUGF5bG9hZEZvclRyYWNpbmcoZXhhbXBsZS5pbnB1dHMpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGlucHV0c0Jsb2IgPSBuZXcgQmxvYihbc3RyaW5naWZpZWRJbnB1dHNdLCB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGZvcm1EYXRhLmFwcGVuZChgJHtleGFtcGxlSWR9LmlucHV0c2AsIGlucHV0c0Jsb2IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQWRkIG91dHB1dHMgaWYgcHJlc2VudFxuICAgICAgICAgICAgaWYgKGV4YW1wbGUub3V0cHV0cykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHN0cmluZ2lmaWVkT3V0cHV0cyA9IHNlcmlhbGl6ZVBheWxvYWRGb3JUcmFjaW5nKGV4YW1wbGUub3V0cHV0cyk7XG4gICAgICAgICAgICAgICAgY29uc3Qgb3V0cHV0c0Jsb2IgPSBuZXcgQmxvYihbc3RyaW5naWZpZWRPdXRwdXRzXSwge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBmb3JtRGF0YS5hcHBlbmQoYCR7ZXhhbXBsZUlkfS5vdXRwdXRzYCwgb3V0cHV0c0Jsb2IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQWRkIGF0dGFjaG1lbnRzIGlmIHByZXNlbnRcbiAgICAgICAgICAgIGlmIChleGFtcGxlLmF0dGFjaG1lbnRzKSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBbbmFtZSwgYXR0YWNobWVudF0gb2YgT2JqZWN0LmVudHJpZXMoZXhhbXBsZS5hdHRhY2htZW50cykpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG1pbWVUeXBlO1xuICAgICAgICAgICAgICAgICAgICBsZXQgZGF0YTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoYXR0YWNobWVudCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFttaW1lVHlwZSwgZGF0YV0gPSBhdHRhY2htZW50O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWltZVR5cGUgPSBhdHRhY2htZW50Lm1pbWVUeXBlO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YSA9IGF0dGFjaG1lbnQuZGF0YTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBhdHRhY2htZW50QmxvYiA9IG5ldyBCbG9iKFtkYXRhXSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogYCR7bWltZVR5cGV9OyBsZW5ndGg9JHtkYXRhLmJ5dGVMZW5ndGh9YCxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGZvcm1EYXRhLmFwcGVuZChgJHtleGFtcGxlSWR9LmF0dGFjaG1lbnQuJHtuYW1lfWAsIGF0dGFjaG1lbnRCbG9iKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZXhhbXBsZS5hdHRhY2htZW50c19vcGVyYXRpb25zKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3RyaW5naWZpZWRBdHRhY2htZW50c09wZXJhdGlvbnMgPSBzZXJpYWxpemVQYXlsb2FkRm9yVHJhY2luZyhleGFtcGxlLmF0dGFjaG1lbnRzX29wZXJhdGlvbnMpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGF0dGFjaG1lbnRzT3BlcmF0aW9uc0Jsb2IgPSBuZXcgQmxvYihbc3RyaW5naWZpZWRBdHRhY2htZW50c09wZXJhdGlvbnNdLCB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGZvcm1EYXRhLmFwcGVuZChgJHtleGFtcGxlSWR9LmF0dGFjaG1lbnRzX29wZXJhdGlvbnNgLCBhdHRhY2htZW50c09wZXJhdGlvbnNCbG9iKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkYXRhc2V0SWRUb1VzZSA9IGRhdGFzZXRJZCA/PyB1cGRhdGVzWzBdPy5kYXRhc2V0X2lkO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuY2FsbGVyLmNhbGwoX2dldEZldGNoSW1wbGVtZW50YXRpb24oKSwgYCR7dGhpcy5hcGlVcmx9L3YxL3BsYXRmb3JtL2RhdGFzZXRzLyR7ZGF0YXNldElkVG9Vc2V9L2V4YW1wbGVzYCwge1xuICAgICAgICAgICAgbWV0aG9kOiBcIlBBVENIXCIsXG4gICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICBib2R5OiBmb3JtRGF0YSxcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBsb2FkIGV4YW1wbGVzIHdpdGggYXR0YWNobWVudHMgdXNpbmcgbXVsdGlwYXJ0IGZvcm0gZGF0YS5cbiAgICAgKiBAcGFyYW0gdXBsb2FkcyBMaXN0IG9mIEV4YW1wbGVVcGxvYWRXaXRoQXR0YWNobWVudHMgb2JqZWN0cyB0byB1cGxvYWRcbiAgICAgKiBAcmV0dXJucyBQcm9taXNlIHdpdGggdGhlIHVwbG9hZCByZXNwb25zZVxuICAgICAqIEBkZXByZWNhdGVkIFRoaXMgbWV0aG9kIGlzIGRlcHJlY2F0ZWQgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiBmdXR1cmUgTGFuZ1NtaXRoIHZlcnNpb25zLCBwbGVhc2UgdXNlIGBjcmVhdGVFeGFtcGxlc2AgaW5zdGVhZFxuICAgICAqL1xuICAgIGFzeW5jIHVwbG9hZEV4YW1wbGVzTXVsdGlwYXJ0KGRhdGFzZXRJZCwgdXBsb2FkcyA9IFtdKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl91cGxvYWRFeGFtcGxlc011bHRpcGFydChkYXRhc2V0SWQsIHVwbG9hZHMpO1xuICAgIH1cbiAgICBhc3luYyBfdXBsb2FkRXhhbXBsZXNNdWx0aXBhcnQoZGF0YXNldElkLCB1cGxvYWRzID0gW10pIHtcbiAgICAgICAgaWYgKCEoYXdhaXQgdGhpcy5fZ2V0TXVsdGlQYXJ0U3VwcG9ydCgpKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiWW91ciBMYW5nU21pdGggdmVyc2lvbiBkb2VzIG5vdCBhbGxvdyB1c2luZyB0aGUgbXVsdGlwYXJ0IGV4YW1wbGVzIGVuZHBvaW50LCBwbGVhc2UgdXBkYXRlIHRvIHRoZSBsYXRlc3QgdmVyc2lvbi5cIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZm9ybURhdGEgPSBuZXcgRm9ybURhdGEoKTtcbiAgICAgICAgZm9yIChjb25zdCBleGFtcGxlIG9mIHVwbG9hZHMpIHtcbiAgICAgICAgICAgIGNvbnN0IGV4YW1wbGVJZCA9IChleGFtcGxlLmlkID8/IHV1aWQudjQoKSkudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIC8vIFByZXBhcmUgdGhlIG1haW4gZXhhbXBsZSBib2R5XG4gICAgICAgICAgICBjb25zdCBleGFtcGxlQm9keSA9IHtcbiAgICAgICAgICAgICAgICBjcmVhdGVkX2F0OiBleGFtcGxlLmNyZWF0ZWRfYXQsXG4gICAgICAgICAgICAgICAgLi4uKGV4YW1wbGUubWV0YWRhdGEgJiYgeyBtZXRhZGF0YTogZXhhbXBsZS5tZXRhZGF0YSB9KSxcbiAgICAgICAgICAgICAgICAuLi4oZXhhbXBsZS5zcGxpdCAmJiB7IHNwbGl0OiBleGFtcGxlLnNwbGl0IH0pLFxuICAgICAgICAgICAgICAgIC4uLihleGFtcGxlLnNvdXJjZV9ydW5faWQgJiYgeyBzb3VyY2VfcnVuX2lkOiBleGFtcGxlLnNvdXJjZV9ydW5faWQgfSksXG4gICAgICAgICAgICAgICAgLi4uKGV4YW1wbGUudXNlX3NvdXJjZV9ydW5faW8gJiYge1xuICAgICAgICAgICAgICAgICAgICB1c2Vfc291cmNlX3J1bl9pbzogZXhhbXBsZS51c2Vfc291cmNlX3J1bl9pbyxcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAuLi4oZXhhbXBsZS51c2Vfc291cmNlX3J1bl9hdHRhY2htZW50cyAmJiB7XG4gICAgICAgICAgICAgICAgICAgIHVzZV9zb3VyY2VfcnVuX2F0dGFjaG1lbnRzOiBleGFtcGxlLnVzZV9zb3VyY2VfcnVuX2F0dGFjaG1lbnRzLFxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIC8vIEFkZCBtYWluIGV4YW1wbGUgZGF0YVxuICAgICAgICAgICAgY29uc3Qgc3RyaW5naWZpZWRFeGFtcGxlID0gc2VyaWFsaXplUGF5bG9hZEZvclRyYWNpbmcoZXhhbXBsZUJvZHkpO1xuICAgICAgICAgICAgY29uc3QgZXhhbXBsZUJsb2IgPSBuZXcgQmxvYihbc3RyaW5naWZpZWRFeGFtcGxlXSwge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBmb3JtRGF0YS5hcHBlbmQoZXhhbXBsZUlkLCBleGFtcGxlQmxvYik7XG4gICAgICAgICAgICAvLyBBZGQgaW5wdXRzIGlmIHByZXNlbnRcbiAgICAgICAgICAgIGlmIChleGFtcGxlLmlucHV0cykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHN0cmluZ2lmaWVkSW5wdXRzID0gc2VyaWFsaXplUGF5bG9hZEZvclRyYWNpbmcoZXhhbXBsZS5pbnB1dHMpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGlucHV0c0Jsb2IgPSBuZXcgQmxvYihbc3RyaW5naWZpZWRJbnB1dHNdLCB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGZvcm1EYXRhLmFwcGVuZChgJHtleGFtcGxlSWR9LmlucHV0c2AsIGlucHV0c0Jsb2IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQWRkIG91dHB1dHMgaWYgcHJlc2VudFxuICAgICAgICAgICAgaWYgKGV4YW1wbGUub3V0cHV0cykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHN0cmluZ2lmaWVkT3V0cHV0cyA9IHNlcmlhbGl6ZVBheWxvYWRGb3JUcmFjaW5nKGV4YW1wbGUub3V0cHV0cyk7XG4gICAgICAgICAgICAgICAgY29uc3Qgb3V0cHV0c0Jsb2IgPSBuZXcgQmxvYihbc3RyaW5naWZpZWRPdXRwdXRzXSwge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBmb3JtRGF0YS5hcHBlbmQoYCR7ZXhhbXBsZUlkfS5vdXRwdXRzYCwgb3V0cHV0c0Jsb2IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQWRkIGF0dGFjaG1lbnRzIGlmIHByZXNlbnRcbiAgICAgICAgICAgIGlmIChleGFtcGxlLmF0dGFjaG1lbnRzKSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBbbmFtZSwgYXR0YWNobWVudF0gb2YgT2JqZWN0LmVudHJpZXMoZXhhbXBsZS5hdHRhY2htZW50cykpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG1pbWVUeXBlO1xuICAgICAgICAgICAgICAgICAgICBsZXQgZGF0YTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoYXR0YWNobWVudCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFttaW1lVHlwZSwgZGF0YV0gPSBhdHRhY2htZW50O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWltZVR5cGUgPSBhdHRhY2htZW50Lm1pbWVUeXBlO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YSA9IGF0dGFjaG1lbnQuZGF0YTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBhdHRhY2htZW50QmxvYiA9IG5ldyBCbG9iKFtkYXRhXSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogYCR7bWltZVR5cGV9OyBsZW5ndGg9JHtkYXRhLmJ5dGVMZW5ndGh9YCxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGZvcm1EYXRhLmFwcGVuZChgJHtleGFtcGxlSWR9LmF0dGFjaG1lbnQuJHtuYW1lfWAsIGF0dGFjaG1lbnRCbG9iKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmNhbGxlci5jYWxsKF9nZXRGZXRjaEltcGxlbWVudGF0aW9uKCksIGAke3RoaXMuYXBpVXJsfS92MS9wbGF0Zm9ybS9kYXRhc2V0cy8ke2RhdGFzZXRJZH0vZXhhbXBsZXNgLCB7XG4gICAgICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgYm9keTogZm9ybURhdGEsXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGFzeW5jIHVwZGF0ZVByb21wdChwcm9tcHRJZGVudGlmaWVyLCBvcHRpb25zKSB7XG4gICAgICAgIGlmICghKGF3YWl0IHRoaXMucHJvbXB0RXhpc3RzKHByb21wdElkZW50aWZpZXIpKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUHJvbXB0IGRvZXMgbm90IGV4aXN0LCB5b3UgbXVzdCBjcmVhdGUgaXQgZmlyc3QuXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IFtvd25lciwgcHJvbXB0TmFtZV0gPSBwYXJzZVByb21wdElkZW50aWZpZXIocHJvbXB0SWRlbnRpZmllcik7XG4gICAgICAgIGlmICghKGF3YWl0IHRoaXMuX2N1cnJlbnRUZW5hbnRJc093bmVyKG93bmVyKSkpIHtcbiAgICAgICAgICAgIHRocm93IGF3YWl0IHRoaXMuX293bmVyQ29uZmxpY3RFcnJvcihcInVwZGF0ZSBhIHByb21wdFwiLCBvd25lcik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAob3B0aW9ucz8uZGVzY3JpcHRpb24gIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHBheWxvYWQuZGVzY3JpcHRpb24gPSBvcHRpb25zLmRlc2NyaXB0aW9uO1xuICAgICAgICBpZiAob3B0aW9ucz8ucmVhZG1lICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICBwYXlsb2FkLnJlYWRtZSA9IG9wdGlvbnMucmVhZG1lO1xuICAgICAgICBpZiAob3B0aW9ucz8udGFncyAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgcGF5bG9hZC50YWdzID0gb3B0aW9ucy50YWdzO1xuICAgICAgICBpZiAob3B0aW9ucz8uaXNQdWJsaWMgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHBheWxvYWQuaXNfcHVibGljID0gb3B0aW9ucy5pc1B1YmxpYztcbiAgICAgICAgaWYgKG9wdGlvbnM/LmlzQXJjaGl2ZWQgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHBheWxvYWQuaXNfYXJjaGl2ZWQgPSBvcHRpb25zLmlzQXJjaGl2ZWQ7XG4gICAgICAgIC8vIENoZWNrIGlmIHBheWxvYWQgaXMgZW1wdHlcbiAgICAgICAgaWYgKE9iamVjdC5rZXlzKHBheWxvYWQpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gdmFsaWQgdXBkYXRlIG9wdGlvbnMgcHJvdmlkZWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmNhbGxlci5jYWxsKF9nZXRGZXRjaEltcGxlbWVudGF0aW9uKCksIGAke3RoaXMuYXBpVXJsfS9yZXBvcy8ke293bmVyfS8ke3Byb21wdE5hbWV9YCwge1xuICAgICAgICAgICAgbWV0aG9kOiBcIlBBVENIXCIsXG4gICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShwYXlsb2FkKSxcbiAgICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICAgICAuLi50aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2lnbmFsOiBBYm9ydFNpZ25hbC50aW1lb3V0KHRoaXMudGltZW91dF9tcyksXG4gICAgICAgICAgICAuLi50aGlzLmZldGNoT3B0aW9ucyxcbiAgICAgICAgfSk7XG4gICAgICAgIGF3YWl0IHJhaXNlRm9yU3RhdHVzKHJlc3BvbnNlLCBcInVwZGF0ZSBwcm9tcHRcIik7XG4gICAgICAgIHJldHVybiByZXNwb25zZS5qc29uKCk7XG4gICAgfVxuICAgIGFzeW5jIGRlbGV0ZVByb21wdChwcm9tcHRJZGVudGlmaWVyKSB7XG4gICAgICAgIGlmICghKGF3YWl0IHRoaXMucHJvbXB0RXhpc3RzKHByb21wdElkZW50aWZpZXIpKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUHJvbXB0IGRvZXMgbm90IGV4aXN0LCB5b3UgbXVzdCBjcmVhdGUgaXQgZmlyc3QuXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IFtvd25lciwgcHJvbXB0TmFtZSwgX10gPSBwYXJzZVByb21wdElkZW50aWZpZXIocHJvbXB0SWRlbnRpZmllcik7XG4gICAgICAgIGlmICghKGF3YWl0IHRoaXMuX2N1cnJlbnRUZW5hbnRJc093bmVyKG93bmVyKSkpIHtcbiAgICAgICAgICAgIHRocm93IGF3YWl0IHRoaXMuX293bmVyQ29uZmxpY3RFcnJvcihcImRlbGV0ZSBhIHByb21wdFwiLCBvd25lcik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmNhbGxlci5jYWxsKF9nZXRGZXRjaEltcGxlbWVudGF0aW9uKCksIGAke3RoaXMuYXBpVXJsfS9yZXBvcy8ke293bmVyfS8ke3Byb21wdE5hbWV9YCwge1xuICAgICAgICAgICAgbWV0aG9kOiBcIkRFTEVURVwiLFxuICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgc2lnbmFsOiBBYm9ydFNpZ25hbC50aW1lb3V0KHRoaXMudGltZW91dF9tcyksXG4gICAgICAgICAgICAuLi50aGlzLmZldGNoT3B0aW9ucyxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgfVxuICAgIGFzeW5jIHB1bGxQcm9tcHRDb21taXQocHJvbXB0SWRlbnRpZmllciwgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBbb3duZXIsIHByb21wdE5hbWUsIGNvbW1pdEhhc2hdID0gcGFyc2VQcm9tcHRJZGVudGlmaWVyKHByb21wdElkZW50aWZpZXIpO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuY2FsbGVyLmNhbGwoX2dldEZldGNoSW1wbGVtZW50YXRpb24oKSwgYCR7dGhpcy5hcGlVcmx9L2NvbW1pdHMvJHtvd25lcn0vJHtwcm9tcHROYW1lfS8ke2NvbW1pdEhhc2h9JHtvcHRpb25zPy5pbmNsdWRlTW9kZWwgPyBcIj9pbmNsdWRlX21vZGVsPXRydWVcIiA6IFwiXCJ9YCwge1xuICAgICAgICAgICAgbWV0aG9kOiBcIkdFVFwiLFxuICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgc2lnbmFsOiBBYm9ydFNpZ25hbC50aW1lb3V0KHRoaXMudGltZW91dF9tcyksXG4gICAgICAgICAgICAuLi50aGlzLmZldGNoT3B0aW9ucyxcbiAgICAgICAgfSk7XG4gICAgICAgIGF3YWl0IHJhaXNlRm9yU3RhdHVzKHJlc3BvbnNlLCBcInB1bGwgcHJvbXB0IGNvbW1pdFwiKTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgb3duZXIsXG4gICAgICAgICAgICByZXBvOiBwcm9tcHROYW1lLFxuICAgICAgICAgICAgY29tbWl0X2hhc2g6IHJlc3VsdC5jb21taXRfaGFzaCxcbiAgICAgICAgICAgIG1hbmlmZXN0OiByZXN1bHQubWFuaWZlc3QsXG4gICAgICAgICAgICBleGFtcGxlczogcmVzdWx0LmV4YW1wbGVzLFxuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBzaG91bGQgbm90IGJlIHVzZWQgZGlyZWN0bHksIHVzZSBgaW1wb3J0IHsgcHVsbCB9IGZyb20gXCJsYW5nY2hhaW4vaHViXCJgIGluc3RlYWQuXG4gICAgICogVXNpbmcgdGhpcyBtZXRob2QgZGlyZWN0bHkgcmV0dXJucyB0aGUgSlNPTiBzdHJpbmcgb2YgdGhlIHByb21wdCByYXRoZXIgdGhhbiBhIExhbmdDaGFpbiBvYmplY3QuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBhc3luYyBfcHVsbFByb21wdChwcm9tcHRJZGVudGlmaWVyLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IHByb21wdE9iamVjdCA9IGF3YWl0IHRoaXMucHVsbFByb21wdENvbW1pdChwcm9tcHRJZGVudGlmaWVyLCB7XG4gICAgICAgICAgICBpbmNsdWRlTW9kZWw6IG9wdGlvbnM/LmluY2x1ZGVNb2RlbCxcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHByb21wdCA9IEpTT04uc3RyaW5naWZ5KHByb21wdE9iamVjdC5tYW5pZmVzdCk7XG4gICAgICAgIHJldHVybiBwcm9tcHQ7XG4gICAgfVxuICAgIGFzeW5jIHB1c2hQcm9tcHQocHJvbXB0SWRlbnRpZmllciwgb3B0aW9ucykge1xuICAgICAgICAvLyBDcmVhdGUgb3IgdXBkYXRlIHByb21wdCBtZXRhZGF0YVxuICAgICAgICBpZiAoYXdhaXQgdGhpcy5wcm9tcHRFeGlzdHMocHJvbXB0SWRlbnRpZmllcikpIHtcbiAgICAgICAgICAgIGlmIChvcHRpb25zICYmIE9iamVjdC5rZXlzKG9wdGlvbnMpLnNvbWUoKGtleSkgPT4ga2V5ICE9PSBcIm9iamVjdFwiKSkge1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMudXBkYXRlUHJvbXB0KHByb21wdElkZW50aWZpZXIsIHtcbiAgICAgICAgICAgICAgICAgICAgZGVzY3JpcHRpb246IG9wdGlvbnM/LmRlc2NyaXB0aW9uLFxuICAgICAgICAgICAgICAgICAgICByZWFkbWU6IG9wdGlvbnM/LnJlYWRtZSxcbiAgICAgICAgICAgICAgICAgICAgdGFnczogb3B0aW9ucz8udGFncyxcbiAgICAgICAgICAgICAgICAgICAgaXNQdWJsaWM6IG9wdGlvbnM/LmlzUHVibGljLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5jcmVhdGVQcm9tcHQocHJvbXB0SWRlbnRpZmllciwge1xuICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBvcHRpb25zPy5kZXNjcmlwdGlvbixcbiAgICAgICAgICAgICAgICByZWFkbWU6IG9wdGlvbnM/LnJlYWRtZSxcbiAgICAgICAgICAgICAgICB0YWdzOiBvcHRpb25zPy50YWdzLFxuICAgICAgICAgICAgICAgIGlzUHVibGljOiBvcHRpb25zPy5pc1B1YmxpYyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICghb3B0aW9ucz8ub2JqZWN0KSB7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5fZ2V0UHJvbXB0VXJsKHByb21wdElkZW50aWZpZXIpO1xuICAgICAgICB9XG4gICAgICAgIC8vIENyZWF0ZSBhIGNvbW1pdCB3aXRoIHRoZSBuZXcgbWFuaWZlc3RcbiAgICAgICAgY29uc3QgdXJsID0gYXdhaXQgdGhpcy5jcmVhdGVDb21taXQocHJvbXB0SWRlbnRpZmllciwgb3B0aW9ucz8ub2JqZWN0LCB7XG4gICAgICAgICAgICBwYXJlbnRDb21taXRIYXNoOiBvcHRpb25zPy5wYXJlbnRDb21taXRIYXNoLFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHVybDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2xvbmUgYSBwdWJsaWMgZGF0YXNldCB0byB5b3VyIG93biBsYW5nc21pdGggdGVuYW50LlxuICAgICAqIFRoaXMgb3BlcmF0aW9uIGlzIGlkZW1wb3RlbnQuIElmIHlvdSBhbHJlYWR5IGhhdmUgYSBkYXRhc2V0IHdpdGggdGhlIGdpdmVuIG5hbWUsXG4gICAgICogdGhpcyBmdW5jdGlvbiB3aWxsIGRvIG5vdGhpbmcuXG4gIFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0b2tlbk9yVXJsIFRoZSB0b2tlbiBvZiB0aGUgcHVibGljIGRhdGFzZXQgdG8gY2xvbmUuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBBZGRpdGlvbmFsIG9wdGlvbnMgZm9yIGNsb25pbmcgdGhlIGRhdGFzZXQuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnNvdXJjZUFwaVVybF0gVGhlIFVSTCBvZiB0aGUgbGFuZ3NtaXRoIHNlcnZlciB3aGVyZSB0aGUgZGF0YSBpcyBob3N0ZWQuIERlZmF1bHRzIHRvIHRoZSBBUEkgVVJMIG9mIHlvdXIgY3VycmVudCBjbGllbnQuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmRhdGFzZXROYW1lXSBUaGUgbmFtZSBvZiB0aGUgZGF0YXNldCB0byBjcmVhdGUgaW4geW91ciB0ZW5hbnQuIERlZmF1bHRzIHRvIHRoZSBuYW1lIG9mIHRoZSBwdWJsaWMgZGF0YXNldC5cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn1cbiAgICAgKi9cbiAgICBhc3luYyBjbG9uZVB1YmxpY0RhdGFzZXQodG9rZW5PclVybCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIGNvbnN0IHsgc291cmNlQXBpVXJsID0gdGhpcy5hcGlVcmwsIGRhdGFzZXROYW1lIH0gPSBvcHRpb25zO1xuICAgICAgICBjb25zdCBbcGFyc2VkQXBpVXJsLCB0b2tlblV1aWRdID0gdGhpcy5wYXJzZVRva2VuT3JVcmwodG9rZW5PclVybCwgc291cmNlQXBpVXJsKTtcbiAgICAgICAgY29uc3Qgc291cmNlQ2xpZW50ID0gbmV3IENsaWVudCh7XG4gICAgICAgICAgICBhcGlVcmw6IHBhcnNlZEFwaVVybCxcbiAgICAgICAgICAgIC8vIFBsYWNlaG9sZGVyIEFQSSBrZXkgbm90IG5lZWRlZCBhbnltb3JlIGluIG1vc3QgY2FzZXMsIGJ1dFxuICAgICAgICAgICAgLy8gc29tZSBwcml2YXRlIGRlcGxveW1lbnRzIG1heSBoYXZlIEFQSSBrZXktYmFzZWQgcmF0ZSBsaW1pdGluZ1xuICAgICAgICAgICAgLy8gdGhhdCB3b3VsZCBjYXVzZSB0aGlzIHRvIGZhaWwgaWYgd2UgcHJvdmlkZSBubyB2YWx1ZS5cbiAgICAgICAgICAgIGFwaUtleTogXCJwbGFjZWhvbGRlclwiLFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgZHMgPSBhd2FpdCBzb3VyY2VDbGllbnQucmVhZFNoYXJlZERhdGFzZXQodG9rZW5VdWlkKTtcbiAgICAgICAgY29uc3QgZmluYWxEYXRhc2V0TmFtZSA9IGRhdGFzZXROYW1lIHx8IGRzLm5hbWU7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoYXdhaXQgdGhpcy5oYXNEYXRhc2V0KHsgZGF0YXNldElkOiBmaW5hbERhdGFzZXROYW1lIH0pKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coYERhdGFzZXQgJHtmaW5hbERhdGFzZXROYW1lfSBhbHJlYWR5IGV4aXN0cyBpbiB5b3VyIHRlbmFudC4gU2tpcHBpbmcuYCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChfKSB7XG4gICAgICAgICAgICAvLyBgLmhhc0RhdGFzZXRgIHdpbGwgdGhyb3cgYW4gZXJyb3IgaWYgdGhlIGRhdGFzZXQgZG9lcyBub3QgZXhpc3QuXG4gICAgICAgICAgICAvLyBuby1vcCBpbiB0aGF0IGNhc2VcbiAgICAgICAgfVxuICAgICAgICAvLyBGZXRjaCBleGFtcGxlcyBmaXJzdCwgdGhlbiBjcmVhdGUgdGhlIGRhdGFzZXRcbiAgICAgICAgY29uc3QgZXhhbXBsZXMgPSBhd2FpdCBzb3VyY2VDbGllbnQubGlzdFNoYXJlZEV4YW1wbGVzKHRva2VuVXVpZCk7XG4gICAgICAgIGNvbnN0IGRhdGFzZXQgPSBhd2FpdCB0aGlzLmNyZWF0ZURhdGFzZXQoZmluYWxEYXRhc2V0TmFtZSwge1xuICAgICAgICAgICAgZGVzY3JpcHRpb246IGRzLmRlc2NyaXB0aW9uLFxuICAgICAgICAgICAgZGF0YVR5cGU6IGRzLmRhdGFfdHlwZSB8fCBcImt2XCIsXG4gICAgICAgICAgICBpbnB1dHNTY2hlbWE6IGRzLmlucHV0c19zY2hlbWFfZGVmaW5pdGlvbiA/PyB1bmRlZmluZWQsXG4gICAgICAgICAgICBvdXRwdXRzU2NoZW1hOiBkcy5vdXRwdXRzX3NjaGVtYV9kZWZpbml0aW9uID8/IHVuZGVmaW5lZCxcbiAgICAgICAgfSk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLmNyZWF0ZUV4YW1wbGVzKHtcbiAgICAgICAgICAgICAgICBpbnB1dHM6IGV4YW1wbGVzLm1hcCgoZSkgPT4gZS5pbnB1dHMpLFxuICAgICAgICAgICAgICAgIG91dHB1dHM6IGV4YW1wbGVzLmZsYXRNYXAoKGUpID0+IChlLm91dHB1dHMgPyBbZS5vdXRwdXRzXSA6IFtdKSksXG4gICAgICAgICAgICAgICAgZGF0YXNldElkOiBkYXRhc2V0LmlkLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYEFuIGVycm9yIG9jY3VycmVkIHdoaWxlIGNyZWF0aW5nIGRhdGFzZXQgJHtmaW5hbERhdGFzZXROYW1lfS4gYCArXG4gICAgICAgICAgICAgICAgXCJZb3Ugc2hvdWxkIGRlbGV0ZSBpdCBtYW51YWxseS5cIik7XG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHBhcnNlVG9rZW5PclVybCh1cmxPclRva2VuLCBhcGlVcmwsIG51bVBhcnRzID0gMiwga2luZCA9IFwiZGF0YXNldFwiKSB7XG4gICAgICAgIC8vIFRyeSBwYXJzaW5nIGFzIFVVSURcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGFzc2VydFV1aWQodXJsT3JUb2tlbik7IC8vIFdpbGwgdGhyb3cgaWYgaXQncyBub3QgYSBVVUlELlxuICAgICAgICAgICAgcmV0dXJuIFthcGlVcmwsIHVybE9yVG9rZW5dO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChfKSB7XG4gICAgICAgICAgICAvLyBuby1vcCBpZiBpdCdzIG5vdCBhIHV1aWRcbiAgICAgICAgfVxuICAgICAgICAvLyBQYXJzZSBhcyBVUkxcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHBhcnNlZFVybCA9IG5ldyBVUkwodXJsT3JUb2tlbik7XG4gICAgICAgICAgICBjb25zdCBwYXRoUGFydHMgPSBwYXJzZWRVcmwucGF0aG5hbWVcbiAgICAgICAgICAgICAgICAuc3BsaXQoXCIvXCIpXG4gICAgICAgICAgICAgICAgLmZpbHRlcigocGFydCkgPT4gcGFydCAhPT0gXCJcIik7XG4gICAgICAgICAgICBpZiAocGF0aFBhcnRzLmxlbmd0aCA+PSBudW1QYXJ0cykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRva2VuVXVpZCA9IHBhdGhQYXJ0c1twYXRoUGFydHMubGVuZ3RoIC0gbnVtUGFydHNdO1xuICAgICAgICAgICAgICAgIHJldHVybiBbYXBpVXJsLCB0b2tlblV1aWRdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHB1YmxpYyAke2tpbmR9IFVSTDogJHt1cmxPclRva2VufWApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHB1YmxpYyAke2tpbmR9IFVSTCBvciB0b2tlbjogJHt1cmxPclRva2VufWApO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEF3YWl0cyBhbGwgcGVuZGluZyB0cmFjZSBiYXRjaGVzLiBVc2VmdWwgZm9yIGVudmlyb25tZW50cyB3aGVyZVxuICAgICAqIHlvdSBuZWVkIHRvIGJlIHN1cmUgdGhhdCBhbGwgdHJhY2luZyByZXF1ZXN0cyBmaW5pc2ggYmVmb3JlIGV4ZWN1dGlvbiBlbmRzLFxuICAgICAqIHN1Y2ggYXMgc2VydmVybGVzcyBlbnZpcm9ubWVudHMuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYFxuICAgICAqIGltcG9ydCB7IENsaWVudCB9IGZyb20gXCJsYW5nc21pdGhcIjtcbiAgICAgKlxuICAgICAqIGNvbnN0IGNsaWVudCA9IG5ldyBDbGllbnQoKTtcbiAgICAgKlxuICAgICAqIHRyeSB7XG4gICAgICogICAvLyBUcmFjaW5nIGhhcHBlbnMgaGVyZVxuICAgICAqICAgLi4uXG4gICAgICogfSBmaW5hbGx5IHtcbiAgICAgKiAgIGF3YWl0IGNsaWVudC5hd2FpdFBlbmRpbmdUcmFjZUJhdGNoZXMoKTtcbiAgICAgKiB9XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBBIHByb21pc2UgdGhhdCByZXNvbHZlcyBvbmNlIGFsbCBjdXJyZW50bHkgcGVuZGluZyB0cmFjZXMgaGF2ZSBzZW50LlxuICAgICAqL1xuICAgIGF3YWl0UGVuZGluZ1RyYWNlQmF0Y2hlcygpIHtcbiAgICAgICAgaWYgKHRoaXMubWFudWFsRmx1c2hNb2RlKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCJbV0FSTklOR106IFdoZW4gdHJhY2luZyBpbiBtYW51YWwgZmx1c2ggbW9kZSwgeW91IG11c3QgY2FsbCBgYXdhaXQgY2xpZW50LmZsdXNoKClgIG1hbnVhbGx5IHRvIHN1Ym1pdCB0cmFjZSBiYXRjaGVzLlwiKTtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwoW1xuICAgICAgICAgICAgLi4udGhpcy5hdXRvQmF0Y2hRdWV1ZS5pdGVtcy5tYXAoKHsgaXRlbVByb21pc2UgfSkgPT4gaXRlbVByb21pc2UpLFxuICAgICAgICAgICAgdGhpcy5iYXRjaEluZ2VzdENhbGxlci5xdWV1ZS5vbklkbGUoKSxcbiAgICAgICAgXSk7XG4gICAgfVxufVxuZnVuY3Rpb24gaXNFeGFtcGxlQ3JlYXRlKGlucHV0KSB7XG4gICAgcmV0dXJuIFwiZGF0YXNldF9pZFwiIGluIGlucHV0IHx8IFwiZGF0YXNldF9uYW1lXCIgaW4gaW5wdXQ7XG59XG4iXSwibmFtZXMiOlsidXVpZCIsIkFzeW5jQ2FsbGVyIiwiY29udmVydExhbmdDaGFpbk1lc3NhZ2VUb0V4YW1wbGUiLCJpc0xhbmdDaGFpbk1lc3NhZ2UiLCJnZXRFbnZpcm9ubWVudFZhcmlhYmxlIiwiZ2V0TGFuZ0NoYWluRW52VmFyc01ldGFkYXRhIiwiZ2V0TGFuZ1NtaXRoRW52aXJvbm1lbnRWYXJpYWJsZSIsImdldFJ1bnRpbWVFbnZpcm9ubWVudCIsIl9fdmVyc2lvbl9fIiwiYXNzZXJ0VXVpZCIsIndhcm5PbmNlIiwicGFyc2VQcm9tcHRJZGVudGlmaWVyIiwicmFpc2VGb3JTdGF0dXMiLCJfZ2V0RmV0Y2hJbXBsZW1lbnRhdGlvbiIsInNlcmlhbGl6ZSIsInNlcmlhbGl6ZVBheWxvYWRGb3JUcmFjaW5nIiwibWVyZ2VSdW50aW1lRW52SW50b1J1bkNyZWF0ZSIsInJ1biIsInJ1bnRpbWVFbnYiLCJlbnZWYXJzIiwiZXh0cmEiLCJtZXRhZGF0YSIsInJ1bnRpbWUiLCJyZXZpc2lvbl9pZCIsImdldFRyYWNpbmdTYW1wbGluZ1JhdGUiLCJjb25maWdSYXRlIiwic2FtcGxpbmdSYXRlU3RyIiwidG9TdHJpbmciLCJ1bmRlZmluZWQiLCJzYW1wbGluZ1JhdGUiLCJwYXJzZUZsb2F0IiwiRXJyb3IiLCJpc0xvY2FsaG9zdCIsInVybCIsInN0cmlwcGVkVXJsIiwicmVwbGFjZSIsImhvc3RuYW1lIiwic3BsaXQiLCJ0b0FycmF5IiwiaXRlcmFibGUiLCJyZXN1bHQiLCJpdGVtIiwicHVzaCIsInRyaW1RdW90ZXMiLCJzdHIiLCJ0cmltIiwiaGFuZGxlNDI5IiwicmVzcG9uc2UiLCJzdGF0dXMiLCJyZXRyeUFmdGVyIiwicGFyc2VJbnQiLCJoZWFkZXJzIiwiZ2V0IiwiUHJvbWlzZSIsInJlc29sdmUiLCJzZXRUaW1lb3V0IiwiX2Zvcm1hdEZlZWRiYWNrU2NvcmUiLCJzY29yZSIsIk51bWJlciIsInRvRml4ZWQiLCJBdXRvQmF0Y2hRdWV1ZSIsImNvbnN0cnVjdG9yIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJlbnVtZXJhYmxlIiwiY29uZmlndXJhYmxlIiwid3JpdGFibGUiLCJ2YWx1ZSIsInBlZWsiLCJpdGVtcyIsIml0ZW1Qcm9taXNlUmVzb2x2ZSIsIml0ZW1Qcm9taXNlIiwic2l6ZSIsImxlbmd0aCIsImFjdGlvbiIsInBheWxvYWQiLCJzaXplQnl0ZXMiLCJwb3AiLCJ1cFRvU2l6ZUJ5dGVzIiwicG9wcGVkIiwicG9wcGVkU2l6ZUJ5dGVzIiwic2hpZnQiLCJtYXAiLCJpdCIsImZvckVhY2giLCJERUZBVUxUX0JBVENIX1NJWkVfTElNSVRfQllURVMiLCJTRVJWRVJfSU5GT19SRVFVRVNUX1RJTUVPVVQiLCJDbGllbnQiLCJjb25maWciLCJTZXQiLCJkZWZhdWx0Q29uZmlnIiwiZ2V0RGVmYXVsdENsaWVudENvbmZpZyIsInRyYWNpbmdTYW1wbGVSYXRlIiwidHJhY2luZ1NhbXBsaW5nUmF0ZSIsImFwaVVybCIsImVuZHNXaXRoIiwic2xpY2UiLCJhcGlLZXkiLCJ3ZWJVcmwiLCJ0aW1lb3V0X21zIiwiY2FsbGVyIiwiY2FsbGVyT3B0aW9ucyIsInRyYWNlQmF0Y2hDb25jdXJyZW5jeSIsImJhdGNoSW5nZXN0Q2FsbGVyIiwibWF4UmV0cmllcyIsIm1heENvbmN1cnJlbmN5Iiwib25GYWlsZWRSZXNwb25zZUhvb2siLCJoaWRlSW5wdXRzIiwiYW5vbnltaXplciIsImhpZGVPdXRwdXRzIiwiYXV0b0JhdGNoVHJhY2luZyIsImJsb2NrT25Sb290UnVuRmluYWxpemF0aW9uIiwiYmF0Y2hTaXplQnl0ZXNMaW1pdCIsImZldGNoT3B0aW9ucyIsIm1hbnVhbEZsdXNoTW9kZSIsImdldEhvc3RVcmwiLCJpbmNsdWRlcyIsInByb2Nlc3NJbnB1dHMiLCJpbnB1dHMiLCJwcm9jZXNzT3V0cHV0cyIsIm91dHB1dHMiLCJwcmVwYXJlUnVuQ3JlYXRlT3JVcGRhdGVJbnB1dHMiLCJydW5QYXJhbXMiLCJfZ2V0UmVzcG9uc2UiLCJwYXRoIiwicXVlcnlQYXJhbXMiLCJwYXJhbXNTdHJpbmciLCJjYWxsIiwibWV0aG9kIiwic2lnbmFsIiwiQWJvcnRTaWduYWwiLCJ0aW1lb3V0IiwiX2dldCIsImpzb24iLCJfZ2V0UGFnaW5hdGVkIiwiVVJMU2VhcmNoUGFyYW1zIiwidHJhbnNmb3JtIiwib2Zmc2V0IiwibGltaXQiLCJzZXQiLCJTdHJpbmciLCJfZ2V0Q3Vyc29yUGFnaW5hdGVkTGlzdCIsImJvZHkiLCJyZXF1ZXN0TWV0aG9kIiwiZGF0YUtleSIsImJvZHlQYXJhbXMiLCJKU09OIiwic3RyaW5naWZ5IiwicmVzcG9uc2VCb2R5IiwiY3Vyc29ycyIsIm5leHQiLCJjdXJzb3IiLCJfc2hvdWxkU2FtcGxlIiwiTWF0aCIsInJhbmRvbSIsIl9maWx0ZXJGb3JTYW1wbGluZyIsInJ1bnMiLCJwYXRjaCIsInNhbXBsZWQiLCJmaWx0ZXJlZFBvc3RVdWlkcyIsImhhcyIsImlkIiwiZGVsZXRlIiwidHJhY2VJZCIsInRyYWNlX2lkIiwiYWRkIiwiX2dldEJhdGNoU2l6ZUxpbWl0Qnl0ZXMiLCJzZXJ2ZXJJbmZvIiwiX2Vuc3VyZVNlcnZlckluZm8iLCJiYXRjaF9pbmdlc3RfY29uZmlnIiwic2l6ZV9saW1pdF9ieXRlcyIsIl9nZXRNdWx0aVBhcnRTdXBwb3J0IiwiaW5zdGFuY2VfZmxhZ3MiLCJkYXRhc2V0X2V4YW1wbGVzX211bHRpcGFydF9lbmFibGVkIiwiZHJhaW5BdXRvQmF0Y2hRdWV1ZSIsImJhdGNoU2l6ZUxpbWl0IiwicHJvbWlzZXMiLCJhdXRvQmF0Y2hRdWV1ZSIsImJhdGNoIiwiZG9uZSIsImJhdGNoUHJvbWlzZSIsIl9wcm9jZXNzQmF0Y2giLCJjYXRjaCIsImNvbnNvbGUiLCJlcnJvciIsImFsbCIsImluZ2VzdFBhcmFtcyIsInJ1bkNyZWF0ZXMiLCJmaWx0ZXIiLCJydW5VcGRhdGVzIiwidXNlX211bHRpcGFydF9lbmRwb2ludCIsIm11bHRpcGFydEluZ2VzdFJ1bnMiLCJiYXRjaEluZ2VzdFJ1bnMiLCJwcm9jZXNzUnVuT3BlcmF0aW9uIiwiY2xlYXJUaW1lb3V0IiwiYXV0b0JhdGNoVGltZW91dCIsInNpemVMaW1pdEJ5dGVzIiwiYXV0b0JhdGNoQWdncmVnYXRpb25EZWxheU1zIiwiX2dldFNlcnZlckluZm8iLCJBY2NlcHQiLCJfZ2V0U2VydmVySW5mb1Byb21pc2UiLCJfc2VydmVySW5mbyIsImUiLCJ3YXJuIiwidGhlbiIsIl9nZXRTZXR0aW5ncyIsInNldHRpbmdzIiwiZmx1c2giLCJjcmVhdGVSdW4iLCJzZXNzaW9uX25hbWUiLCJwcm9qZWN0X25hbWUiLCJydW5DcmVhdGUiLCJzdGFydF90aW1lIiwiRGF0ZSIsIm5vdyIsImRvdHRlZF9vcmRlciIsIm1lcmdlZFJ1bkNyZWF0ZVBhcmFtIiwicHJlcGFyZWRDcmVhdGVQYXJhbXMiLCJjcmVhdGUiLCJwcmVwYXJlZFVwZGF0ZVBhcmFtcyIsInVwZGF0ZSIsImNyZWF0ZUJ5SWQiLCJyZWR1Y2UiLCJwYXJhbXMiLCJzdGFuZGFsb25lVXBkYXRlcyIsInVwZGF0ZVBhcmFtIiwidmFsdWVzIiwicmF3QmF0Y2giLCJwb3N0IiwiYmF0Y2hDaHVua3MiLCJrIiwia2V5IiwiYmF0Y2hJdGVtcyIsInJldmVyc2UiLCJiYXRjaEl0ZW0iLCJfcG9zdEJhdGNoSW5nZXN0UnVucyIsImFsbEF0dGFjaG1lbnRzIiwicHJlcGFyZWRDcmVhdGUiLCJhdHRhY2htZW50cyIsImludmFsaWRSdW5DcmVhdGUiLCJmaW5kIiwiaW52YWxpZFJ1blVwZGF0ZSIsInJ1blVwZGF0ZSIsImFjY3VtdWxhdGVkQ29udGV4dCIsImFjY3VtdWxhdGVkUGFydHMiLCJwYXlsb2FkcyIsIm9yaWdpbmFsUGF5bG9hZCIsImV2ZW50cyIsImZpZWxkcyIsInN0cmluZ2lmaWVkUGF5bG9hZCIsIm5hbWUiLCJCbG9iIiwidHlwZSIsImVudHJpZXMiLCJzdHJpbmdpZmllZFZhbHVlIiwiYXR0YWNobWVudCIsImNvbnRlbnRUeXBlIiwiY29udGVudCIsIkFycmF5IiwiaXNBcnJheSIsIm1pbWVUeXBlIiwiZGF0YSIsImJ5dGVMZW5ndGgiLCJfc2VuZE11bHRpcGFydFJlcXVlc3QiLCJqb2luIiwicGFydHMiLCJjb250ZXh0IiwiYm91bmRhcnkiLCJjaHVua3MiLCJwYXJ0IiwiYXJyYXlCdWZmZXIiLCJyZXMiLCJtZXNzYWdlIiwidXBkYXRlUnVuIiwicnVuSWQiLCJlbmRfdGltZSIsInBhcmVudF9ydW5faWQiLCJyZWFkUnVuIiwibG9hZENoaWxkUnVucyIsImNoaWxkX3J1bl9pZHMiLCJfbG9hZENoaWxkUnVucyIsImdldFJ1blVybCIsInByb2plY3RPcHRzIiwic2Vzc2lvbklkIiwic2Vzc2lvbl9pZCIsInByb2plY3ROYW1lIiwicmVhZFByb2plY3QiLCJwcm9qZWN0SWQiLCJwcm9qZWN0IiwidGVuYW50SWQiLCJfZ2V0VGVuYW50SWQiLCJydW5fIiwiYXBwX3BhdGgiLCJiYXNlVXJsIiwiY2hpbGRSdW5zIiwibGlzdFJ1bnMiLCJ0cmVlbWFwIiwic29ydCIsImEiLCJiIiwibG9jYWxlQ29tcGFyZSIsImNoaWxkUnVuIiwiY2hpbGRfcnVucyIsInByb3BzIiwicGFyZW50UnVuSWQiLCJyZWZlcmVuY2VFeGFtcGxlSWQiLCJzdGFydFRpbWUiLCJleGVjdXRpb25PcmRlciIsImlzUm9vdCIsInJ1blR5cGUiLCJxdWVyeSIsInRyYWNlRmlsdGVyIiwidHJlZUZpbHRlciIsInNlbGVjdCIsInByb2plY3RJZHMiLCJwcm9qZWN0TmFtZXMiLCJwcm9qZWN0SWRzXyIsImRlZmF1bHRfc2VsZWN0Iiwic2Vzc2lvbiIsInJ1bl90eXBlIiwicmVmZXJlbmNlX2V4YW1wbGUiLCJ0cmFjZV9maWx0ZXIiLCJ0cmVlX2ZpbHRlciIsImV4ZWN1dGlvbl9vcmRlciIsInBhcmVudF9ydW4iLCJ0b0lTT1N0cmluZyIsInRyYWNlIiwiaXNfcm9vdCIsInJ1bnNZaWVsZGVkIiwibmV3UnVucyIsImdldFJ1blN0YXRzIiwicGFyZW50UnVuIiwicmVmZXJlbmNlRXhhbXBsZUlkcyIsImVuZFRpbWUiLCJkYXRhU291cmNlVHlwZSIsImRhdGFfc291cmNlX3R5cGUiLCJmaWx0ZXJlZFBheWxvYWQiLCJmcm9tRW50cmllcyIsIl8iLCJzaGFyZVJ1biIsInNoYXJlSWQiLCJydW5faWQiLCJzaGFyZV90b2tlbiIsInY0IiwidW5zaGFyZVJ1biIsInJlYWRSdW5TaGFyZWRMaW5rIiwibGlzdFNoYXJlZFJ1bnMiLCJzaGFyZVRva2VuIiwicnVuSWRzIiwiYXBwZW5kIiwicmVhZERhdGFzZXRTaGFyZWRTY2hlbWEiLCJkYXRhc2V0SWQiLCJkYXRhc2V0TmFtZSIsImRhdGFzZXQiLCJyZWFkRGF0YXNldCIsInNoYXJlU2NoZW1hIiwic2hhcmVEYXRhc2V0IiwiZGF0YXNldF9pZCIsInVuc2hhcmVEYXRhc2V0IiwicmVhZFNoYXJlZERhdGFzZXQiLCJsaXN0U2hhcmVkRXhhbXBsZXMiLCJvcHRpb25zIiwiZXhhbXBsZUlkcyIsInVybFBhcmFtcyIsInYiLCJvayIsImRldGFpbCIsInN0YXR1c1RleHQiLCJleGFtcGxlIiwiX2hvc3RVcmwiLCJjcmVhdGVQcm9qZWN0IiwiZGVzY3JpcHRpb24iLCJ1cHNlcnQiLCJwcm9qZWN0RXh0cmEiLCJyZWZlcmVuY2VEYXRhc2V0SWQiLCJ1cHNlcnRfIiwiZW5kcG9pbnQiLCJ1cGRhdGVQcm9qZWN0IiwiaGFzUHJvamVjdCIsImluY2x1ZGVTdGF0cyIsImdldFByb2plY3RVcmwiLCJnZXREYXRhc2V0VXJsIiwiX3RlbmFudElkIiwicHJvamVjdHMiLCJ0ZW5hbnRfaWQiLCJsaXN0UHJvamVjdHMiLCJuYW1lQ29udGFpbnMiLCJyZWZlcmVuY2VEYXRhc2V0TmFtZSIsInJlZmVyZW5jZUZyZWUiLCJkZWxldGVQcm9qZWN0IiwicHJvamVjdElkXyIsInVwbG9hZENzdiIsImNzdkZpbGUiLCJmaWxlTmFtZSIsImlucHV0S2V5cyIsIm91dHB1dEtleXMiLCJkYXRhVHlwZSIsImZvcm1EYXRhIiwiRm9ybURhdGEiLCJjcmVhdGVEYXRhc2V0IiwiaW5wdXRzU2NoZW1hIiwib3V0cHV0c1NjaGVtYSIsImRhdGFfdHlwZSIsImlucHV0c19zY2hlbWFfZGVmaW5pdGlvbiIsIm91dHB1dHNfc2NoZW1hX2RlZmluaXRpb24iLCJoYXNEYXRhc2V0IiwidG9Mb2NhbGVMb3dlckNhc2UiLCJkaWZmRGF0YXNldFZlcnNpb25zIiwiZnJvbVZlcnNpb24iLCJ0b1ZlcnNpb24iLCJkYXRhc2V0SWRfIiwiZnJvbV92ZXJzaW9uIiwidG9fdmVyc2lvbiIsInJlYWREYXRhc2V0T3BlbmFpRmluZXR1bmluZyIsImRhdGFzZXRUZXh0IiwidGV4dCIsImxpbmUiLCJwYXJzZSIsImxpc3REYXRhc2V0cyIsImRhdGFzZXRJZHMiLCJkYXRhc2V0TmFtZUNvbnRhaW5zIiwiaWRfIiwiZGF0YXNldHMiLCJ1cGRhdGVEYXRhc2V0IiwiX2RhdGFzZXRJZCIsInVwZGF0ZURhdGFzZXRUYWciLCJhc09mIiwidGFnIiwiYXNfb2YiLCJkZWxldGVEYXRhc2V0IiwiaW5kZXhEYXRhc2V0Iiwic2ltaWxhckV4YW1wbGVzIiwiY3JlYXRlRXhhbXBsZSIsImlucHV0c09yVXBkYXRlIiwiaXNFeGFtcGxlQ3JlYXRlIiwiZGF0YXNldE5hbWVfIiwiZGF0YXNldF9uYW1lIiwiY3JlYXRlZEF0XyIsImNyZWF0ZWRBdCIsImNyZWF0ZWRfYXQiLCJleGFtcGxlSWQiLCJzb3VyY2VfcnVuX2lkIiwic291cmNlUnVuSWQiLCJ1c2Vfc291cmNlX3J1bl9pbyIsInVzZVNvdXJjZVJ1bklPIiwidXNlX3NvdXJjZV9ydW5fYXR0YWNobWVudHMiLCJ1c2VTb3VyY2VSdW5BdHRhY2htZW50cyIsIl91cGxvYWRFeGFtcGxlc011bHRpcGFydCIsInJlYWRFeGFtcGxlIiwiZXhhbXBsZV9pZHMiLCJjcmVhdGVFeGFtcGxlcyIsInByb3BzT3JVcGxvYWRzIiwidXBsb2FkcyIsImV4YW1wbGVzIiwic3BsaXRzIiwic291cmNlUnVuSWRzIiwidXNlU291cmNlUnVuSU9zIiwiZm9ybWF0dGVkRXhhbXBsZXMiLCJpbnB1dCIsImlkeCIsImNyZWF0ZUxMTUV4YW1wbGUiLCJnZW5lcmF0aW9uIiwib3V0cHV0IiwiY3JlYXRlQ2hhdEV4YW1wbGUiLCJnZW5lcmF0aW9ucyIsImZpbmFsSW5wdXQiLCJmaW5hbE91dHB1dCIsInJhd0V4YW1wbGUiLCJhdHRhY2htZW50X3VybHMiLCJyZXN0IiwiYWNjIiwicHJlc2lnbmVkX3VybCIsIm1pbWVfdHlwZSIsImxpc3RFeGFtcGxlcyIsImlubGluZVMzVXJscyIsImluY2x1ZGVBdHRhY2htZW50cyIsImRhdGFzZXRfdmVyc2lvbiIsImlubGluZVMzVXJsc18iLCJzZXJpYWxpemVkTWV0YWRhdGEiLCJmaWVsZCIsImkiLCJyYXdFeGFtcGxlcyIsImRlbGV0ZUV4YW1wbGUiLCJ1cGRhdGVFeGFtcGxlIiwiZXhhbXBsZUlkT3JVcGRhdGUiLCJ1cGRhdGVUb1VzZSIsIl91cGRhdGVFeGFtcGxlc011bHRpcGFydCIsInVwZGF0ZUV4YW1wbGVzIiwicmVhZERhdGFzZXRWZXJzaW9uIiwicmVzb2x2ZWREYXRhc2V0SWQiLCJsaXN0RGF0YXNldFNwbGl0cyIsInVwZGF0ZURhdGFzZXRTcGxpdHMiLCJzcGxpdE5hbWUiLCJyZW1vdmUiLCJzcGxpdF9uYW1lIiwiZXZhbHVhdGVSdW4iLCJldmFsdWF0b3IiLCJzb3VyY2VJbmZvIiwicmVmZXJlbmNlRXhhbXBsZSIsInJlZmVyZW5jZV9leGFtcGxlX2lkIiwiZmVlZGJhY2tSZXN1bHQiLCJmZWVkYmFja3MiLCJfbG9nRXZhbHVhdGlvbkZlZWRiYWNrIiwiY3JlYXRlRmVlZGJhY2siLCJjb3JyZWN0aW9uIiwiY29tbWVudCIsImZlZWRiYWNrU291cmNlVHlwZSIsImZlZWRiYWNrSWQiLCJmZWVkYmFja0NvbmZpZyIsImNvbXBhcmF0aXZlRXhwZXJpbWVudElkIiwiZmVlZGJhY2tfc291cmNlIiwiZmVlZGJhY2siLCJjb21wYXJhdGl2ZV9leHBlcmltZW50X2lkIiwidXBkYXRlRmVlZGJhY2siLCJmZWVkYmFja1VwZGF0ZSIsInJlYWRGZWVkYmFjayIsImRlbGV0ZUZlZWRiYWNrIiwibGlzdEZlZWRiYWNrIiwiZmVlZGJhY2tLZXlzIiwiZmVlZGJhY2tTb3VyY2VUeXBlcyIsImNyZWF0ZVByZXNpZ25lZEZlZWRiYWNrVG9rZW4iLCJmZWVkYmFja0tleSIsImV4cGlyYXRpb24iLCJmZWVkYmFja19rZXkiLCJmZWVkYmFja19jb25maWciLCJob3VycyIsIm1pbnV0ZXMiLCJkYXlzIiwiY3JlYXRlQ29tcGFyYXRpdmVFeHBlcmltZW50IiwiZXhwZXJpbWVudElkcyIsInJlZmVyZW5jZV9kYXRhc2V0X2lkIiwiZXhwZXJpbWVudF9pZHMiLCJsaXN0UHJlc2lnbmVkRmVlZGJhY2tUb2tlbnMiLCJ0b2tlbnMiLCJfc2VsZWN0RXZhbFJlc3VsdHMiLCJyZXN1bHRzIiwicmVzdWx0c18iLCJldmFsdWF0b3JSZXNwb25zZSIsImV2YWxSZXN1bHRzIiwic291cmNlSW5mb18iLCJldmFsdWF0b3JJbmZvIiwicnVuSWRfIiwidGFyZ2V0UnVuSWQiLCJsb2dFdmFsdWF0aW9uRmVlZGJhY2siLCJsaXN0QW5ub3RhdGlvblF1ZXVlcyIsInF1ZXVlSWRzIiwibWluIiwiY291bnQiLCJxdWV1ZXMiLCJjcmVhdGVBbm5vdGF0aW9uUXVldWUiLCJxdWV1ZUlkIiwicmVhZEFubm90YXRpb25RdWV1ZSIsInF1ZXVlSXRlcmF0b3JSZXN1bHQiLCJ1cGRhdGVBbm5vdGF0aW9uUXVldWUiLCJkZWxldGVBbm5vdGF0aW9uUXVldWUiLCJhZGRSdW5zVG9Bbm5vdGF0aW9uUXVldWUiLCJnZXRSdW5Gcm9tQW5ub3RhdGlvblF1ZXVlIiwiaW5kZXgiLCJkZWxldGVSdW5Gcm9tQW5ub3RhdGlvblF1ZXVlIiwicXVldWVSdW5JZCIsImdldFNpemVGcm9tQW5ub3RhdGlvblF1ZXVlIiwiX2N1cnJlbnRUZW5hbnRJc093bmVyIiwib3duZXIiLCJ0ZW5hbnRfaGFuZGxlIiwiX293bmVyQ29uZmxpY3RFcnJvciIsIl9nZXRMYXRlc3RDb21taXRIYXNoIiwicHJvbXB0T3duZXJBbmROYW1lIiwic3RhdHVzQ29kZSIsImNvbW1pdHMiLCJjb21taXRfaGFzaCIsIl9saWtlT3JVbmxpa2VQcm9tcHQiLCJwcm9tcHRJZGVudGlmaWVyIiwibGlrZSIsInByb21wdE5hbWUiLCJfZ2V0UHJvbXB0VXJsIiwiY29tbWl0SGFzaCIsInN1YnN0cmluZyIsInByb21wdEV4aXN0cyIsInByb21wdCIsImdldFByb21wdCIsImxpa2VQcm9tcHQiLCJ1bmxpa2VQcm9tcHQiLCJsaXN0Q29tbWl0cyIsImxpc3RQcm9tcHRzIiwic29ydEZpZWxkIiwiaXNBcmNoaXZlZCIsImlzUHVibGljIiwicHJvbXB0cyIsInJlcG9zIiwicmVwbyIsImNyZWF0ZVByb21wdCIsInJlcG9faGFuZGxlIiwicmVhZG1lIiwidGFncyIsImlzX3B1YmxpYyIsImNyZWF0ZUNvbW1pdCIsIm9iamVjdCIsInJlc29sdmVkUGFyZW50Q29tbWl0SGFzaCIsInBhcmVudENvbW1pdEhhc2giLCJtYW5pZmVzdCIsInBhcmVudF9jb21taXQiLCJ1cGRhdGVFeGFtcGxlc011bHRpcGFydCIsInVwZGF0ZXMiLCJleGFtcGxlQm9keSIsInN0cmluZ2lmaWVkRXhhbXBsZSIsImV4YW1wbGVCbG9iIiwic3RyaW5naWZpZWRJbnB1dHMiLCJpbnB1dHNCbG9iIiwic3RyaW5naWZpZWRPdXRwdXRzIiwib3V0cHV0c0Jsb2IiLCJhdHRhY2htZW50QmxvYiIsImF0dGFjaG1lbnRzX29wZXJhdGlvbnMiLCJzdHJpbmdpZmllZEF0dGFjaG1lbnRzT3BlcmF0aW9ucyIsImF0dGFjaG1lbnRzT3BlcmF0aW9uc0Jsb2IiLCJkYXRhc2V0SWRUb1VzZSIsInVwbG9hZEV4YW1wbGVzTXVsdGlwYXJ0IiwidXBkYXRlUHJvbXB0IiwiaXNfYXJjaGl2ZWQiLCJrZXlzIiwiZGVsZXRlUHJvbXB0IiwicHVsbFByb21wdENvbW1pdCIsImluY2x1ZGVNb2RlbCIsIl9wdWxsUHJvbXB0IiwicHJvbXB0T2JqZWN0IiwicHVzaFByb21wdCIsInNvbWUiLCJjbG9uZVB1YmxpY0RhdGFzZXQiLCJ0b2tlbk9yVXJsIiwic291cmNlQXBpVXJsIiwicGFyc2VkQXBpVXJsIiwidG9rZW5VdWlkIiwicGFyc2VUb2tlbk9yVXJsIiwic291cmNlQ2xpZW50IiwiZHMiLCJmaW5hbERhdGFzZXROYW1lIiwibG9nIiwiZmxhdE1hcCIsInVybE9yVG9rZW4iLCJudW1QYXJ0cyIsImtpbmQiLCJwYXJzZWRVcmwiLCJVUkwiLCJwYXRoUGFydHMiLCJwYXRobmFtZSIsImF3YWl0UGVuZGluZ1RyYWNlQmF0Y2hlcyIsInF1ZXVlIiwib25JZGxlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/langsmith/dist/client.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/langsmith/dist/env.js":
/*!********************************************!*\
  !*** ./node_modules/langsmith/dist/env.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   isTracingEnabled: () => (/* binding */ isTracingEnabled)\n/* harmony export */ });\n/* harmony import */ var _utils_env_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils/env.js */ \"(rsc)/./node_modules/langsmith/dist/utils/env.js\");\n\nconst isTracingEnabled = (tracingEnabled)=>{\n    if (tracingEnabled !== undefined) {\n        return tracingEnabled;\n    }\n    const envVars = [\n        \"TRACING_V2\",\n        \"TRACING\"\n    ];\n    return !!envVars.find((envVar)=>(0,_utils_env_js__WEBPACK_IMPORTED_MODULE_0__.getLangSmithEnvironmentVariable)(envVar) === \"true\");\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL2Rpc3QvZW52LmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQWlFO0FBQzFELE1BQU1DLG1CQUFtQixDQUFDQztJQUM3QixJQUFJQSxtQkFBbUJDLFdBQVc7UUFDOUIsT0FBT0Q7SUFDWDtJQUNBLE1BQU1FLFVBQVU7UUFBQztRQUFjO0tBQVU7SUFDekMsT0FBTyxDQUFDLENBQUNBLFFBQVFDLElBQUksQ0FBQyxDQUFDQyxTQUFXTiw4RUFBK0JBLENBQUNNLFlBQVk7QUFDbEYsRUFBRSIsInNvdXJjZXMiOlsid2VicGFjazovL2FpLW1hcmtldC1yZXNlYXJjaC1hZ2VudC8uL25vZGVfbW9kdWxlcy9sYW5nc21pdGgvZGlzdC9lbnYuanM/ZTU5OSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBnZXRMYW5nU21pdGhFbnZpcm9ubWVudFZhcmlhYmxlIH0gZnJvbSBcIi4vdXRpbHMvZW52LmpzXCI7XG5leHBvcnQgY29uc3QgaXNUcmFjaW5nRW5hYmxlZCA9ICh0cmFjaW5nRW5hYmxlZCkgPT4ge1xuICAgIGlmICh0cmFjaW5nRW5hYmxlZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiB0cmFjaW5nRW5hYmxlZDtcbiAgICB9XG4gICAgY29uc3QgZW52VmFycyA9IFtcIlRSQUNJTkdfVjJcIiwgXCJUUkFDSU5HXCJdO1xuICAgIHJldHVybiAhIWVudlZhcnMuZmluZCgoZW52VmFyKSA9PiBnZXRMYW5nU21pdGhFbnZpcm9ubWVudFZhcmlhYmxlKGVudlZhcikgPT09IFwidHJ1ZVwiKTtcbn07XG4iXSwibmFtZXMiOlsiZ2V0TGFuZ1NtaXRoRW52aXJvbm1lbnRWYXJpYWJsZSIsImlzVHJhY2luZ0VuYWJsZWQiLCJ0cmFjaW5nRW5hYmxlZCIsInVuZGVmaW5lZCIsImVudlZhcnMiLCJmaW5kIiwiZW52VmFyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/langsmith/dist/env.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/langsmith/dist/index.js":
/*!**********************************************!*\
  !*** ./node_modules/langsmith/dist/index.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Client: () => (/* reexport safe */ _client_js__WEBPACK_IMPORTED_MODULE_0__.Client),\n/* harmony export */   RunTree: () => (/* reexport safe */ _run_trees_js__WEBPACK_IMPORTED_MODULE_1__.RunTree),\n/* harmony export */   __version__: () => (/* binding */ __version__),\n/* harmony export */   overrideFetchImplementation: () => (/* reexport safe */ _singletons_fetch_js__WEBPACK_IMPORTED_MODULE_2__.overrideFetchImplementation)\n/* harmony export */ });\n/* harmony import */ var _client_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./client.js */ \"(rsc)/./node_modules/langsmith/dist/client.js\");\n/* harmony import */ var _run_trees_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./run_trees.js */ \"(rsc)/./node_modules/langsmith/dist/run_trees.js\");\n/* harmony import */ var _singletons_fetch_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./singletons/fetch.js */ \"(rsc)/./node_modules/langsmith/dist/singletons/fetch.js\");\n\n\n\n// Update using yarn bump-version\nconst __version__ = \"0.3.15\";\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFzQztBQUNHO0FBQzJCO0FBQ3BFLGlDQUFpQztBQUMxQixNQUFNRyxjQUFjLFNBQVMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9haS1tYXJrZXQtcmVzZWFyY2gtYWdlbnQvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL2Rpc3QvaW5kZXguanM/YWEyOCJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgeyBDbGllbnQsIH0gZnJvbSBcIi4vY2xpZW50LmpzXCI7XG5leHBvcnQgeyBSdW5UcmVlIH0gZnJvbSBcIi4vcnVuX3RyZWVzLmpzXCI7XG5leHBvcnQgeyBvdmVycmlkZUZldGNoSW1wbGVtZW50YXRpb24gfSBmcm9tIFwiLi9zaW5nbGV0b25zL2ZldGNoLmpzXCI7XG4vLyBVcGRhdGUgdXNpbmcgeWFybiBidW1wLXZlcnNpb25cbmV4cG9ydCBjb25zdCBfX3ZlcnNpb25fXyA9IFwiMC4zLjE1XCI7XG4iXSwibmFtZXMiOlsiQ2xpZW50IiwiUnVuVHJlZSIsIm92ZXJyaWRlRmV0Y2hJbXBsZW1lbnRhdGlvbiIsIl9fdmVyc2lvbl9fIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/langsmith/dist/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/langsmith/dist/run_trees.js":
/*!**************************************************!*\
  !*** ./node_modules/langsmith/dist/run_trees.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   RunTree: () => (/* binding */ RunTree),\n/* harmony export */   convertToDottedOrderFormat: () => (/* binding */ convertToDottedOrderFormat),\n/* harmony export */   isRunTree: () => (/* binding */ isRunTree),\n/* harmony export */   isRunnableConfigLike: () => (/* binding */ isRunnableConfigLike)\n/* harmony export */ });\n/* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! uuid */ \"(rsc)/./node_modules/uuid/dist/esm-node/v4.js\");\n/* harmony import */ var _utils_env_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils/env.js */ \"(rsc)/./node_modules/langsmith/dist/utils/env.js\");\n/* harmony import */ var _client_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./client.js */ \"(rsc)/./node_modules/langsmith/dist/client.js\");\n/* harmony import */ var _env_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./env.js */ \"(rsc)/./node_modules/langsmith/dist/env.js\");\n/* harmony import */ var _utils_warn_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils/warn.js */ \"(rsc)/./node_modules/langsmith/dist/utils/warn.js\");\n/* harmony import */ var _singletons_constants_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./singletons/constants.js */ \"(rsc)/./node_modules/langsmith/dist/singletons/constants.js\");\n\n\n\n\n\n\nfunction stripNonAlphanumeric(input) {\n    return input.replace(/[-:.]/g, \"\");\n}\nfunction convertToDottedOrderFormat(epoch, runId, executionOrder = 1) {\n    // Date only has millisecond precision, so we use the microseconds to break\n    // possible ties, avoiding incorrect run order\n    const paddedOrder = executionOrder.toFixed(0).slice(0, 3).padStart(3, \"0\");\n    return stripNonAlphanumeric(`${new Date(epoch).toISOString().slice(0, -1)}${paddedOrder}Z`) + runId;\n}\n/**\n * Baggage header information\n */ class Baggage {\n    constructor(metadata, tags){\n        Object.defineProperty(this, \"metadata\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"tags\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.metadata = metadata;\n        this.tags = tags;\n    }\n    static fromHeader(value) {\n        const items = value.split(\",\");\n        let metadata = {};\n        let tags = [];\n        for (const item of items){\n            const [key, uriValue] = item.split(\"=\");\n            const value = decodeURIComponent(uriValue);\n            if (key === \"langsmith-metadata\") {\n                metadata = JSON.parse(value);\n            } else if (key === \"langsmith-tags\") {\n                tags = value.split(\",\");\n            }\n        }\n        return new Baggage(metadata, tags);\n    }\n    toHeader() {\n        const items = [];\n        if (this.metadata && Object.keys(this.metadata).length > 0) {\n            items.push(`langsmith-metadata=${encodeURIComponent(JSON.stringify(this.metadata))}`);\n        }\n        if (this.tags && this.tags.length > 0) {\n            items.push(`langsmith-tags=${encodeURIComponent(this.tags.join(\",\"))}`);\n        }\n        return items.join(\",\");\n    }\n}\nclass RunTree {\n    constructor(originalConfig){\n        Object.defineProperty(this, \"id\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"run_type\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"project_name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"parent_run\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"child_runs\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"start_time\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"end_time\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"extra\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"tags\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"error\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"serialized\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"inputs\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"outputs\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"reference_example_id\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"client\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"events\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"trace_id\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"dotted_order\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"tracingEnabled\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"execution_order\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"child_execution_order\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        /**\n         * Attachments associated with the run.\n         * Each entry is a tuple of [mime_type, bytes]\n         */ Object.defineProperty(this, \"attachments\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        // If you pass in a run tree directly, return a shallow clone\n        if (isRunTree(originalConfig)) {\n            Object.assign(this, {\n                ...originalConfig\n            });\n            return;\n        }\n        const defaultConfig = RunTree.getDefaultConfig();\n        const { metadata, ...config } = originalConfig;\n        const client = config.client ?? RunTree.getSharedClient();\n        const dedupedMetadata = {\n            ...metadata,\n            ...config?.extra?.metadata\n        };\n        config.extra = {\n            ...config.extra,\n            metadata: dedupedMetadata\n        };\n        Object.assign(this, {\n            ...defaultConfig,\n            ...config,\n            client\n        });\n        if (!this.trace_id) {\n            if (this.parent_run) {\n                this.trace_id = this.parent_run.trace_id ?? this.id;\n            } else {\n                this.trace_id = this.id;\n            }\n        }\n        this.execution_order ??= 1;\n        this.child_execution_order ??= 1;\n        if (!this.dotted_order) {\n            const currentDottedOrder = convertToDottedOrderFormat(this.start_time, this.id, this.execution_order);\n            if (this.parent_run) {\n                this.dotted_order = this.parent_run.dotted_order + \".\" + currentDottedOrder;\n            } else {\n                this.dotted_order = currentDottedOrder;\n            }\n        }\n    }\n    static getDefaultConfig() {\n        return {\n            id: uuid__WEBPACK_IMPORTED_MODULE_5__[\"default\"](),\n            run_type: \"chain\",\n            project_name: (0,_utils_env_js__WEBPACK_IMPORTED_MODULE_0__.getLangSmithEnvironmentVariable)(\"PROJECT\") ?? (0,_utils_env_js__WEBPACK_IMPORTED_MODULE_0__.getEnvironmentVariable)(\"LANGCHAIN_SESSION\") ?? // TODO: Deprecate\n            \"default\",\n            child_runs: [],\n            api_url: (0,_utils_env_js__WEBPACK_IMPORTED_MODULE_0__.getEnvironmentVariable)(\"LANGCHAIN_ENDPOINT\") ?? \"http://localhost:1984\",\n            api_key: (0,_utils_env_js__WEBPACK_IMPORTED_MODULE_0__.getEnvironmentVariable)(\"LANGCHAIN_API_KEY\"),\n            caller_options: {},\n            start_time: Date.now(),\n            serialized: {},\n            inputs: {},\n            extra: {}\n        };\n    }\n    static getSharedClient() {\n        if (!RunTree.sharedClient) {\n            RunTree.sharedClient = new _client_js__WEBPACK_IMPORTED_MODULE_1__.Client();\n        }\n        return RunTree.sharedClient;\n    }\n    createChild(config) {\n        const child_execution_order = this.child_execution_order + 1;\n        const child = new RunTree({\n            ...config,\n            parent_run: this,\n            project_name: this.project_name,\n            client: this.client,\n            tracingEnabled: this.tracingEnabled,\n            execution_order: child_execution_order,\n            child_execution_order: child_execution_order\n        });\n        // Copy context vars over into the new run tree.\n        if (_singletons_constants_js__WEBPACK_IMPORTED_MODULE_4__._LC_CONTEXT_VARIABLES_KEY in this) {\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            child[_singletons_constants_js__WEBPACK_IMPORTED_MODULE_4__._LC_CONTEXT_VARIABLES_KEY] = this[_singletons_constants_js__WEBPACK_IMPORTED_MODULE_4__._LC_CONTEXT_VARIABLES_KEY];\n        }\n        const LC_CHILD = Symbol.for(\"lc:child_config\");\n        const presentConfig = config.extra?.[LC_CHILD] ?? this.extra[LC_CHILD];\n        // tracing for LangChain is defined by the _parentRunId and runMap of the tracer\n        if (isRunnableConfigLike(presentConfig)) {\n            const newConfig = {\n                ...presentConfig\n            };\n            const callbacks = isCallbackManagerLike(newConfig.callbacks) ? newConfig.callbacks.copy?.() : undefined;\n            if (callbacks) {\n                // update the parent run id\n                Object.assign(callbacks, {\n                    _parentRunId: child.id\n                });\n                // only populate if we're in a newer LC.JS version\n                callbacks.handlers?.find(isLangChainTracerLike)?.updateFromRunTree?.(child);\n                newConfig.callbacks = callbacks;\n            }\n            child.extra[LC_CHILD] = newConfig;\n        }\n        // propagate child_execution_order upwards\n        const visited = new Set();\n        let current = this;\n        while(current != null && !visited.has(current.id)){\n            visited.add(current.id);\n            current.child_execution_order = Math.max(current.child_execution_order, child_execution_order);\n            current = current.parent_run;\n        }\n        this.child_runs.push(child);\n        return child;\n    }\n    async end(outputs, error, endTime = Date.now(), metadata) {\n        this.outputs = this.outputs ?? outputs;\n        this.error = this.error ?? error;\n        this.end_time = this.end_time ?? endTime;\n        if (metadata && Object.keys(metadata).length > 0) {\n            this.extra = this.extra ? {\n                ...this.extra,\n                metadata: {\n                    ...this.extra.metadata,\n                    ...metadata\n                }\n            } : {\n                metadata\n            };\n        }\n    }\n    _convertToCreate(run, runtimeEnv, excludeChildRuns = true) {\n        const runExtra = run.extra ?? {};\n        if (!runExtra.runtime) {\n            runExtra.runtime = {};\n        }\n        if (runtimeEnv) {\n            for (const [k, v] of Object.entries(runtimeEnv)){\n                if (!runExtra.runtime[k]) {\n                    runExtra.runtime[k] = v;\n                }\n            }\n        }\n        let child_runs;\n        let parent_run_id;\n        if (!excludeChildRuns) {\n            child_runs = run.child_runs.map((child_run)=>this._convertToCreate(child_run, runtimeEnv, excludeChildRuns));\n            parent_run_id = undefined;\n        } else {\n            parent_run_id = run.parent_run?.id;\n            child_runs = [];\n        }\n        const persistedRun = {\n            id: run.id,\n            name: run.name,\n            start_time: run.start_time,\n            end_time: run.end_time,\n            run_type: run.run_type,\n            reference_example_id: run.reference_example_id,\n            extra: runExtra,\n            serialized: run.serialized,\n            error: run.error,\n            inputs: run.inputs,\n            outputs: run.outputs,\n            session_name: run.project_name,\n            child_runs: child_runs,\n            parent_run_id: parent_run_id,\n            trace_id: run.trace_id,\n            dotted_order: run.dotted_order,\n            tags: run.tags,\n            attachments: run.attachments\n        };\n        return persistedRun;\n    }\n    async postRun(excludeChildRuns = true) {\n        try {\n            const runtimeEnv = (0,_utils_env_js__WEBPACK_IMPORTED_MODULE_0__.getRuntimeEnvironment)();\n            const runCreate = await this._convertToCreate(this, runtimeEnv, true);\n            await this.client.createRun(runCreate);\n            if (!excludeChildRuns) {\n                (0,_utils_warn_js__WEBPACK_IMPORTED_MODULE_3__.warnOnce)(\"Posting with excludeChildRuns=false is deprecated and will be removed in a future version.\");\n                for (const childRun of this.child_runs){\n                    await childRun.postRun(false);\n                }\n            }\n        } catch (error) {\n            console.error(`Error in postRun for run ${this.id}:`, error);\n        }\n    }\n    async patchRun() {\n        try {\n            const runUpdate = {\n                end_time: this.end_time,\n                error: this.error,\n                inputs: this.inputs,\n                outputs: this.outputs,\n                parent_run_id: this.parent_run?.id,\n                reference_example_id: this.reference_example_id,\n                extra: this.extra,\n                events: this.events,\n                dotted_order: this.dotted_order,\n                trace_id: this.trace_id,\n                tags: this.tags,\n                attachments: this.attachments\n            };\n            await this.client.updateRun(this.id, runUpdate);\n        } catch (error) {\n            console.error(`Error in patchRun for run ${this.id}`, error);\n        }\n    }\n    toJSON() {\n        return this._convertToCreate(this, undefined, false);\n    }\n    /**\n     * Add an event to the run tree.\n     * @param event - A single event or string to add\n     */ addEvent(event) {\n        if (!this.events) {\n            this.events = [];\n        }\n        if (typeof event === \"string\") {\n            this.events.push({\n                name: \"event\",\n                time: new Date().toISOString(),\n                message: event\n            });\n        } else {\n            this.events.push({\n                ...event,\n                time: event.time ?? new Date().toISOString()\n            });\n        }\n    }\n    static fromRunnableConfig(parentConfig, props) {\n        // We only handle the callback manager case for now\n        const callbackManager = parentConfig?.callbacks;\n        let parentRun;\n        let projectName;\n        let client;\n        let tracingEnabled = (0,_env_js__WEBPACK_IMPORTED_MODULE_2__.isTracingEnabled)();\n        if (callbackManager) {\n            const parentRunId = callbackManager?.getParentRunId?.() ?? \"\";\n            const langChainTracer = callbackManager?.handlers?.find((handler)=>handler?.name == \"langchain_tracer\");\n            parentRun = langChainTracer?.getRun?.(parentRunId);\n            projectName = langChainTracer?.projectName;\n            client = langChainTracer?.client;\n            tracingEnabled = tracingEnabled || !!langChainTracer;\n        }\n        if (!parentRun) {\n            return new RunTree({\n                ...props,\n                client,\n                tracingEnabled,\n                project_name: projectName\n            });\n        }\n        const parentRunTree = new RunTree({\n            name: parentRun.name,\n            id: parentRun.id,\n            trace_id: parentRun.trace_id,\n            dotted_order: parentRun.dotted_order,\n            client,\n            tracingEnabled,\n            project_name: projectName,\n            tags: [\n                ...new Set((parentRun?.tags ?? []).concat(parentConfig?.tags ?? []))\n            ],\n            extra: {\n                metadata: {\n                    ...parentRun?.extra?.metadata,\n                    ...parentConfig?.metadata\n                }\n            }\n        });\n        return parentRunTree.createChild(props);\n    }\n    static fromDottedOrder(dottedOrder) {\n        return this.fromHeaders({\n            \"langsmith-trace\": dottedOrder\n        });\n    }\n    static fromHeaders(headers, inheritArgs) {\n        const rawHeaders = \"get\" in headers && typeof headers.get === \"function\" ? {\n            \"langsmith-trace\": headers.get(\"langsmith-trace\"),\n            baggage: headers.get(\"baggage\")\n        } : headers;\n        const headerTrace = rawHeaders[\"langsmith-trace\"];\n        if (!headerTrace || typeof headerTrace !== \"string\") return undefined;\n        const parentDottedOrder = headerTrace.trim();\n        const parsedDottedOrder = parentDottedOrder.split(\".\").map((part)=>{\n            const [strTime, uuid] = part.split(\"Z\");\n            return {\n                strTime,\n                time: Date.parse(strTime + \"Z\"),\n                uuid\n            };\n        });\n        const traceId = parsedDottedOrder[0].uuid;\n        const config = {\n            ...inheritArgs,\n            name: inheritArgs?.[\"name\"] ?? \"parent\",\n            run_type: inheritArgs?.[\"run_type\"] ?? \"chain\",\n            start_time: inheritArgs?.[\"start_time\"] ?? Date.now(),\n            id: parsedDottedOrder.at(-1)?.uuid,\n            trace_id: traceId,\n            dotted_order: parentDottedOrder\n        };\n        if (rawHeaders[\"baggage\"] && typeof rawHeaders[\"baggage\"] === \"string\") {\n            const baggage = Baggage.fromHeader(rawHeaders[\"baggage\"]);\n            config.metadata = baggage.metadata;\n            config.tags = baggage.tags;\n        }\n        return new RunTree(config);\n    }\n    toHeaders(headers) {\n        const result = {\n            \"langsmith-trace\": this.dotted_order,\n            baggage: new Baggage(this.extra?.metadata, this.tags).toHeader()\n        };\n        if (headers) {\n            for (const [key, value] of Object.entries(result)){\n                headers.set(key, value);\n            }\n        }\n        return result;\n    }\n}\nObject.defineProperty(RunTree, \"sharedClient\", {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: null\n});\nfunction isRunTree(x) {\n    return x !== undefined && typeof x.createChild === \"function\" && typeof x.postRun === \"function\";\n}\nfunction isLangChainTracerLike(x) {\n    return typeof x === \"object\" && x != null && typeof x.name === \"string\" && x.name === \"langchain_tracer\";\n}\nfunction containsLangChainTracerLike(x) {\n    return Array.isArray(x) && x.some((callback)=>isLangChainTracerLike(callback));\n}\nfunction isCallbackManagerLike(x) {\n    return typeof x === \"object\" && x != null && Array.isArray(x.handlers);\n}\nfunction isRunnableConfigLike(x) {\n    // Check that it's an object with a callbacks arg\n    // that has either a CallbackManagerLike object with a langchain tracer within it\n    // or an array with a LangChainTracerLike object within it\n    return x !== undefined && typeof x.callbacks === \"object\" && // Callback manager with a langchain tracer\n    (containsLangChainTracerLike(x.callbacks?.handlers) || // Or it's an array with a LangChainTracerLike object within it\n    containsLangChainTracerLike(x.callbacks));\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL2Rpc3QvcnVuX3RyZWVzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7QUFBNkI7QUFDb0Y7QUFDNUU7QUFDTztBQUNEO0FBQzJCO0FBQ3RFLFNBQVNRLHFCQUFxQkMsS0FBSztJQUMvQixPQUFPQSxNQUFNQyxPQUFPLENBQUMsVUFBVTtBQUNuQztBQUNPLFNBQVNDLDJCQUEyQkMsS0FBSyxFQUFFQyxLQUFLLEVBQUVDLGlCQUFpQixDQUFDO0lBQ3ZFLDJFQUEyRTtJQUMzRSw4Q0FBOEM7SUFDOUMsTUFBTUMsY0FBY0QsZUFBZUUsT0FBTyxDQUFDLEdBQUdDLEtBQUssQ0FBQyxHQUFHLEdBQUdDLFFBQVEsQ0FBQyxHQUFHO0lBQ3RFLE9BQVFWLHFCQUFxQixDQUFDLEVBQUUsSUFBSVcsS0FBS1AsT0FBT1EsV0FBVyxHQUFHSCxLQUFLLENBQUMsR0FBRyxDQUFDLEdBQUcsRUFBRUYsWUFBWSxDQUFDLENBQUMsSUFBSUY7QUFDbkc7QUFDQTs7Q0FFQyxHQUNELE1BQU1RO0lBQ0ZDLFlBQVlDLFFBQVEsRUFBRUMsSUFBSSxDQUFFO1FBQ3hCQyxPQUFPQyxjQUFjLENBQUMsSUFBSSxFQUFFLFlBQVk7WUFDcENDLFlBQVk7WUFDWkMsY0FBYztZQUNkQyxVQUFVO1lBQ1ZDLE9BQU8sS0FBSztRQUNoQjtRQUNBTCxPQUFPQyxjQUFjLENBQUMsSUFBSSxFQUFFLFFBQVE7WUFDaENDLFlBQVk7WUFDWkMsY0FBYztZQUNkQyxVQUFVO1lBQ1ZDLE9BQU8sS0FBSztRQUNoQjtRQUNBLElBQUksQ0FBQ1AsUUFBUSxHQUFHQTtRQUNoQixJQUFJLENBQUNDLElBQUksR0FBR0E7SUFDaEI7SUFDQSxPQUFPTyxXQUFXRCxLQUFLLEVBQUU7UUFDckIsTUFBTUUsUUFBUUYsTUFBTUcsS0FBSyxDQUFDO1FBQzFCLElBQUlWLFdBQVcsQ0FBQztRQUNoQixJQUFJQyxPQUFPLEVBQUU7UUFDYixLQUFLLE1BQU1VLFFBQVFGLE1BQU87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Q1YsT0FBT2lGLEVBQUU3RixXQUFXLEtBQUssY0FDekIsT0FBTzZGLEVBQUU5QyxPQUFPLEtBQUs7QUFDN0I7QUFDQSxTQUFTL0Isc0JBQXNCNkUsQ0FBQztJQUM1QixPQUFRLE9BQU9BLE1BQU0sWUFDakJBLEtBQUssUUFDTCxPQUFPQSxFQUFFbEQsSUFBSSxLQUFLLFlBQ2xCa0QsRUFBRWxELElBQUksS0FBSztBQUNuQjtBQUNBLFNBQVNtRCw0QkFBNEJELENBQUM7SUFDbEMsT0FBUUUsTUFBTUMsT0FBTyxDQUFDSCxNQUFNQSxFQUFFSSxJQUFJLENBQUMsQ0FBQ0MsV0FBYWxGLHNCQUFzQmtGO0FBQzNFO0FBQ0EsU0FBU3hGLHNCQUFzQm1GLENBQUM7SUFDNUIsT0FBUSxPQUFPQSxNQUFNLFlBQ2pCQSxLQUFLLFFBQ0xFLE1BQU1DLE9BQU8sQ0FBQ0gsRUFBRS9FLFFBQVE7QUFDaEM7QUFDTyxTQUFTUCxxQkFBcUJzRixDQUFDO0lBQ2xDLGlEQUFpRDtJQUNqRCxpRkFBaUY7SUFDakYsMERBQTBEO0lBQzFELE9BQVFBLE1BQU1qRixhQUNWLE9BQU9pRixFQUFFcEYsU0FBUyxLQUFLLFlBQ3ZCLDJDQUEyQztJQUMxQ3FGLENBQUFBLDRCQUE0QkQsRUFBRXBGLFNBQVMsRUFBRUssYUFDdEMsK0RBQStEO0lBQy9EZ0YsNEJBQTRCRCxFQUFFcEYsU0FBUztBQUNuRCIsInNvdXJjZXMiOlsid2VicGFjazovL2FpLW1hcmtldC1yZXNlYXJjaC1hZ2VudC8uL25vZGVfbW9kdWxlcy9sYW5nc21pdGgvZGlzdC9ydW5fdHJlZXMuanM/NTEyZCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyB1dWlkIGZyb20gXCJ1dWlkXCI7XG5pbXBvcnQgeyBnZXRFbnZpcm9ubWVudFZhcmlhYmxlLCBnZXRMYW5nU21pdGhFbnZpcm9ubWVudFZhcmlhYmxlLCBnZXRSdW50aW1lRW52aXJvbm1lbnQsIH0gZnJvbSBcIi4vdXRpbHMvZW52LmpzXCI7XG5pbXBvcnQgeyBDbGllbnQgfSBmcm9tIFwiLi9jbGllbnQuanNcIjtcbmltcG9ydCB7IGlzVHJhY2luZ0VuYWJsZWQgfSBmcm9tIFwiLi9lbnYuanNcIjtcbmltcG9ydCB7IHdhcm5PbmNlIH0gZnJvbSBcIi4vdXRpbHMvd2Fybi5qc1wiO1xuaW1wb3J0IHsgX0xDX0NPTlRFWFRfVkFSSUFCTEVTX0tFWSB9IGZyb20gXCIuL3NpbmdsZXRvbnMvY29uc3RhbnRzLmpzXCI7XG5mdW5jdGlvbiBzdHJpcE5vbkFscGhhbnVtZXJpYyhpbnB1dCkge1xuICAgIHJldHVybiBpbnB1dC5yZXBsYWNlKC9bLTouXS9nLCBcIlwiKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBjb252ZXJ0VG9Eb3R0ZWRPcmRlckZvcm1hdChlcG9jaCwgcnVuSWQsIGV4ZWN1dGlvbk9yZGVyID0gMSkge1xuICAgIC8vIERhdGUgb25seSBoYXMgbWlsbGlzZWNvbmQgcHJlY2lzaW9uLCBzbyB3ZSB1c2UgdGhlIG1pY3Jvc2Vjb25kcyB0byBicmVha1xuICAgIC8vIHBvc3NpYmxlIHRpZXMsIGF2b2lkaW5nIGluY29ycmVjdCBydW4gb3JkZXJcbiAgICBjb25zdCBwYWRkZWRPcmRlciA9IGV4ZWN1dGlvbk9yZGVyLnRvRml4ZWQoMCkuc2xpY2UoMCwgMykucGFkU3RhcnQoMywgXCIwXCIpO1xuICAgIHJldHVybiAoc3RyaXBOb25BbHBoYW51bWVyaWMoYCR7bmV3IERhdGUoZXBvY2gpLnRvSVNPU3RyaW5nKCkuc2xpY2UoMCwgLTEpfSR7cGFkZGVkT3JkZXJ9WmApICsgcnVuSWQpO1xufVxuLyoqXG4gKiBCYWdnYWdlIGhlYWRlciBpbmZvcm1hdGlvblxuICovXG5jbGFzcyBCYWdnYWdlIHtcbiAgICBjb25zdHJ1Y3RvcihtZXRhZGF0YSwgdGFncykge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJtZXRhZGF0YVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJ0YWdzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMubWV0YWRhdGEgPSBtZXRhZGF0YTtcbiAgICAgICAgdGhpcy50YWdzID0gdGFncztcbiAgICB9XG4gICAgc3RhdGljIGZyb21IZWFkZXIodmFsdWUpIHtcbiAgICAgICAgY29uc3QgaXRlbXMgPSB2YWx1ZS5zcGxpdChcIixcIik7XG4gICAgICAgIGxldCBtZXRhZGF0YSA9IHt9O1xuICAgICAgICBsZXQgdGFncyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgaXRlbXMpIHtcbiAgICAgICAgICAgIGNvbnN0IFtrZXksIHVyaVZhbHVlXSA9IGl0ZW0uc3BsaXQoXCI9XCIpO1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBkZWNvZGVVUklDb21wb25lbnQodXJpVmFsdWUpO1xuICAgICAgICAgICAgaWYgKGtleSA9PT0gXCJsYW5nc21pdGgtbWV0YWRhdGFcIikge1xuICAgICAgICAgICAgICAgIG1ldGFkYXRhID0gSlNPTi5wYXJzZSh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChrZXkgPT09IFwibGFuZ3NtaXRoLXRhZ3NcIikge1xuICAgICAgICAgICAgICAgIHRhZ3MgPSB2YWx1ZS5zcGxpdChcIixcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBCYWdnYWdlKG1ldGFkYXRhLCB0YWdzKTtcbiAgICB9XG4gICAgdG9IZWFkZXIoKSB7XG4gICAgICAgIGNvbnN0IGl0ZW1zID0gW107XG4gICAgICAgIGlmICh0aGlzLm1ldGFkYXRhICYmIE9iamVjdC5rZXlzKHRoaXMubWV0YWRhdGEpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGl0ZW1zLnB1c2goYGxhbmdzbWl0aC1tZXRhZGF0YT0ke2VuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeSh0aGlzLm1ldGFkYXRhKSl9YCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMudGFncyAmJiB0aGlzLnRhZ3MubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgaXRlbXMucHVzaChgbGFuZ3NtaXRoLXRhZ3M9JHtlbmNvZGVVUklDb21wb25lbnQodGhpcy50YWdzLmpvaW4oXCIsXCIpKX1gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaXRlbXMuam9pbihcIixcIik7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIFJ1blRyZWUge1xuICAgIGNvbnN0cnVjdG9yKG9yaWdpbmFsQ29uZmlnKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImlkXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwicnVuX3R5cGVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwicHJvamVjdF9uYW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInBhcmVudF9ydW5cIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiY2hpbGRfcnVuc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJzdGFydF90aW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImVuZF90aW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImV4dHJhXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInRhZ3NcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiZXJyb3JcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwic2VyaWFsaXplZFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJpbnB1dHNcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwib3V0cHV0c1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJyZWZlcmVuY2VfZXhhbXBsZV9pZFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJjbGllbnRcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiZXZlbnRzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInRyYWNlX2lkXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImRvdHRlZF9vcmRlclwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJ0cmFjaW5nRW5hYmxlZFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJleGVjdXRpb25fb3JkZXJcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiY2hpbGRfZXhlY3V0aW9uX29yZGVyXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBdHRhY2htZW50cyBhc3NvY2lhdGVkIHdpdGggdGhlIHJ1bi5cbiAgICAgICAgICogRWFjaCBlbnRyeSBpcyBhIHR1cGxlIG9mIFttaW1lX3R5cGUsIGJ5dGVzXVxuICAgICAgICAgKi9cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiYXR0YWNobWVudHNcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgLy8gSWYgeW91IHBhc3MgaW4gYSBydW4gdHJlZSBkaXJlY3RseSwgcmV0dXJuIGEgc2hhbGxvdyBjbG9uZVxuICAgICAgICBpZiAoaXNSdW5UcmVlKG9yaWdpbmFsQ29uZmlnKSkge1xuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLCB7IC4uLm9yaWdpbmFsQ29uZmlnIH0pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRlZmF1bHRDb25maWcgPSBSdW5UcmVlLmdldERlZmF1bHRDb25maWcoKTtcbiAgICAgICAgY29uc3QgeyBtZXRhZGF0YSwgLi4uY29uZmlnIH0gPSBvcmlnaW5hbENvbmZpZztcbiAgICAgICAgY29uc3QgY2xpZW50ID0gY29uZmlnLmNsaWVudCA/PyBSdW5UcmVlLmdldFNoYXJlZENsaWVudCgpO1xuICAgICAgICBjb25zdCBkZWR1cGVkTWV0YWRhdGEgPSB7XG4gICAgICAgICAgICAuLi5tZXRhZGF0YSxcbiAgICAgICAgICAgIC4uLmNvbmZpZz8uZXh0cmE/Lm1ldGFkYXRhLFxuICAgICAgICB9O1xuICAgICAgICBjb25maWcuZXh0cmEgPSB7IC4uLmNvbmZpZy5leHRyYSwgbWV0YWRhdGE6IGRlZHVwZWRNZXRhZGF0YSB9O1xuICAgICAgICBPYmplY3QuYXNzaWduKHRoaXMsIHsgLi4uZGVmYXVsdENvbmZpZywgLi4uY29uZmlnLCBjbGllbnQgfSk7XG4gICAgICAgIGlmICghdGhpcy50cmFjZV9pZCkge1xuICAgICAgICAgICAgaWYgKHRoaXMucGFyZW50X3J1bikge1xuICAgICAgICAgICAgICAgIHRoaXMudHJhY2VfaWQgPSB0aGlzLnBhcmVudF9ydW4udHJhY2VfaWQgPz8gdGhpcy5pZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMudHJhY2VfaWQgPSB0aGlzLmlkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuZXhlY3V0aW9uX29yZGVyID8/PSAxO1xuICAgICAgICB0aGlzLmNoaWxkX2V4ZWN1dGlvbl9vcmRlciA/Pz0gMTtcbiAgICAgICAgaWYgKCF0aGlzLmRvdHRlZF9vcmRlcikge1xuICAgICAgICAgICAgY29uc3QgY3VycmVudERvdHRlZE9yZGVyID0gY29udmVydFRvRG90dGVkT3JkZXJGb3JtYXQodGhpcy5zdGFydF90aW1lLCB0aGlzLmlkLCB0aGlzLmV4ZWN1dGlvbl9vcmRlcik7XG4gICAgICAgICAgICBpZiAodGhpcy5wYXJlbnRfcnVuKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kb3R0ZWRfb3JkZXIgPVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnBhcmVudF9ydW4uZG90dGVkX29yZGVyICsgXCIuXCIgKyBjdXJyZW50RG90dGVkT3JkZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRvdHRlZF9vcmRlciA9IGN1cnJlbnREb3R0ZWRPcmRlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBzdGF0aWMgZ2V0RGVmYXVsdENvbmZpZygpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGlkOiB1dWlkLnY0KCksXG4gICAgICAgICAgICBydW5fdHlwZTogXCJjaGFpblwiLFxuICAgICAgICAgICAgcHJvamVjdF9uYW1lOiBnZXRMYW5nU21pdGhFbnZpcm9ubWVudFZhcmlhYmxlKFwiUFJPSkVDVFwiKSA/P1xuICAgICAgICAgICAgICAgIGdldEVudmlyb25tZW50VmFyaWFibGUoXCJMQU5HQ0hBSU5fU0VTU0lPTlwiKSA/PyAvLyBUT0RPOiBEZXByZWNhdGVcbiAgICAgICAgICAgICAgICBcImRlZmF1bHRcIixcbiAgICAgICAgICAgIGNoaWxkX3J1bnM6IFtdLFxuICAgICAgICAgICAgYXBpX3VybDogZ2V0RW52aXJvbm1lbnRWYXJpYWJsZShcIkxBTkdDSEFJTl9FTkRQT0lOVFwiKSA/PyBcImh0dHA6Ly9sb2NhbGhvc3Q6MTk4NFwiLFxuICAgICAgICAgICAgYXBpX2tleTogZ2V0RW52aXJvbm1lbnRWYXJpYWJsZShcIkxBTkdDSEFJTl9BUElfS0VZXCIpLFxuICAgICAgICAgICAgY2FsbGVyX29wdGlvbnM6IHt9LFxuICAgICAgICAgICAgc3RhcnRfdGltZTogRGF0ZS5ub3coKSxcbiAgICAgICAgICAgIHNlcmlhbGl6ZWQ6IHt9LFxuICAgICAgICAgICAgaW5wdXRzOiB7fSxcbiAgICAgICAgICAgIGV4dHJhOiB7fSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgc3RhdGljIGdldFNoYXJlZENsaWVudCgpIHtcbiAgICAgICAgaWYgKCFSdW5UcmVlLnNoYXJlZENsaWVudCkge1xuICAgICAgICAgICAgUnVuVHJlZS5zaGFyZWRDbGllbnQgPSBuZXcgQ2xpZW50KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFJ1blRyZWUuc2hhcmVkQ2xpZW50O1xuICAgIH1cbiAgICBjcmVhdGVDaGlsZChjb25maWcpIHtcbiAgICAgICAgY29uc3QgY2hpbGRfZXhlY3V0aW9uX29yZGVyID0gdGhpcy5jaGlsZF9leGVjdXRpb25fb3JkZXIgKyAxO1xuICAgICAgICBjb25zdCBjaGlsZCA9IG5ldyBSdW5UcmVlKHtcbiAgICAgICAgICAgIC4uLmNvbmZpZyxcbiAgICAgICAgICAgIHBhcmVudF9ydW46IHRoaXMsXG4gICAgICAgICAgICBwcm9qZWN0X25hbWU6IHRoaXMucHJvamVjdF9uYW1lLFxuICAgICAgICAgICAgY2xpZW50OiB0aGlzLmNsaWVudCxcbiAgICAgICAgICAgIHRyYWNpbmdFbmFibGVkOiB0aGlzLnRyYWNpbmdFbmFibGVkLFxuICAgICAgICAgICAgZXhlY3V0aW9uX29yZGVyOiBjaGlsZF9leGVjdXRpb25fb3JkZXIsXG4gICAgICAgICAgICBjaGlsZF9leGVjdXRpb25fb3JkZXI6IGNoaWxkX2V4ZWN1dGlvbl9vcmRlcixcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIENvcHkgY29udGV4dCB2YXJzIG92ZXIgaW50byB0aGUgbmV3IHJ1biB0cmVlLlxuICAgICAgICBpZiAoX0xDX0NPTlRFWFRfVkFSSUFCTEVTX0tFWSBpbiB0aGlzKSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAgICAgY2hpbGRbX0xDX0NPTlRFWFRfVkFSSUFCTEVTX0tFWV0gPVxuICAgICAgICAgICAgICAgIHRoaXNbX0xDX0NPTlRFWFRfVkFSSUFCTEVTX0tFWV07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgTENfQ0hJTEQgPSBTeW1ib2wuZm9yKFwibGM6Y2hpbGRfY29uZmlnXCIpO1xuICAgICAgICBjb25zdCBwcmVzZW50Q29uZmlnID0gY29uZmlnLmV4dHJhPy5bTENfQ0hJTERdID8/XG4gICAgICAgICAgICB0aGlzLmV4dHJhW0xDX0NISUxEXTtcbiAgICAgICAgLy8gdHJhY2luZyBmb3IgTGFuZ0NoYWluIGlzIGRlZmluZWQgYnkgdGhlIF9wYXJlbnRSdW5JZCBhbmQgcnVuTWFwIG9mIHRoZSB0cmFjZXJcbiAgICAgICAgaWYgKGlzUnVubmFibGVDb25maWdMaWtlKHByZXNlbnRDb25maWcpKSB7XG4gICAgICAgICAgICBjb25zdCBuZXdDb25maWcgPSB7IC4uLnByZXNlbnRDb25maWcgfTtcbiAgICAgICAgICAgIGNvbnN0IGNhbGxiYWNrcyA9IGlzQ2FsbGJhY2tNYW5hZ2VyTGlrZShuZXdDb25maWcuY2FsbGJhY2tzKVxuICAgICAgICAgICAgICAgID8gbmV3Q29uZmlnLmNhbGxiYWNrcy5jb3B5Py4oKVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgaWYgKGNhbGxiYWNrcykge1xuICAgICAgICAgICAgICAgIC8vIHVwZGF0ZSB0aGUgcGFyZW50IHJ1biBpZFxuICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24oY2FsbGJhY2tzLCB7IF9wYXJlbnRSdW5JZDogY2hpbGQuaWQgfSk7XG4gICAgICAgICAgICAgICAgLy8gb25seSBwb3B1bGF0ZSBpZiB3ZSdyZSBpbiBhIG5ld2VyIExDLkpTIHZlcnNpb25cbiAgICAgICAgICAgICAgICBjYWxsYmFja3MuaGFuZGxlcnNcbiAgICAgICAgICAgICAgICAgICAgPy5maW5kKGlzTGFuZ0NoYWluVHJhY2VyTGlrZSlcbiAgICAgICAgICAgICAgICAgICAgPy51cGRhdGVGcm9tUnVuVHJlZT8uKGNoaWxkKTtcbiAgICAgICAgICAgICAgICBuZXdDb25maWcuY2FsbGJhY2tzID0gY2FsbGJhY2tzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2hpbGQuZXh0cmFbTENfQ0hJTERdID0gbmV3Q29uZmlnO1xuICAgICAgICB9XG4gICAgICAgIC8vIHByb3BhZ2F0ZSBjaGlsZF9leGVjdXRpb25fb3JkZXIgdXB3YXJkc1xuICAgICAgICBjb25zdCB2aXNpdGVkID0gbmV3IFNldCgpO1xuICAgICAgICBsZXQgY3VycmVudCA9IHRoaXM7XG4gICAgICAgIHdoaWxlIChjdXJyZW50ICE9IG51bGwgJiYgIXZpc2l0ZWQuaGFzKGN1cnJlbnQuaWQpKSB7XG4gICAgICAgICAgICB2aXNpdGVkLmFkZChjdXJyZW50LmlkKTtcbiAgICAgICAgICAgIGN1cnJlbnQuY2hpbGRfZXhlY3V0aW9uX29yZGVyID0gTWF0aC5tYXgoY3VycmVudC5jaGlsZF9leGVjdXRpb25fb3JkZXIsIGNoaWxkX2V4ZWN1dGlvbl9vcmRlcik7XG4gICAgICAgICAgICBjdXJyZW50ID0gY3VycmVudC5wYXJlbnRfcnVuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2hpbGRfcnVucy5wdXNoKGNoaWxkKTtcbiAgICAgICAgcmV0dXJuIGNoaWxkO1xuICAgIH1cbiAgICBhc3luYyBlbmQob3V0cHV0cywgZXJyb3IsIGVuZFRpbWUgPSBEYXRlLm5vdygpLCBtZXRhZGF0YSkge1xuICAgICAgICB0aGlzLm91dHB1dHMgPSB0aGlzLm91dHB1dHMgPz8gb3V0cHV0cztcbiAgICAgICAgdGhpcy5lcnJvciA9IHRoaXMuZXJyb3IgPz8gZXJyb3I7XG4gICAgICAgIHRoaXMuZW5kX3RpbWUgPSB0aGlzLmVuZF90aW1lID8/IGVuZFRpbWU7XG4gICAgICAgIGlmIChtZXRhZGF0YSAmJiBPYmplY3Qua2V5cyhtZXRhZGF0YSkubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdGhpcy5leHRyYSA9IHRoaXMuZXh0cmFcbiAgICAgICAgICAgICAgICA/IHsgLi4udGhpcy5leHRyYSwgbWV0YWRhdGE6IHsgLi4udGhpcy5leHRyYS5tZXRhZGF0YSwgLi4ubWV0YWRhdGEgfSB9XG4gICAgICAgICAgICAgICAgOiB7IG1ldGFkYXRhIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgX2NvbnZlcnRUb0NyZWF0ZShydW4sIHJ1bnRpbWVFbnYsIGV4Y2x1ZGVDaGlsZFJ1bnMgPSB0cnVlKSB7XG4gICAgICAgIGNvbnN0IHJ1bkV4dHJhID0gcnVuLmV4dHJhID8/IHt9O1xuICAgICAgICBpZiAoIXJ1bkV4dHJhLnJ1bnRpbWUpIHtcbiAgICAgICAgICAgIHJ1bkV4dHJhLnJ1bnRpbWUgPSB7fTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocnVudGltZUVudikge1xuICAgICAgICAgICAgZm9yIChjb25zdCBbaywgdl0gb2YgT2JqZWN0LmVudHJpZXMocnVudGltZUVudikpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXJ1bkV4dHJhLnJ1bnRpbWVba10pIHtcbiAgICAgICAgICAgICAgICAgICAgcnVuRXh0cmEucnVudGltZVtrXSA9IHY7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCBjaGlsZF9ydW5zO1xuICAgICAgICBsZXQgcGFyZW50X3J1bl9pZDtcbiAgICAgICAgaWYgKCFleGNsdWRlQ2hpbGRSdW5zKSB7XG4gICAgICAgICAgICBjaGlsZF9ydW5zID0gcnVuLmNoaWxkX3J1bnMubWFwKChjaGlsZF9ydW4pID0+IHRoaXMuX2NvbnZlcnRUb0NyZWF0ZShjaGlsZF9ydW4sIHJ1bnRpbWVFbnYsIGV4Y2x1ZGVDaGlsZFJ1bnMpKTtcbiAgICAgICAgICAgIHBhcmVudF9ydW5faWQgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwYXJlbnRfcnVuX2lkID0gcnVuLnBhcmVudF9ydW4/LmlkO1xuICAgICAgICAgICAgY2hpbGRfcnVucyA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBlcnNpc3RlZFJ1biA9IHtcbiAgICAgICAgICAgIGlkOiBydW4uaWQsXG4gICAgICAgICAgICBuYW1lOiBydW4ubmFtZSxcbiAgICAgICAgICAgIHN0YXJ0X3RpbWU6IHJ1bi5zdGFydF90aW1lLFxuICAgICAgICAgICAgZW5kX3RpbWU6IHJ1bi5lbmRfdGltZSxcbiAgICAgICAgICAgIHJ1bl90eXBlOiBydW4ucnVuX3R5cGUsXG4gICAgICAgICAgICByZWZlcmVuY2VfZXhhbXBsZV9pZDogcnVuLnJlZmVyZW5jZV9leGFtcGxlX2lkLFxuICAgICAgICAgICAgZXh0cmE6IHJ1bkV4dHJhLFxuICAgICAgICAgICAgc2VyaWFsaXplZDogcnVuLnNlcmlhbGl6ZWQsXG4gICAgICAgICAgICBlcnJvcjogcnVuLmVycm9yLFxuICAgICAgICAgICAgaW5wdXRzOiBydW4uaW5wdXRzLFxuICAgICAgICAgICAgb3V0cHV0czogcnVuLm91dHB1dHMsXG4gICAgICAgICAgICBzZXNzaW9uX25hbWU6IHJ1bi5wcm9qZWN0X25hbWUsXG4gICAgICAgICAgICBjaGlsZF9ydW5zOiBjaGlsZF9ydW5zLFxuICAgICAgICAgICAgcGFyZW50X3J1bl9pZDogcGFyZW50X3J1bl9pZCxcbiAgICAgICAgICAgIHRyYWNlX2lkOiBydW4udHJhY2VfaWQsXG4gICAgICAgICAgICBkb3R0ZWRfb3JkZXI6IHJ1bi5kb3R0ZWRfb3JkZXIsXG4gICAgICAgICAgICB0YWdzOiBydW4udGFncyxcbiAgICAgICAgICAgIGF0dGFjaG1lbnRzOiBydW4uYXR0YWNobWVudHMsXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBwZXJzaXN0ZWRSdW47XG4gICAgfVxuICAgIGFzeW5jIHBvc3RSdW4oZXhjbHVkZUNoaWxkUnVucyA9IHRydWUpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJ1bnRpbWVFbnYgPSBnZXRSdW50aW1lRW52aXJvbm1lbnQoKTtcbiAgICAgICAgICAgIGNvbnN0IHJ1bkNyZWF0ZSA9IGF3YWl0IHRoaXMuX2NvbnZlcnRUb0NyZWF0ZSh0aGlzLCBydW50aW1lRW52LCB0cnVlKTtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuY2xpZW50LmNyZWF0ZVJ1bihydW5DcmVhdGUpO1xuICAgICAgICAgICAgaWYgKCFleGNsdWRlQ2hpbGRSdW5zKSB7XG4gICAgICAgICAgICAgICAgd2Fybk9uY2UoXCJQb3N0aW5nIHdpdGggZXhjbHVkZUNoaWxkUnVucz1mYWxzZSBpcyBkZXByZWNhdGVkIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gYSBmdXR1cmUgdmVyc2lvbi5cIik7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBjaGlsZFJ1biBvZiB0aGlzLmNoaWxkX3J1bnMpIHtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgY2hpbGRSdW4ucG9zdFJ1bihmYWxzZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihgRXJyb3IgaW4gcG9zdFJ1biBmb3IgcnVuICR7dGhpcy5pZH06YCwgZXJyb3IpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIHBhdGNoUnVuKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcnVuVXBkYXRlID0ge1xuICAgICAgICAgICAgICAgIGVuZF90aW1lOiB0aGlzLmVuZF90aW1lLFxuICAgICAgICAgICAgICAgIGVycm9yOiB0aGlzLmVycm9yLFxuICAgICAgICAgICAgICAgIGlucHV0czogdGhpcy5pbnB1dHMsXG4gICAgICAgICAgICAgICAgb3V0cHV0czogdGhpcy5vdXRwdXRzLFxuICAgICAgICAgICAgICAgIHBhcmVudF9ydW5faWQ6IHRoaXMucGFyZW50X3J1bj8uaWQsXG4gICAgICAgICAgICAgICAgcmVmZXJlbmNlX2V4YW1wbGVfaWQ6IHRoaXMucmVmZXJlbmNlX2V4YW1wbGVfaWQsXG4gICAgICAgICAgICAgICAgZXh0cmE6IHRoaXMuZXh0cmEsXG4gICAgICAgICAgICAgICAgZXZlbnRzOiB0aGlzLmV2ZW50cyxcbiAgICAgICAgICAgICAgICBkb3R0ZWRfb3JkZXI6IHRoaXMuZG90dGVkX29yZGVyLFxuICAgICAgICAgICAgICAgIHRyYWNlX2lkOiB0aGlzLnRyYWNlX2lkLFxuICAgICAgICAgICAgICAgIHRhZ3M6IHRoaXMudGFncyxcbiAgICAgICAgICAgICAgICBhdHRhY2htZW50czogdGhpcy5hdHRhY2htZW50cyxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBhd2FpdCB0aGlzLmNsaWVudC51cGRhdGVSdW4odGhpcy5pZCwgcnVuVXBkYXRlKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIGluIHBhdGNoUnVuIGZvciBydW4gJHt0aGlzLmlkfWAsIGVycm9yKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jb252ZXJ0VG9DcmVhdGUodGhpcywgdW5kZWZpbmVkLCBmYWxzZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZCBhbiBldmVudCB0byB0aGUgcnVuIHRyZWUuXG4gICAgICogQHBhcmFtIGV2ZW50IC0gQSBzaW5nbGUgZXZlbnQgb3Igc3RyaW5nIHRvIGFkZFxuICAgICAqL1xuICAgIGFkZEV2ZW50KGV2ZW50KSB7XG4gICAgICAgIGlmICghdGhpcy5ldmVudHMpIHtcbiAgICAgICAgICAgIHRoaXMuZXZlbnRzID0gW107XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBldmVudCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgdGhpcy5ldmVudHMucHVzaCh7XG4gICAgICAgICAgICAgICAgbmFtZTogXCJldmVudFwiLFxuICAgICAgICAgICAgICAgIHRpbWU6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiBldmVudCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5ldmVudHMucHVzaCh7XG4gICAgICAgICAgICAgICAgLi4uZXZlbnQsXG4gICAgICAgICAgICAgICAgdGltZTogZXZlbnQudGltZSA/PyBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzdGF0aWMgZnJvbVJ1bm5hYmxlQ29uZmlnKHBhcmVudENvbmZpZywgcHJvcHMpIHtcbiAgICAgICAgLy8gV2Ugb25seSBoYW5kbGUgdGhlIGNhbGxiYWNrIG1hbmFnZXIgY2FzZSBmb3Igbm93XG4gICAgICAgIGNvbnN0IGNhbGxiYWNrTWFuYWdlciA9IHBhcmVudENvbmZpZz8uY2FsbGJhY2tzO1xuICAgICAgICBsZXQgcGFyZW50UnVuO1xuICAgICAgICBsZXQgcHJvamVjdE5hbWU7XG4gICAgICAgIGxldCBjbGllbnQ7XG4gICAgICAgIGxldCB0cmFjaW5nRW5hYmxlZCA9IGlzVHJhY2luZ0VuYWJsZWQoKTtcbiAgICAgICAgaWYgKGNhbGxiYWNrTWFuYWdlcikge1xuICAgICAgICAgICAgY29uc3QgcGFyZW50UnVuSWQgPSBjYWxsYmFja01hbmFnZXI/LmdldFBhcmVudFJ1bklkPy4oKSA/PyBcIlwiO1xuICAgICAgICAgICAgY29uc3QgbGFuZ0NoYWluVHJhY2VyID0gY2FsbGJhY2tNYW5hZ2VyPy5oYW5kbGVycz8uZmluZCgoaGFuZGxlcikgPT4gaGFuZGxlcj8ubmFtZSA9PSBcImxhbmdjaGFpbl90cmFjZXJcIik7XG4gICAgICAgICAgICBwYXJlbnRSdW4gPSBsYW5nQ2hhaW5UcmFjZXI/LmdldFJ1bj8uKHBhcmVudFJ1bklkKTtcbiAgICAgICAgICAgIHByb2plY3ROYW1lID0gbGFuZ0NoYWluVHJhY2VyPy5wcm9qZWN0TmFtZTtcbiAgICAgICAgICAgIGNsaWVudCA9IGxhbmdDaGFpblRyYWNlcj8uY2xpZW50O1xuICAgICAgICAgICAgdHJhY2luZ0VuYWJsZWQgPSB0cmFjaW5nRW5hYmxlZCB8fCAhIWxhbmdDaGFpblRyYWNlcjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXBhcmVudFJ1bikge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBSdW5UcmVlKHtcbiAgICAgICAgICAgICAgICAuLi5wcm9wcyxcbiAgICAgICAgICAgICAgICBjbGllbnQsXG4gICAgICAgICAgICAgICAgdHJhY2luZ0VuYWJsZWQsXG4gICAgICAgICAgICAgICAgcHJvamVjdF9uYW1lOiBwcm9qZWN0TmFtZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBhcmVudFJ1blRyZWUgPSBuZXcgUnVuVHJlZSh7XG4gICAgICAgICAgICBuYW1lOiBwYXJlbnRSdW4ubmFtZSxcbiAgICAgICAgICAgIGlkOiBwYXJlbnRSdW4uaWQsXG4gICAgICAgICAgICB0cmFjZV9pZDogcGFyZW50UnVuLnRyYWNlX2lkLFxuICAgICAgICAgICAgZG90dGVkX29yZGVyOiBwYXJlbnRSdW4uZG90dGVkX29yZGVyLFxuICAgICAgICAgICAgY2xpZW50LFxuICAgICAgICAgICAgdHJhY2luZ0VuYWJsZWQsXG4gICAgICAgICAgICBwcm9qZWN0X25hbWU6IHByb2plY3ROYW1lLFxuICAgICAgICAgICAgdGFnczogW1xuICAgICAgICAgICAgICAgIC4uLm5ldyBTZXQoKHBhcmVudFJ1bj8udGFncyA/PyBbXSkuY29uY2F0KHBhcmVudENvbmZpZz8udGFncyA/PyBbXSkpLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIGV4dHJhOiB7XG4gICAgICAgICAgICAgICAgbWV0YWRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgLi4ucGFyZW50UnVuPy5leHRyYT8ubWV0YWRhdGEsXG4gICAgICAgICAgICAgICAgICAgIC4uLnBhcmVudENvbmZpZz8ubWV0YWRhdGEsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcGFyZW50UnVuVHJlZS5jcmVhdGVDaGlsZChwcm9wcyk7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tRG90dGVkT3JkZXIoZG90dGVkT3JkZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZnJvbUhlYWRlcnMoeyBcImxhbmdzbWl0aC10cmFjZVwiOiBkb3R0ZWRPcmRlciB9KTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21IZWFkZXJzKGhlYWRlcnMsIGluaGVyaXRBcmdzKSB7XG4gICAgICAgIGNvbnN0IHJhd0hlYWRlcnMgPSBcImdldFwiIGluIGhlYWRlcnMgJiYgdHlwZW9mIGhlYWRlcnMuZ2V0ID09PSBcImZ1bmN0aW9uXCJcbiAgICAgICAgICAgID8ge1xuICAgICAgICAgICAgICAgIFwibGFuZ3NtaXRoLXRyYWNlXCI6IGhlYWRlcnMuZ2V0KFwibGFuZ3NtaXRoLXRyYWNlXCIpLFxuICAgICAgICAgICAgICAgIGJhZ2dhZ2U6IGhlYWRlcnMuZ2V0KFwiYmFnZ2FnZVwiKSxcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIDogaGVhZGVycztcbiAgICAgICAgY29uc3QgaGVhZGVyVHJhY2UgPSByYXdIZWFkZXJzW1wibGFuZ3NtaXRoLXRyYWNlXCJdO1xuICAgICAgICBpZiAoIWhlYWRlclRyYWNlIHx8IHR5cGVvZiBoZWFkZXJUcmFjZSAhPT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIGNvbnN0IHBhcmVudERvdHRlZE9yZGVyID0gaGVhZGVyVHJhY2UudHJpbSgpO1xuICAgICAgICBjb25zdCBwYXJzZWREb3R0ZWRPcmRlciA9IHBhcmVudERvdHRlZE9yZGVyLnNwbGl0KFwiLlwiKS5tYXAoKHBhcnQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IFtzdHJUaW1lLCB1dWlkXSA9IHBhcnQuc3BsaXQoXCJaXCIpO1xuICAgICAgICAgICAgcmV0dXJuIHsgc3RyVGltZSwgdGltZTogRGF0ZS5wYXJzZShzdHJUaW1lICsgXCJaXCIpLCB1dWlkIH07XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCB0cmFjZUlkID0gcGFyc2VkRG90dGVkT3JkZXJbMF0udXVpZDtcbiAgICAgICAgY29uc3QgY29uZmlnID0ge1xuICAgICAgICAgICAgLi4uaW5oZXJpdEFyZ3MsXG4gICAgICAgICAgICBuYW1lOiBpbmhlcml0QXJncz8uW1wibmFtZVwiXSA/PyBcInBhcmVudFwiLFxuICAgICAgICAgICAgcnVuX3R5cGU6IGluaGVyaXRBcmdzPy5bXCJydW5fdHlwZVwiXSA/PyBcImNoYWluXCIsXG4gICAgICAgICAgICBzdGFydF90aW1lOiBpbmhlcml0QXJncz8uW1wic3RhcnRfdGltZVwiXSA/PyBEYXRlLm5vdygpLFxuICAgICAgICAgICAgaWQ6IHBhcnNlZERvdHRlZE9yZGVyLmF0KC0xKT8udXVpZCxcbiAgICAgICAgICAgIHRyYWNlX2lkOiB0cmFjZUlkLFxuICAgICAgICAgICAgZG90dGVkX29yZGVyOiBwYXJlbnREb3R0ZWRPcmRlcixcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHJhd0hlYWRlcnNbXCJiYWdnYWdlXCJdICYmIHR5cGVvZiByYXdIZWFkZXJzW1wiYmFnZ2FnZVwiXSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgY29uc3QgYmFnZ2FnZSA9IEJhZ2dhZ2UuZnJvbUhlYWRlcihyYXdIZWFkZXJzW1wiYmFnZ2FnZVwiXSk7XG4gICAgICAgICAgICBjb25maWcubWV0YWRhdGEgPSBiYWdnYWdlLm1ldGFkYXRhO1xuICAgICAgICAgICAgY29uZmlnLnRhZ3MgPSBiYWdnYWdlLnRhZ3M7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBSdW5UcmVlKGNvbmZpZyk7XG4gICAgfVxuICAgIHRvSGVhZGVycyhoZWFkZXJzKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAgICAgICAgIFwibGFuZ3NtaXRoLXRyYWNlXCI6IHRoaXMuZG90dGVkX29yZGVyLFxuICAgICAgICAgICAgYmFnZ2FnZTogbmV3IEJhZ2dhZ2UodGhpcy5leHRyYT8ubWV0YWRhdGEsIHRoaXMudGFncykudG9IZWFkZXIoKSxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGhlYWRlcnMpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKHJlc3VsdCkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJzLnNldChrZXksIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbn1cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShSdW5UcmVlLCBcInNoYXJlZENsaWVudFwiLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgd3JpdGFibGU6IHRydWUsXG4gICAgdmFsdWU6IG51bGxcbn0pO1xuZXhwb3J0IGZ1bmN0aW9uIGlzUnVuVHJlZSh4KSB7XG4gICAgcmV0dXJuICh4ICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgdHlwZW9mIHguY3JlYXRlQ2hpbGQgPT09IFwiZnVuY3Rpb25cIiAmJlxuICAgICAgICB0eXBlb2YgeC5wb3N0UnVuID09PSBcImZ1bmN0aW9uXCIpO1xufVxuZnVuY3Rpb24gaXNMYW5nQ2hhaW5UcmFjZXJMaWtlKHgpIHtcbiAgICByZXR1cm4gKHR5cGVvZiB4ID09PSBcIm9iamVjdFwiICYmXG4gICAgICAgIHggIT0gbnVsbCAmJlxuICAgICAgICB0eXBlb2YgeC5uYW1lID09PSBcInN0cmluZ1wiICYmXG4gICAgICAgIHgubmFtZSA9PT0gXCJsYW5nY2hhaW5fdHJhY2VyXCIpO1xufVxuZnVuY3Rpb24gY29udGFpbnNMYW5nQ2hhaW5UcmFjZXJMaWtlKHgpIHtcbiAgICByZXR1cm4gKEFycmF5LmlzQXJyYXkoeCkgJiYgeC5zb21lKChjYWxsYmFjaykgPT4gaXNMYW5nQ2hhaW5UcmFjZXJMaWtlKGNhbGxiYWNrKSkpO1xufVxuZnVuY3Rpb24gaXNDYWxsYmFja01hbmFnZXJMaWtlKHgpIHtcbiAgICByZXR1cm4gKHR5cGVvZiB4ID09PSBcIm9iamVjdFwiICYmXG4gICAgICAgIHggIT0gbnVsbCAmJlxuICAgICAgICBBcnJheS5pc0FycmF5KHguaGFuZGxlcnMpKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBpc1J1bm5hYmxlQ29uZmlnTGlrZSh4KSB7XG4gICAgLy8gQ2hlY2sgdGhhdCBpdCdzIGFuIG9iamVjdCB3aXRoIGEgY2FsbGJhY2tzIGFyZ1xuICAgIC8vIHRoYXQgaGFzIGVpdGhlciBhIENhbGxiYWNrTWFuYWdlckxpa2Ugb2JqZWN0IHdpdGggYSBsYW5nY2hhaW4gdHJhY2VyIHdpdGhpbiBpdFxuICAgIC8vIG9yIGFuIGFycmF5IHdpdGggYSBMYW5nQ2hhaW5UcmFjZXJMaWtlIG9iamVjdCB3aXRoaW4gaXRcbiAgICByZXR1cm4gKHggIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICB0eXBlb2YgeC5jYWxsYmFja3MgPT09IFwib2JqZWN0XCIgJiZcbiAgICAgICAgLy8gQ2FsbGJhY2sgbWFuYWdlciB3aXRoIGEgbGFuZ2NoYWluIHRyYWNlclxuICAgICAgICAoY29udGFpbnNMYW5nQ2hhaW5UcmFjZXJMaWtlKHguY2FsbGJhY2tzPy5oYW5kbGVycykgfHxcbiAgICAgICAgICAgIC8vIE9yIGl0J3MgYW4gYXJyYXkgd2l0aCBhIExhbmdDaGFpblRyYWNlckxpa2Ugb2JqZWN0IHdpdGhpbiBpdFxuICAgICAgICAgICAgY29udGFpbnNMYW5nQ2hhaW5UcmFjZXJMaWtlKHguY2FsbGJhY2tzKSkpO1xufVxuIl0sIm5hbWVzIjpbInV1aWQiLCJnZXRFbnZpcm9ubWVudFZhcmlhYmxlIiwiZ2V0TGFuZ1NtaXRoRW52aXJvbm1lbnRWYXJpYWJsZSIsImdldFJ1bnRpbWVFbnZpcm9ubWVudCIsIkNsaWVudCIsImlzVHJhY2luZ0VuYWJsZWQiLCJ3YXJuT25jZSIsIl9MQ19DT05URVhUX1ZBUklBQkxFU19LRVkiLCJzdHJpcE5vbkFscGhhbnVtZXJpYyIsImlucHV0IiwicmVwbGFjZSIsImNvbnZlcnRUb0RvdHRlZE9yZGVyRm9ybWF0IiwiZXBvY2giLCJydW5JZCIsImV4ZWN1dGlvbk9yZGVyIiwicGFkZGVkT3JkZXIiLCJ0b0ZpeGVkIiwic2xpY2UiLCJwYWRTdGFydCIsIkRhdGUiLCJ0b0lTT1N0cmluZyIsIkJhZ2dhZ2UiLCJjb25zdHJ1Y3RvciIsIm1ldGFkYXRhIiwidGFncyIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZW51bWVyYWJsZSIsImNvbmZpZ3VyYWJsZSIsIndyaXRhYmxlIiwidmFsdWUiLCJmcm9tSGVhZGVyIiwiaXRlbXMiLCJzcGxpdCIsIml0ZW0iLCJrZXkiLCJ1cmlWYWx1ZSIsImRlY29kZVVSSUNvbXBvbmVudCIsIkpTT04iLCJwYXJzZSIsInRvSGVhZGVyIiwia2V5cyIsImxlbmd0aCIsInB1c2giLCJlbmNvZGVVUklDb21wb25lbnQiLCJzdHJpbmdpZnkiLCJqb2luIiwiUnVuVHJlZSIsIm9yaWdpbmFsQ29uZmlnIiwiaXNSdW5UcmVlIiwiYXNzaWduIiwiZGVmYXVsdENvbmZpZyIsImdldERlZmF1bHRDb25maWciLCJjb25maWciLCJjbGllbnQiLCJnZXRTaGFyZWRDbGllbnQiLCJkZWR1cGVkTWV0YWRhdGEiLCJleHRyYSIsInRyYWNlX2lkIiwicGFyZW50X3J1biIsImlkIiwiZXhlY3V0aW9uX29yZGVyIiwiY2hpbGRfZXhlY3V0aW9uX29yZGVyIiwiZG90dGVkX29yZGVyIiwiY3VycmVudERvdHRlZE9yZGVyIiwic3RhcnRfdGltZSIsInY0IiwicnVuX3R5cGUiLCJwcm9qZWN0X25hbWUiLCJjaGlsZF9ydW5zIiwiYXBpX3VybCIsImFwaV9rZXkiLCJjYWxsZXJfb3B0aW9ucyIsIm5vdyIsInNlcmlhbGl6ZWQiLCJpbnB1dHMiLCJzaGFyZWRDbGllbnQiLCJjcmVhdGVDaGlsZCIsImNoaWxkIiwidHJhY2luZ0VuYWJsZWQiLCJMQ19DSElMRCIsIlN5bWJvbCIsImZvciIsInByZXNlbnRDb25maWciLCJpc1J1bm5hYmxlQ29uZmlnTGlrZSIsIm5ld0NvbmZpZyIsImNhbGxiYWNrcyIsImlzQ2FsbGJhY2tNYW5hZ2VyTGlrZSIsImNvcHkiLCJ1bmRlZmluZWQiLCJfcGFyZW50UnVuSWQiLCJoYW5kbGVycyIsImZpbmQiLCJpc0xhbmdDaGFpblRyYWNlckxpa2UiLCJ1cGRhdGVGcm9tUnVuVHJlZSIsInZpc2l0ZWQiLCJTZXQiLCJjdXJyZW50IiwiaGFzIiwiYWRkIiwiTWF0aCIsIm1heCIsImVuZCIsIm91dHB1dHMiLCJlcnJvciIsImVuZFRpbWUiLCJlbmRfdGltZSIsIl9jb252ZXJ0VG9DcmVhdGUiLCJydW4iLCJydW50aW1lRW52IiwiZXhjbHVkZUNoaWxkUnVucyIsInJ1bkV4dHJhIiwicnVudGltZSIsImsiLCJ2IiwiZW50cmllcyIsInBhcmVudF9ydW5faWQiLCJtYXAiLCJjaGlsZF9ydW4iLCJwZXJzaXN0ZWRSdW4iLCJuYW1lIiwicmVmZXJlbmNlX2V4YW1wbGVfaWQiLCJzZXNzaW9uX25hbWUiLCJhdHRhY2htZW50cyIsInBvc3RSdW4iLCJydW5DcmVhdGUiLCJjcmVhdGVSdW4iLCJjaGlsZFJ1biIsImNvbnNvbGUiLCJwYXRjaFJ1biIsInJ1blVwZGF0ZSIsImV2ZW50cyIsInVwZGF0ZVJ1biIsInRvSlNPTiIsImFkZEV2ZW50IiwiZXZlbnQiLCJ0aW1lIiwibWVzc2FnZSIsImZyb21SdW5uYWJsZUNvbmZpZyIsInBhcmVudENvbmZpZyIsInByb3BzIiwiY2FsbGJhY2tNYW5hZ2VyIiwicGFyZW50UnVuIiwicHJvamVjdE5hbWUiLCJwYXJlbnRSdW5JZCIsImdldFBhcmVudFJ1bklkIiwibGFuZ0NoYWluVHJhY2VyIiwiaGFuZGxlciIsImdldFJ1biIsInBhcmVudFJ1blRyZWUiLCJjb25jYXQiLCJmcm9tRG90dGVkT3JkZXIiLCJkb3R0ZWRPcmRlciIsImZyb21IZWFkZXJzIiwiaGVhZGVycyIsImluaGVyaXRBcmdzIiwicmF3SGVhZGVycyIsImdldCIsImJhZ2dhZ2UiLCJoZWFkZXJUcmFjZSIsInBhcmVudERvdHRlZE9yZGVyIiwidHJpbSIsInBhcnNlZERvdHRlZE9yZGVyIiwicGFydCIsInN0clRpbWUiLCJ0cmFjZUlkIiwiYXQiLCJ0b0hlYWRlcnMiLCJyZXN1bHQiLCJzZXQiLCJ4IiwiY29udGFpbnNMYW5nQ2hhaW5UcmFjZXJMaWtlIiwiQXJyYXkiLCJpc0FycmF5Iiwic29tZSIsImNhbGxiYWNrIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/langsmith/dist/run_trees.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/langsmith/dist/singletons/constants.js":
/*!*************************************************************!*\
  !*** ./node_modules/langsmith/dist/singletons/constants.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   _LC_CONTEXT_VARIABLES_KEY: () => (/* binding */ _LC_CONTEXT_VARIABLES_KEY)\n/* harmony export */ });\nconst _LC_CONTEXT_VARIABLES_KEY = Symbol.for(\"lc:context_variables\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL2Rpc3Qvc2luZ2xldG9ucy9jb25zdGFudHMuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFPLE1BQU1BLDRCQUE0QkMsT0FBT0MsR0FBRyxDQUFDLHdCQUF3QiIsInNvdXJjZXMiOlsid2VicGFjazovL2FpLW1hcmtldC1yZXNlYXJjaC1hZ2VudC8uL25vZGVfbW9kdWxlcy9sYW5nc21pdGgvZGlzdC9zaW5nbGV0b25zL2NvbnN0YW50cy5qcz8xZGE0Il0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBjb25zdCBfTENfQ09OVEVYVF9WQVJJQUJMRVNfS0VZID0gU3ltYm9sLmZvcihcImxjOmNvbnRleHRfdmFyaWFibGVzXCIpO1xuIl0sIm5hbWVzIjpbIl9MQ19DT05URVhUX1ZBUklBQkxFU19LRVkiLCJTeW1ib2wiLCJmb3IiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/langsmith/dist/singletons/constants.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/langsmith/dist/singletons/fetch.js":
/*!*********************************************************!*\
  !*** ./node_modules/langsmith/dist/singletons/fetch.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   _getFetchImplementation: () => (/* binding */ _getFetchImplementation),\n/* harmony export */   overrideFetchImplementation: () => (/* binding */ overrideFetchImplementation)\n/* harmony export */ });\n// Wrap the default fetch call due to issues with illegal invocations\n// in some environments:\n// https://stackoverflow.com/questions/69876859/why-does-bind-fix-failed-to-execute-fetch-on-window-illegal-invocation-err\n// @ts-expect-error Broad typing to support a range of fetch implementations\nconst DEFAULT_FETCH_IMPLEMENTATION = (...args)=>fetch(...args);\nconst LANGSMITH_FETCH_IMPLEMENTATION_KEY = Symbol.for(\"ls:fetch_implementation\");\n/**\n * Overrides the fetch implementation used for LangSmith calls.\n * You should use this if you need to use an implementation of fetch\n * other than the default global (e.g. for dealing with proxies).\n * @param fetch The new fetch functino to use.\n */ const overrideFetchImplementation = (fetch1)=>{\n    globalThis[LANGSMITH_FETCH_IMPLEMENTATION_KEY] = fetch1;\n};\n/**\n * @internal\n */ const _getFetchImplementation = ()=>{\n    return globalThis[LANGSMITH_FETCH_IMPLEMENTATION_KEY] ?? DEFAULT_FETCH_IMPLEMENTATION;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL2Rpc3Qvc2luZ2xldG9ucy9mZXRjaC5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBLHFFQUFxRTtBQUNyRSx3QkFBd0I7QUFDeEIsMEhBQTBIO0FBQzFILDRFQUE0RTtBQUM1RSxNQUFNQSwrQkFBK0IsQ0FBQyxHQUFHQyxPQUFTQyxTQUFTRDtBQUMzRCxNQUFNRSxxQ0FBcUNDLE9BQU9DLEdBQUcsQ0FBQztBQUN0RDs7Ozs7Q0FLQyxHQUNNLE1BQU1DLDhCQUE4QixDQUFDSjtJQUN4Q0ssVUFBVSxDQUFDSixtQ0FBbUMsR0FBR0Q7QUFDckQsRUFBRTtBQUNGOztDQUVDLEdBQ00sTUFBTU0sMEJBQTBCO0lBQ25DLE9BQVFELFVBQVUsQ0FBQ0osbUNBQW1DLElBQ2xESDtBQUNSLEVBQUUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9haS1tYXJrZXQtcmVzZWFyY2gtYWdlbnQvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL2Rpc3Qvc2luZ2xldG9ucy9mZXRjaC5qcz83NjJjIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIFdyYXAgdGhlIGRlZmF1bHQgZmV0Y2ggY2FsbCBkdWUgdG8gaXNzdWVzIHdpdGggaWxsZWdhbCBpbnZvY2F0aW9uc1xuLy8gaW4gc29tZSBlbnZpcm9ubWVudHM6XG4vLyBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy82OTg3Njg1OS93aHktZG9lcy1iaW5kLWZpeC1mYWlsZWQtdG8tZXhlY3V0ZS1mZXRjaC1vbi13aW5kb3ctaWxsZWdhbC1pbnZvY2F0aW9uLWVyclxuLy8gQHRzLWV4cGVjdC1lcnJvciBCcm9hZCB0eXBpbmcgdG8gc3VwcG9ydCBhIHJhbmdlIG9mIGZldGNoIGltcGxlbWVudGF0aW9uc1xuY29uc3QgREVGQVVMVF9GRVRDSF9JTVBMRU1FTlRBVElPTiA9ICguLi5hcmdzKSA9PiBmZXRjaCguLi5hcmdzKTtcbmNvbnN0IExBTkdTTUlUSF9GRVRDSF9JTVBMRU1FTlRBVElPTl9LRVkgPSBTeW1ib2wuZm9yKFwibHM6ZmV0Y2hfaW1wbGVtZW50YXRpb25cIik7XG4vKipcbiAqIE92ZXJyaWRlcyB0aGUgZmV0Y2ggaW1wbGVtZW50YXRpb24gdXNlZCBmb3IgTGFuZ1NtaXRoIGNhbGxzLlxuICogWW91IHNob3VsZCB1c2UgdGhpcyBpZiB5b3UgbmVlZCB0byB1c2UgYW4gaW1wbGVtZW50YXRpb24gb2YgZmV0Y2hcbiAqIG90aGVyIHRoYW4gdGhlIGRlZmF1bHQgZ2xvYmFsIChlLmcuIGZvciBkZWFsaW5nIHdpdGggcHJveGllcykuXG4gKiBAcGFyYW0gZmV0Y2ggVGhlIG5ldyBmZXRjaCBmdW5jdGlubyB0byB1c2UuXG4gKi9cbmV4cG9ydCBjb25zdCBvdmVycmlkZUZldGNoSW1wbGVtZW50YXRpb24gPSAoZmV0Y2gpID0+IHtcbiAgICBnbG9iYWxUaGlzW0xBTkdTTUlUSF9GRVRDSF9JTVBMRU1FTlRBVElPTl9LRVldID0gZmV0Y2g7XG59O1xuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZXhwb3J0IGNvbnN0IF9nZXRGZXRjaEltcGxlbWVudGF0aW9uID0gKCkgPT4ge1xuICAgIHJldHVybiAoZ2xvYmFsVGhpc1tMQU5HU01JVEhfRkVUQ0hfSU1QTEVNRU5UQVRJT05fS0VZXSA/P1xuICAgICAgICBERUZBVUxUX0ZFVENIX0lNUExFTUVOVEFUSU9OKTtcbn07XG4iXSwibmFtZXMiOlsiREVGQVVMVF9GRVRDSF9JTVBMRU1FTlRBVElPTiIsImFyZ3MiLCJmZXRjaCIsIkxBTkdTTUlUSF9GRVRDSF9JTVBMRU1FTlRBVElPTl9LRVkiLCJTeW1ib2wiLCJmb3IiLCJvdmVycmlkZUZldGNoSW1wbGVtZW50YXRpb24iLCJnbG9iYWxUaGlzIiwiX2dldEZldGNoSW1wbGVtZW50YXRpb24iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/langsmith/dist/singletons/fetch.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/langsmith/dist/singletons/traceable.js":
/*!*************************************************************!*\
  !*** ./node_modules/langsmith/dist/singletons/traceable.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AsyncLocalStorageProviderSingleton: () => (/* binding */ AsyncLocalStorageProviderSingleton),\n/* harmony export */   ROOT: () => (/* binding */ ROOT),\n/* harmony export */   getCurrentRunTree: () => (/* binding */ getCurrentRunTree),\n/* harmony export */   isTraceableFunction: () => (/* binding */ isTraceableFunction),\n/* harmony export */   withRunTree: () => (/* binding */ withRunTree)\n/* harmony export */ });\n/* harmony import */ var _run_trees_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../run_trees.js */ \"(rsc)/./node_modules/langsmith/dist/run_trees.js\");\n\nclass MockAsyncLocalStorage {\n    getStore() {\n        return undefined;\n    }\n    run(_, callback) {\n        return callback();\n    }\n}\nconst TRACING_ALS_KEY = Symbol.for(\"ls:tracing_async_local_storage\");\nconst mockAsyncLocalStorage = new MockAsyncLocalStorage();\nclass AsyncLocalStorageProvider {\n    getInstance() {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        return globalThis[TRACING_ALS_KEY] ?? mockAsyncLocalStorage;\n    }\n    initializeGlobalInstance(instance) {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        if (globalThis[TRACING_ALS_KEY] === undefined) {\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            globalThis[TRACING_ALS_KEY] = instance;\n        }\n    }\n}\nconst AsyncLocalStorageProviderSingleton = new AsyncLocalStorageProvider();\n/**\n * Return the current run tree from within a traceable-wrapped function.\n * Will throw an error if called outside of a traceable function.\n *\n * @returns The run tree for the given context.\n */ const getCurrentRunTree = ()=>{\n    const runTree = AsyncLocalStorageProviderSingleton.getInstance().getStore();\n    if (!(0,_run_trees_js__WEBPACK_IMPORTED_MODULE_0__.isRunTree)(runTree)) {\n        throw new Error([\n            \"Could not get the current run tree.\",\n            \"\",\n            \"Please make sure you are calling this method within a traceable function and that tracing is enabled.\"\n        ].join(\"\\n\"));\n    }\n    return runTree;\n};\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction withRunTree(runTree, fn) {\n    const storage = AsyncLocalStorageProviderSingleton.getInstance();\n    return new Promise((resolve, reject)=>{\n        storage.run(runTree, ()=>void Promise.resolve(fn()).then(resolve).catch(reject));\n    });\n}\nconst ROOT = Symbol.for(\"langsmith:traceable:root\");\nfunction isTraceableFunction(x) {\n    return typeof x === \"function\" && \"langsmith:traceable\" in x;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL2Rpc3Qvc2luZ2xldG9ucy90cmFjZWFibGUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQTRDO0FBQzVDLE1BQU1DO0lBQ0ZDLFdBQVc7UUFDUCxPQUFPQztJQUNYO0lBQ0FDLElBQUlDLENBQUMsRUFBRUMsUUFBUSxFQUFFO1FBQ2IsT0FBT0E7SUFDWDtBQUNKO0FBQ0EsTUFBTUMsa0JBQWtCQyxPQUFPQyxHQUFHLENBQUM7QUFDbkMsTUFBTUMsd0JBQXdCLElBQUlUO0FBQ2xDLE1BQU1VO0lBQ0ZDLGNBQWM7UUFDViw4REFBOEQ7UUFDOUQsT0FBT0MsVUFBVSxDQUFDTixnQkFBZ0IsSUFBSUc7SUFDMUM7SUFDQUkseUJBQXlCQyxRQUFRLEVBQUU7UUFDL0IsOERBQThEO1FBQzlELElBQUlGLFVBQVUsQ0FBQ04sZ0JBQWdCLEtBQUtKLFdBQVc7WUFDM0MsOERBQThEO1lBQzlEVSxVQUFVLENBQUNOLGdCQUFnQixHQUFHUTtRQUNsQztJQUNKO0FBQ0o7QUFDTyxNQUFNQyxxQ0FBcUMsSUFBSUwsNEJBQTRCO0FBQ2xGOzs7OztDQUtDLEdBQ00sTUFBTU0sb0JBQW9CO0lBQzdCLE1BQU1DLFVBQVVGLG1DQUFtQ0osV0FBVyxHQUFHVixRQUFRO0lBQ3pFLElBQUksQ0FBQ0Ysd0RBQVNBLENBQUNrQixVQUFVO1FBQ3JCLE1BQU0sSUFBSUMsTUFBTTtZQUNaO1lBQ0E7WUFDQTtTQUNILENBQUNDLElBQUksQ0FBQztJQUNYO0lBQ0EsT0FBT0Y7QUFDWCxFQUFFO0FBQ0YsOERBQThEO0FBQ3ZELFNBQVNHLFlBQVlILE9BQU8sRUFBRUksRUFBRTtJQUNuQyxNQUFNQyxVQUFVUCxtQ0FBbUNKLFdBQVc7SUFDOUQsT0FBTyxJQUFJWSxRQUFRLENBQUNDLFNBQVNDO1FBQ3pCSCxRQUFRbkIsR0FBRyxDQUFDYyxTQUFTLElBQU0sS0FBS00sUUFBUUMsT0FBTyxDQUFDSCxNQUFNSyxJQUFJLENBQUNGLFNBQVNHLEtBQUssQ0FBQ0Y7SUFDOUU7QUFDSjtBQUNPLE1BQU1HLE9BQU9yQixPQUFPQyxHQUFHLENBQUMsNEJBQTRCO0FBQ3BELFNBQVNxQixvQkFBb0JDLENBQUM7SUFHakMsT0FBTyxPQUFPQSxNQUFNLGNBQWMseUJBQXlCQTtBQUMvRCIsInNvdXJjZXMiOlsid2VicGFjazovL2FpLW1hcmtldC1yZXNlYXJjaC1hZ2VudC8uL25vZGVfbW9kdWxlcy9sYW5nc21pdGgvZGlzdC9zaW5nbGV0b25zL3RyYWNlYWJsZS5qcz83MjIzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGlzUnVuVHJlZSB9IGZyb20gXCIuLi9ydW5fdHJlZXMuanNcIjtcbmNsYXNzIE1vY2tBc3luY0xvY2FsU3RvcmFnZSB7XG4gICAgZ2V0U3RvcmUoKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHJ1bihfLCBjYWxsYmFjaykge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2soKTtcbiAgICB9XG59XG5jb25zdCBUUkFDSU5HX0FMU19LRVkgPSBTeW1ib2wuZm9yKFwibHM6dHJhY2luZ19hc3luY19sb2NhbF9zdG9yYWdlXCIpO1xuY29uc3QgbW9ja0FzeW5jTG9jYWxTdG9yYWdlID0gbmV3IE1vY2tBc3luY0xvY2FsU3RvcmFnZSgpO1xuY2xhc3MgQXN5bmNMb2NhbFN0b3JhZ2VQcm92aWRlciB7XG4gICAgZ2V0SW5zdGFuY2UoKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgIHJldHVybiBnbG9iYWxUaGlzW1RSQUNJTkdfQUxTX0tFWV0gPz8gbW9ja0FzeW5jTG9jYWxTdG9yYWdlO1xuICAgIH1cbiAgICBpbml0aWFsaXplR2xvYmFsSW5zdGFuY2UoaW5zdGFuY2UpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgaWYgKGdsb2JhbFRoaXNbVFJBQ0lOR19BTFNfS0VZXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAgICAgZ2xvYmFsVGhpc1tUUkFDSU5HX0FMU19LRVldID0gaW5zdGFuY2U7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnQgY29uc3QgQXN5bmNMb2NhbFN0b3JhZ2VQcm92aWRlclNpbmdsZXRvbiA9IG5ldyBBc3luY0xvY2FsU3RvcmFnZVByb3ZpZGVyKCk7XG4vKipcbiAqIFJldHVybiB0aGUgY3VycmVudCBydW4gdHJlZSBmcm9tIHdpdGhpbiBhIHRyYWNlYWJsZS13cmFwcGVkIGZ1bmN0aW9uLlxuICogV2lsbCB0aHJvdyBhbiBlcnJvciBpZiBjYWxsZWQgb3V0c2lkZSBvZiBhIHRyYWNlYWJsZSBmdW5jdGlvbi5cbiAqXG4gKiBAcmV0dXJucyBUaGUgcnVuIHRyZWUgZm9yIHRoZSBnaXZlbiBjb250ZXh0LlxuICovXG5leHBvcnQgY29uc3QgZ2V0Q3VycmVudFJ1blRyZWUgPSAoKSA9PiB7XG4gICAgY29uc3QgcnVuVHJlZSA9IEFzeW5jTG9jYWxTdG9yYWdlUHJvdmlkZXJTaW5nbGV0b24uZ2V0SW5zdGFuY2UoKS5nZXRTdG9yZSgpO1xuICAgIGlmICghaXNSdW5UcmVlKHJ1blRyZWUpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihbXG4gICAgICAgICAgICBcIkNvdWxkIG5vdCBnZXQgdGhlIGN1cnJlbnQgcnVuIHRyZWUuXCIsXG4gICAgICAgICAgICBcIlwiLFxuICAgICAgICAgICAgXCJQbGVhc2UgbWFrZSBzdXJlIHlvdSBhcmUgY2FsbGluZyB0aGlzIG1ldGhvZCB3aXRoaW4gYSB0cmFjZWFibGUgZnVuY3Rpb24gYW5kIHRoYXQgdHJhY2luZyBpcyBlbmFibGVkLlwiLFxuICAgICAgICBdLmpvaW4oXCJcXG5cIikpO1xuICAgIH1cbiAgICByZXR1cm4gcnVuVHJlZTtcbn07XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuZXhwb3J0IGZ1bmN0aW9uIHdpdGhSdW5UcmVlKHJ1blRyZWUsIGZuKSB7XG4gICAgY29uc3Qgc3RvcmFnZSA9IEFzeW5jTG9jYWxTdG9yYWdlUHJvdmlkZXJTaW5nbGV0b24uZ2V0SW5zdGFuY2UoKTtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICBzdG9yYWdlLnJ1bihydW5UcmVlLCAoKSA9PiB2b2lkIFByb21pc2UucmVzb2x2ZShmbigpKS50aGVuKHJlc29sdmUpLmNhdGNoKHJlamVjdCkpO1xuICAgIH0pO1xufVxuZXhwb3J0IGNvbnN0IFJPT1QgPSBTeW1ib2wuZm9yKFwibGFuZ3NtaXRoOnRyYWNlYWJsZTpyb290XCIpO1xuZXhwb3J0IGZ1bmN0aW9uIGlzVHJhY2VhYmxlRnVuY3Rpb24oeFxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbikge1xuICAgIHJldHVybiB0eXBlb2YgeCA9PT0gXCJmdW5jdGlvblwiICYmIFwibGFuZ3NtaXRoOnRyYWNlYWJsZVwiIGluIHg7XG59XG4iXSwibmFtZXMiOlsiaXNSdW5UcmVlIiwiTW9ja0FzeW5jTG9jYWxTdG9yYWdlIiwiZ2V0U3RvcmUiLCJ1bmRlZmluZWQiLCJydW4iLCJfIiwiY2FsbGJhY2siLCJUUkFDSU5HX0FMU19LRVkiLCJTeW1ib2wiLCJmb3IiLCJtb2NrQXN5bmNMb2NhbFN0b3JhZ2UiLCJBc3luY0xvY2FsU3RvcmFnZVByb3ZpZGVyIiwiZ2V0SW5zdGFuY2UiLCJnbG9iYWxUaGlzIiwiaW5pdGlhbGl6ZUdsb2JhbEluc3RhbmNlIiwiaW5zdGFuY2UiLCJBc3luY0xvY2FsU3RvcmFnZVByb3ZpZGVyU2luZ2xldG9uIiwiZ2V0Q3VycmVudFJ1blRyZWUiLCJydW5UcmVlIiwiRXJyb3IiLCJqb2luIiwid2l0aFJ1blRyZWUiLCJmbiIsInN0b3JhZ2UiLCJQcm9taXNlIiwicmVzb2x2ZSIsInJlamVjdCIsInRoZW4iLCJjYXRjaCIsIlJPT1QiLCJpc1RyYWNlYWJsZUZ1bmN0aW9uIiwieCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/langsmith/dist/singletons/traceable.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/langsmith/dist/utils/_uuid.js":
/*!****************************************************!*\
  !*** ./node_modules/langsmith/dist/utils/_uuid.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   assertUuid: () => (/* binding */ assertUuid)\n/* harmony export */ });\n/* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! uuid */ \"(rsc)/./node_modules/uuid/dist/esm-node/validate.js\");\n\nfunction assertUuid(str, which) {\n    if (!uuid__WEBPACK_IMPORTED_MODULE_0__[\"default\"](str)) {\n        const msg = which !== undefined ? `Invalid UUID for ${which}: ${str}` : `Invalid UUID: ${str}`;\n        throw new Error(msg);\n    }\n    return str;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL2Rpc3QvdXRpbHMvX3V1aWQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBNkI7QUFDdEIsU0FBU0MsV0FBV0MsR0FBRyxFQUFFQyxLQUFLO0lBQ2pDLElBQUksQ0FBQ0gsNENBQWEsQ0FBQ0UsTUFBTTtRQUNyQixNQUFNRyxNQUFNRixVQUFVRyxZQUNoQixDQUFDLGlCQUFpQixFQUFFSCxNQUFNLEVBQUUsRUFBRUQsSUFBSSxDQUFDLEdBQ25DLENBQUMsY0FBYyxFQUFFQSxJQUFJLENBQUM7UUFDNUIsTUFBTSxJQUFJSyxNQUFNRjtJQUNwQjtJQUNBLE9BQU9IO0FBQ1giLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9haS1tYXJrZXQtcmVzZWFyY2gtYWdlbnQvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL2Rpc3QvdXRpbHMvX3V1aWQuanM/YzZiOSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyB1dWlkIGZyb20gXCJ1dWlkXCI7XG5leHBvcnQgZnVuY3Rpb24gYXNzZXJ0VXVpZChzdHIsIHdoaWNoKSB7XG4gICAgaWYgKCF1dWlkLnZhbGlkYXRlKHN0cikpIHtcbiAgICAgICAgY29uc3QgbXNnID0gd2hpY2ggIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgPyBgSW52YWxpZCBVVUlEIGZvciAke3doaWNofTogJHtzdHJ9YFxuICAgICAgICAgICAgOiBgSW52YWxpZCBVVUlEOiAke3N0cn1gO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbiAgICB9XG4gICAgcmV0dXJuIHN0cjtcbn1cbiJdLCJuYW1lcyI6WyJ1dWlkIiwiYXNzZXJ0VXVpZCIsInN0ciIsIndoaWNoIiwidmFsaWRhdGUiLCJtc2ciLCJ1bmRlZmluZWQiLCJFcnJvciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/langsmith/dist/utils/_uuid.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/langsmith/dist/utils/async_caller.js":
/*!***********************************************************!*\
  !*** ./node_modules/langsmith/dist/utils/async_caller.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AsyncCaller: () => (/* binding */ AsyncCaller)\n/* harmony export */ });\n/* harmony import */ var p_retry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! p-retry */ \"(rsc)/./node_modules/p-retry/index.js\");\n/* harmony import */ var p_queue__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! p-queue */ \"(rsc)/./node_modules/p-queue/dist/index.js\");\n/* harmony import */ var _singletons_fetch_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../singletons/fetch.js */ \"(rsc)/./node_modules/langsmith/dist/singletons/fetch.js\");\n\n\n\nconst STATUS_NO_RETRY = [\n    400,\n    401,\n    403,\n    404,\n    405,\n    406,\n    407,\n    408\n];\nconst STATUS_IGNORE = [\n    409\n];\n/**\n * A class that can be used to make async calls with concurrency and retry logic.\n *\n * This is useful for making calls to any kind of \"expensive\" external resource,\n * be it because it's rate-limited, subject to network issues, etc.\n *\n * Concurrent calls are limited by the `maxConcurrency` parameter, which defaults\n * to `Infinity`. This means that by default, all calls will be made in parallel.\n *\n * Retries are limited by the `maxRetries` parameter, which defaults to 6. This\n * means that by default, each call will be retried up to 6 times, with an\n * exponential backoff between each attempt.\n */ class AsyncCaller {\n    constructor(params){\n        Object.defineProperty(this, \"maxConcurrency\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"maxRetries\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"queue\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"onFailedResponseHook\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.maxConcurrency = params.maxConcurrency ?? Infinity;\n        this.maxRetries = params.maxRetries ?? 6;\n        if ( true) {\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            this.queue = new p_queue__WEBPACK_IMPORTED_MODULE_1__[\"default\"]({\n                concurrency: this.maxConcurrency\n            });\n        } else {\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            this.queue = new p_queue__WEBPACK_IMPORTED_MODULE_1__({\n                concurrency: this.maxConcurrency\n            });\n        }\n        this.onFailedResponseHook = params?.onFailedResponseHook;\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    call(callable, ...args) {\n        const onFailedResponseHook = this.onFailedResponseHook;\n        return this.queue.add(()=>p_retry__WEBPACK_IMPORTED_MODULE_0__(()=>callable(...args).catch((error)=>{\n                    // eslint-disable-next-line no-instanceof/no-instanceof\n                    if (error instanceof Error) {\n                        throw error;\n                    } else {\n                        throw new Error(error);\n                    }\n                }), {\n                async onFailedAttempt (error) {\n                    if (error.message.startsWith(\"Cancel\") || error.message.startsWith(\"TimeoutError\") || error.message.startsWith(\"AbortError\")) {\n                        throw error;\n                    }\n                    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                    if (error?.code === \"ECONNABORTED\") {\n                        throw error;\n                    }\n                    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                    const response = error?.response;\n                    const status = response?.status;\n                    if (status) {\n                        if (STATUS_NO_RETRY.includes(+status)) {\n                            throw error;\n                        } else if (STATUS_IGNORE.includes(+status)) {\n                            return;\n                        }\n                        if (onFailedResponseHook) {\n                            await onFailedResponseHook(response);\n                        }\n                    }\n                },\n                // If needed we can change some of the defaults here,\n                // but they're quite sensible.\n                retries: this.maxRetries,\n                randomize: true\n            }), {\n            throwOnTimeout: true\n        });\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    callWithOptions(options, callable, ...args) {\n        // Note this doesn't cancel the underlying request,\n        // when available prefer to use the signal option of the underlying call\n        if (options.signal) {\n            return Promise.race([\n                this.call(callable, ...args),\n                new Promise((_, reject)=>{\n                    options.signal?.addEventListener(\"abort\", ()=>{\n                        reject(new Error(\"AbortError\"));\n                    });\n                })\n            ]);\n        }\n        return this.call(callable, ...args);\n    }\n    fetch(...args) {\n        return this.call(()=>(0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_2__._getFetchImplementation)()(...args).then((res)=>res.ok ? res : Promise.reject(res)));\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL2Rpc3QvdXRpbHMvYXN5bmNfY2FsbGVyLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBNkI7QUFDRztBQUNpQztBQUNqRSxNQUFNRyxrQkFBa0I7SUFDcEI7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtDQUNIO0FBQ0QsTUFBTUMsZ0JBQWdCO0lBQ2xCO0NBQ0g7QUFDRDs7Ozs7Ozs7Ozs7O0NBWUMsR0FDTSxNQUFNQztJQUNUQyxZQUFZQyxNQUFNLENBQUU7UUFDaEJDLE9BQU9DLGNBQWMsQ0FBQyxJQUFJLEVBQUUsa0JBQWtCO1lBQzFDQyxZQUFZO1lBQ1pDLGNBQWM7WUFDZEMsVUFBVTtZQUNWQyxPQUFPLEtBQUs7UUFDaEI7UUFDQUwsT0FBT0MsY0FBYyxDQUFDLElBQUksRUFBRSxjQUFjO1lBQ3RDQyxZQUFZO1lBQ1pDLGNBQWM7WUFDZEMsVUFBVTtZQUNWQyxPQUFPLEtBQUs7UUFDaEI7UUFDQUwsT0FBT0MsY0FBYyxDQUFDLElBQUksRUFBRSxTQUFTO1lBQ2pDQyxZQUFZO1lBQ1pDLGNBQWM7WUFDZEMsVUFBVTtZQUNWQyxPQUFPLEtBQUs7UUFDaEI7UUFDQUwsT0FBT0MsY0FBYyxDQUFDLElBQUksRUFBRSx3QkFBd0I7WUFDaERDLFlBQVk7WUFDWkMsY0FBYztZQUNkQyxVQUFVO1lBQ1ZDLE9BQU8sS0FBSztRQUNoQjtRQUNBLElBQUksQ0FBQ0MsY0FBYyxHQUFHUCxPQUFPTyxjQUFjLElBQUlDO1FBQy9DLElBQUksQ0FBQ0MsVUFBVSxHQUFHVCxPQUFPUyxVQUFVLElBQUk7UUFDdkMsSUFBSSxLQUFzQmYsRUFBRTtZQUN4Qiw4REFBOEQ7WUFDOUQsSUFBSSxDQUFDZ0IsS0FBSyxHQUFHLElBQUloQiwrQ0FBaUIsQ0FBQztnQkFDL0JrQixhQUFhLElBQUksQ0FBQ0wsY0FBYztZQUNwQztRQUNKLE9BQ0s7WUFDRCw4REFBOEQ7WUFDOUQsSUFBSSxDQUFDRyxLQUFLLEdBQUcsSUFBSWhCLG9DQUFTQSxDQUFDO2dCQUFFa0IsYUFBYSxJQUFJLENBQUNMLGNBQWM7WUFBQztRQUNsRTtRQUNBLElBQUksQ0FBQ00sb0JBQW9CLEdBQUdiLFFBQVFhO0lBQ3hDO0lBQ0EsOERBQThEO0lBQzlEQyxLQUFLQyxRQUFRLEVBQUUsR0FBR0MsSUFBSSxFQUFFO1FBQ3BCLE1BQU1ILHVCQUF1QixJQUFJLENBQUNBLG9CQUFvQjtRQUN0RCxPQUFPLElBQUksQ0FBQ0gsS0FBSyxDQUFDTyxHQUFHLENBQUMsSUFBTXhCLG9DQUFNQSxDQUFDLElBQU1zQixZQUFZQyxNQUFNRSxLQUFLLENBQUMsQ0FBQ0M7b0JBQzlELHVEQUF1RDtvQkFDdkQsSUFBSUEsaUJBQWlCQyxPQUFPO3dCQUN4QixNQUFNRDtvQkFDVixPQUNLO3dCQUNELE1BQU0sSUFBSUMsTUFBTUQ7b0JBQ3BCO2dCQUNKLElBQUk7Z0JBQ0EsTUFBTUUsaUJBQWdCRixLQUFLO29CQUN2QixJQUFJQSxNQUFNRyxPQUFPLENBQUNDLFVBQVUsQ0FBQyxhQUN6QkosTUFBTUcsT0FBTyxDQUFDQyxVQUFVLENBQUMsbUJBQ3pCSixNQUFNRyxPQUFPLENBQUNDLFVBQVUsQ0FBQyxlQUFlO3dCQUN4QyxNQUFNSjtvQkFDVjtvQkFDQSw4REFBOEQ7b0JBQzlELElBQUlBLE9BQU9LLFNBQVMsZ0JBQWdCO3dCQUNoQyxNQUFNTDtvQkFDVjtvQkFDQSw4REFBOEQ7b0JBQzlELE1BQU1NLFdBQVdOLE9BQU9NO29CQUN4QixNQUFNQyxTQUFTRCxVQUFVQztvQkFDekIsSUFBSUEsUUFBUTt3QkFDUixJQUFJOUIsZ0JBQWdCK0IsUUFBUSxDQUFDLENBQUNELFNBQVM7NEJBQ25DLE1BQU1QO3dCQUNWLE9BQ0ssSUFBSXRCLGNBQWM4QixRQUFRLENBQUMsQ0FBQ0QsU0FBUzs0QkFDdEM7d0JBQ0o7d0JBQ0EsSUFBSWIsc0JBQXNCOzRCQUN0QixNQUFNQSxxQkFBcUJZO3dCQUMvQjtvQkFDSjtnQkFDSjtnQkFDQSxxREFBcUQ7Z0JBQ3JELDhCQUE4QjtnQkFDOUJHLFNBQVMsSUFBSSxDQUFDbkIsVUFBVTtnQkFDeEJvQixXQUFXO1lBQ2YsSUFBSTtZQUFFQyxnQkFBZ0I7UUFBSztJQUMvQjtJQUNBLDhEQUE4RDtJQUM5REMsZ0JBQWdCQyxPQUFPLEVBQUVqQixRQUFRLEVBQUUsR0FBR0MsSUFBSSxFQUFFO1FBQ3hDLG1EQUFtRDtRQUNuRCx3RUFBd0U7UUFDeEUsSUFBSWdCLFFBQVFDLE1BQU0sRUFBRTtZQUNoQixPQUFPQyxRQUFRQyxJQUFJLENBQUM7Z0JBQ2hCLElBQUksQ0FBQ3JCLElBQUksQ0FBQ0MsYUFBYUM7Z0JBQ3ZCLElBQUlrQixRQUFRLENBQUNFLEdBQUdDO29CQUNaTCxRQUFRQyxNQUFNLEVBQUVLLGlCQUFpQixTQUFTO3dCQUN0Q0QsT0FBTyxJQUFJakIsTUFBTTtvQkFDckI7Z0JBQ0o7YUFDSDtRQUNMO1FBQ0EsT0FBTyxJQUFJLENBQUNOLElBQUksQ0FBQ0MsYUFBYUM7SUFDbEM7SUFDQXVCLE1BQU0sR0FBR3ZCLElBQUksRUFBRTtRQUNYLE9BQU8sSUFBSSxDQUFDRixJQUFJLENBQUMsSUFBTW5CLDZFQUF1QkEsTUFBTXFCLE1BQU13QixJQUFJLENBQUMsQ0FBQ0MsTUFBUUEsSUFBSUMsRUFBRSxHQUFHRCxNQUFNUCxRQUFRRyxNQUFNLENBQUNJO0lBQzFHO0FBQ0oiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9haS1tYXJrZXQtcmVzZWFyY2gtYWdlbnQvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL2Rpc3QvdXRpbHMvYXN5bmNfY2FsbGVyLmpzP2E4ZDciXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHBSZXRyeSBmcm9tIFwicC1yZXRyeVwiO1xuaW1wb3J0IFBRdWV1ZU1vZCBmcm9tIFwicC1xdWV1ZVwiO1xuaW1wb3J0IHsgX2dldEZldGNoSW1wbGVtZW50YXRpb24gfSBmcm9tIFwiLi4vc2luZ2xldG9ucy9mZXRjaC5qc1wiO1xuY29uc3QgU1RBVFVTX05PX1JFVFJZID0gW1xuICAgIDQwMCwgLy8gQmFkIFJlcXVlc3RcbiAgICA0MDEsIC8vIFVuYXV0aG9yaXplZFxuICAgIDQwMywgLy8gRm9yYmlkZGVuXG4gICAgNDA0LCAvLyBOb3QgRm91bmRcbiAgICA0MDUsIC8vIE1ldGhvZCBOb3QgQWxsb3dlZFxuICAgIDQwNiwgLy8gTm90IEFjY2VwdGFibGVcbiAgICA0MDcsIC8vIFByb3h5IEF1dGhlbnRpY2F0aW9uIFJlcXVpcmVkXG4gICAgNDA4LCAvLyBSZXF1ZXN0IFRpbWVvdXRcbl07XG5jb25zdCBTVEFUVVNfSUdOT1JFID0gW1xuICAgIDQwOSwgLy8gQ29uZmxpY3Rcbl07XG4vKipcbiAqIEEgY2xhc3MgdGhhdCBjYW4gYmUgdXNlZCB0byBtYWtlIGFzeW5jIGNhbGxzIHdpdGggY29uY3VycmVuY3kgYW5kIHJldHJ5IGxvZ2ljLlxuICpcbiAqIFRoaXMgaXMgdXNlZnVsIGZvciBtYWtpbmcgY2FsbHMgdG8gYW55IGtpbmQgb2YgXCJleHBlbnNpdmVcIiBleHRlcm5hbCByZXNvdXJjZSxcbiAqIGJlIGl0IGJlY2F1c2UgaXQncyByYXRlLWxpbWl0ZWQsIHN1YmplY3QgdG8gbmV0d29yayBpc3N1ZXMsIGV0Yy5cbiAqXG4gKiBDb25jdXJyZW50IGNhbGxzIGFyZSBsaW1pdGVkIGJ5IHRoZSBgbWF4Q29uY3VycmVuY3lgIHBhcmFtZXRlciwgd2hpY2ggZGVmYXVsdHNcbiAqIHRvIGBJbmZpbml0eWAuIFRoaXMgbWVhbnMgdGhhdCBieSBkZWZhdWx0LCBhbGwgY2FsbHMgd2lsbCBiZSBtYWRlIGluIHBhcmFsbGVsLlxuICpcbiAqIFJldHJpZXMgYXJlIGxpbWl0ZWQgYnkgdGhlIGBtYXhSZXRyaWVzYCBwYXJhbWV0ZXIsIHdoaWNoIGRlZmF1bHRzIHRvIDYuIFRoaXNcbiAqIG1lYW5zIHRoYXQgYnkgZGVmYXVsdCwgZWFjaCBjYWxsIHdpbGwgYmUgcmV0cmllZCB1cCB0byA2IHRpbWVzLCB3aXRoIGFuXG4gKiBleHBvbmVudGlhbCBiYWNrb2ZmIGJldHdlZW4gZWFjaCBhdHRlbXB0LlxuICovXG5leHBvcnQgY2xhc3MgQXN5bmNDYWxsZXIge1xuICAgIGNvbnN0cnVjdG9yKHBhcmFtcykge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJtYXhDb25jdXJyZW5jeVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJtYXhSZXRyaWVzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInF1ZXVlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm9uRmFpbGVkUmVzcG9uc2VIb29rXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMubWF4Q29uY3VycmVuY3kgPSBwYXJhbXMubWF4Q29uY3VycmVuY3kgPz8gSW5maW5pdHk7XG4gICAgICAgIHRoaXMubWF4UmV0cmllcyA9IHBhcmFtcy5tYXhSZXRyaWVzID8/IDY7XG4gICAgICAgIGlmIChcImRlZmF1bHRcIiBpbiBQUXVldWVNb2QpIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgICB0aGlzLnF1ZXVlID0gbmV3IFBRdWV1ZU1vZC5kZWZhdWx0KHtcbiAgICAgICAgICAgICAgICBjb25jdXJyZW5jeTogdGhpcy5tYXhDb25jdXJyZW5jeSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgICAgIHRoaXMucXVldWUgPSBuZXcgUFF1ZXVlTW9kKHsgY29uY3VycmVuY3k6IHRoaXMubWF4Q29uY3VycmVuY3kgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vbkZhaWxlZFJlc3BvbnNlSG9vayA9IHBhcmFtcz8ub25GYWlsZWRSZXNwb25zZUhvb2s7XG4gICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgY2FsbChjYWxsYWJsZSwgLi4uYXJncykge1xuICAgICAgICBjb25zdCBvbkZhaWxlZFJlc3BvbnNlSG9vayA9IHRoaXMub25GYWlsZWRSZXNwb25zZUhvb2s7XG4gICAgICAgIHJldHVybiB0aGlzLnF1ZXVlLmFkZCgoKSA9PiBwUmV0cnkoKCkgPT4gY2FsbGFibGUoLi4uYXJncykuY2F0Y2goKGVycm9yKSA9PiB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8taW5zdGFuY2VvZi9uby1pbnN0YW5jZW9mXG4gICAgICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSksIHtcbiAgICAgICAgICAgIGFzeW5jIG9uRmFpbGVkQXR0ZW1wdChlcnJvcikge1xuICAgICAgICAgICAgICAgIGlmIChlcnJvci5tZXNzYWdlLnN0YXJ0c1dpdGgoXCJDYW5jZWxcIikgfHxcbiAgICAgICAgICAgICAgICAgICAgZXJyb3IubWVzc2FnZS5zdGFydHNXaXRoKFwiVGltZW91dEVycm9yXCIpIHx8XG4gICAgICAgICAgICAgICAgICAgIGVycm9yLm1lc3NhZ2Uuc3RhcnRzV2l0aChcIkFib3J0RXJyb3JcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgICAgICAgaWYgKGVycm9yPy5jb2RlID09PSBcIkVDT05OQUJPUlRFRFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gZXJyb3I/LnJlc3BvbnNlO1xuICAgICAgICAgICAgICAgIGNvbnN0IHN0YXR1cyA9IHJlc3BvbnNlPy5zdGF0dXM7XG4gICAgICAgICAgICAgICAgaWYgKHN0YXR1cykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoU1RBVFVTX05PX1JFVFJZLmluY2x1ZGVzKCtzdGF0dXMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChTVEFUVVNfSUdOT1JFLmluY2x1ZGVzKCtzdGF0dXMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9uRmFpbGVkUmVzcG9uc2VIb29rKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCBvbkZhaWxlZFJlc3BvbnNlSG9vayhyZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLy8gSWYgbmVlZGVkIHdlIGNhbiBjaGFuZ2Ugc29tZSBvZiB0aGUgZGVmYXVsdHMgaGVyZSxcbiAgICAgICAgICAgIC8vIGJ1dCB0aGV5J3JlIHF1aXRlIHNlbnNpYmxlLlxuICAgICAgICAgICAgcmV0cmllczogdGhpcy5tYXhSZXRyaWVzLFxuICAgICAgICAgICAgcmFuZG9taXplOiB0cnVlLFxuICAgICAgICB9KSwgeyB0aHJvd09uVGltZW91dDogdHJ1ZSB9KTtcbiAgICB9XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICBjYWxsV2l0aE9wdGlvbnMob3B0aW9ucywgY2FsbGFibGUsIC4uLmFyZ3MpIHtcbiAgICAgICAgLy8gTm90ZSB0aGlzIGRvZXNuJ3QgY2FuY2VsIHRoZSB1bmRlcmx5aW5nIHJlcXVlc3QsXG4gICAgICAgIC8vIHdoZW4gYXZhaWxhYmxlIHByZWZlciB0byB1c2UgdGhlIHNpZ25hbCBvcHRpb24gb2YgdGhlIHVuZGVybHlpbmcgY2FsbFxuICAgICAgICBpZiAob3B0aW9ucy5zaWduYWwpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJhY2UoW1xuICAgICAgICAgICAgICAgIHRoaXMuY2FsbChjYWxsYWJsZSwgLi4uYXJncyksXG4gICAgICAgICAgICAgICAgbmV3IFByb21pc2UoKF8sIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBvcHRpb25zLnNpZ25hbD8uYWRkRXZlbnRMaXN0ZW5lcihcImFib3J0XCIsICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoXCJBYm9ydEVycm9yXCIpKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5jYWxsKGNhbGxhYmxlLCAuLi5hcmdzKTtcbiAgICB9XG4gICAgZmV0Y2goLi4uYXJncykge1xuICAgICAgICByZXR1cm4gdGhpcy5jYWxsKCgpID0+IF9nZXRGZXRjaEltcGxlbWVudGF0aW9uKCkoLi4uYXJncykudGhlbigocmVzKSA9PiByZXMub2sgPyByZXMgOiBQcm9taXNlLnJlamVjdChyZXMpKSk7XG4gICAgfVxufVxuIl0sIm5hbWVzIjpbInBSZXRyeSIsIlBRdWV1ZU1vZCIsIl9nZXRGZXRjaEltcGxlbWVudGF0aW9uIiwiU1RBVFVTX05PX1JFVFJZIiwiU1RBVFVTX0lHTk9SRSIsIkFzeW5jQ2FsbGVyIiwiY29uc3RydWN0b3IiLCJwYXJhbXMiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImVudW1lcmFibGUiLCJjb25maWd1cmFibGUiLCJ3cml0YWJsZSIsInZhbHVlIiwibWF4Q29uY3VycmVuY3kiLCJJbmZpbml0eSIsIm1heFJldHJpZXMiLCJxdWV1ZSIsImRlZmF1bHQiLCJjb25jdXJyZW5jeSIsIm9uRmFpbGVkUmVzcG9uc2VIb29rIiwiY2FsbCIsImNhbGxhYmxlIiwiYXJncyIsImFkZCIsImNhdGNoIiwiZXJyb3IiLCJFcnJvciIsIm9uRmFpbGVkQXR0ZW1wdCIsIm1lc3NhZ2UiLCJzdGFydHNXaXRoIiwiY29kZSIsInJlc3BvbnNlIiwic3RhdHVzIiwiaW5jbHVkZXMiLCJyZXRyaWVzIiwicmFuZG9taXplIiwidGhyb3dPblRpbWVvdXQiLCJjYWxsV2l0aE9wdGlvbnMiLCJvcHRpb25zIiwic2lnbmFsIiwiUHJvbWlzZSIsInJhY2UiLCJfIiwicmVqZWN0IiwiYWRkRXZlbnRMaXN0ZW5lciIsImZldGNoIiwidGhlbiIsInJlcyIsIm9rIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/langsmith/dist/utils/async_caller.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/langsmith/dist/utils/env.js":
/*!**************************************************!*\
  !*** ./node_modules/langsmith/dist/utils/env.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getEnv: () => (/* binding */ getEnv),\n/* harmony export */   getEnvironmentVariable: () => (/* binding */ getEnvironmentVariable),\n/* harmony export */   getEnvironmentVariables: () => (/* binding */ getEnvironmentVariables),\n/* harmony export */   getLangChainEnvVars: () => (/* binding */ getLangChainEnvVars),\n/* harmony export */   getLangChainEnvVarsMetadata: () => (/* binding */ getLangChainEnvVarsMetadata),\n/* harmony export */   getLangSmithEnvironmentVariable: () => (/* binding */ getLangSmithEnvironmentVariable),\n/* harmony export */   getRuntimeEnvironment: () => (/* binding */ getRuntimeEnvironment),\n/* harmony export */   getShas: () => (/* binding */ getShas),\n/* harmony export */   isBrowser: () => (/* binding */ isBrowser),\n/* harmony export */   isDeno: () => (/* binding */ isDeno),\n/* harmony export */   isJsDom: () => (/* binding */ isJsDom),\n/* harmony export */   isNode: () => (/* binding */ isNode),\n/* harmony export */   isWebWorker: () => (/* binding */ isWebWorker),\n/* harmony export */   setEnvironmentVariable: () => (/* binding */ setEnvironmentVariable)\n/* harmony export */ });\n/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../index.js */ \"(rsc)/./node_modules/langsmith/dist/index.js\");\n// Inlined from https://github.com/flexdinesh/browser-or-node\n\nlet globalEnv;\nconst isBrowser = ()=> false && 0;\nconst isWebWorker = ()=>typeof globalThis === \"object\" && globalThis.constructor && globalThis.constructor.name === \"DedicatedWorkerGlobalScope\";\nconst isJsDom = ()=> false || typeof navigator !== \"undefined\" && (navigator.userAgent.includes(\"Node.js\") || navigator.userAgent.includes(\"jsdom\"));\n// Supabase Edge Function provides a `Deno` global object\n// without `version` property\nconst isDeno = ()=>typeof Deno !== \"undefined\";\n// Mark not-as-node if in Supabase Edge Function\nconst isNode = ()=>typeof process !== \"undefined\" && typeof process.versions !== \"undefined\" && typeof process.versions.node !== \"undefined\" && !isDeno();\nconst getEnv = ()=>{\n    if (globalEnv) {\n        return globalEnv;\n    }\n    if (isBrowser()) {\n        globalEnv = \"browser\";\n    } else if (isNode()) {\n        globalEnv = \"node\";\n    } else if (isWebWorker()) {\n        globalEnv = \"webworker\";\n    } else if (isJsDom()) {\n        globalEnv = \"jsdom\";\n    } else if (isDeno()) {\n        globalEnv = \"deno\";\n    } else {\n        globalEnv = \"other\";\n    }\n    return globalEnv;\n};\nlet runtimeEnvironment;\nfunction getRuntimeEnvironment() {\n    if (runtimeEnvironment === undefined) {\n        const env = getEnv();\n        const releaseEnv = getShas();\n        runtimeEnvironment = {\n            library: \"langsmith\",\n            runtime: env,\n            sdk: \"langsmith-js\",\n            sdk_version: _index_js__WEBPACK_IMPORTED_MODULE_0__.__version__,\n            ...releaseEnv\n        };\n    }\n    return runtimeEnvironment;\n}\n/**\n * Retrieves the LangChain-specific environment variables from the current runtime environment.\n * Sensitive keys (containing the word \"key\", \"token\", or \"secret\") have their values redacted for security.\n *\n * @returns {Record<string, string>}\n *  - A record of LangChain-specific environment variables.\n */ function getLangChainEnvVars() {\n    const allEnvVars = getEnvironmentVariables() || {};\n    const envVars = {};\n    for (const [key, value] of Object.entries(allEnvVars)){\n        if (key.startsWith(\"LANGCHAIN_\") && typeof value === \"string\") {\n            envVars[key] = value;\n        }\n    }\n    for(const key in envVars){\n        if ((key.toLowerCase().includes(\"key\") || key.toLowerCase().includes(\"secret\") || key.toLowerCase().includes(\"token\")) && typeof envVars[key] === \"string\") {\n            const value = envVars[key];\n            envVars[key] = value.slice(0, 2) + \"*\".repeat(value.length - 4) + value.slice(-2);\n        }\n    }\n    return envVars;\n}\n/**\n * Retrieves the LangChain-specific metadata from the current runtime environment.\n *\n * @returns {Record<string, string>}\n *  - A record of LangChain-specific metadata environment variables.\n */ function getLangChainEnvVarsMetadata() {\n    const allEnvVars = getEnvironmentVariables() || {};\n    const envVars = {};\n    const excluded = [\n        \"LANGCHAIN_API_KEY\",\n        \"LANGCHAIN_ENDPOINT\",\n        \"LANGCHAIN_TRACING_V2\",\n        \"LANGCHAIN_PROJECT\",\n        \"LANGCHAIN_SESSION\",\n        \"LANGSMITH_API_KEY\",\n        \"LANGSMITH_ENDPOINT\",\n        \"LANGSMITH_TRACING_V2\",\n        \"LANGSMITH_PROJECT\",\n        \"LANGSMITH_SESSION\"\n    ];\n    for (const [key, value] of Object.entries(allEnvVars)){\n        if ((key.startsWith(\"LANGCHAIN_\") || key.startsWith(\"LANGSMITH_\")) && typeof value === \"string\" && !excluded.includes(key) && !key.toLowerCase().includes(\"key\") && !key.toLowerCase().includes(\"secret\") && !key.toLowerCase().includes(\"token\")) {\n            if (key === \"LANGCHAIN_REVISION_ID\") {\n                envVars[\"revision_id\"] = value;\n            } else {\n                envVars[key] = value;\n            }\n        }\n    }\n    return envVars;\n}\n/**\n * Retrieves the environment variables from the current runtime environment.\n *\n * This function is designed to operate in a variety of JS environments,\n * including Node.js, Deno, browsers, etc.\n *\n * @returns {Record<string, string> | undefined}\n *  - A record of environment variables if available.\n *  - `undefined` if the environment does not support or allows access to environment variables.\n */ function getEnvironmentVariables() {\n    try {\n        // Check for Node.js environment\n        // eslint-disable-next-line no-process-env\n        if (typeof process !== \"undefined\" && process.env) {\n            // eslint-disable-next-line no-process-env\n            return Object.entries(process.env).reduce((acc, [key, value])=>{\n                acc[key] = String(value);\n                return acc;\n            }, {});\n        }\n        // For browsers and other environments, we may not have direct access to env variables\n        // Return undefined or any other fallback as required.\n        return undefined;\n    } catch (e) {\n        // Catch any errors that might occur while trying to access environment variables\n        return undefined;\n    }\n}\nfunction getEnvironmentVariable(name) {\n    // Certain Deno setups will throw an error if you try to access environment variables\n    // https://github.com/hwchase17/langchainjs/issues/1412\n    try {\n        return typeof process !== \"undefined\" ? process.env?.[name] : undefined;\n    } catch (e) {\n        return undefined;\n    }\n}\nfunction getLangSmithEnvironmentVariable(name) {\n    return getEnvironmentVariable(`LANGSMITH_${name}`) || getEnvironmentVariable(`LANGCHAIN_${name}`);\n}\nfunction setEnvironmentVariable(name, value) {\n    if (typeof process !== \"undefined\") {\n        // eslint-disable-next-line no-process-env\n        process.env[name] = value;\n    }\n}\nlet cachedCommitSHAs;\n/**\n * Get the Git commit SHA from common environment variables\n * used by different CI/CD platforms.\n * @returns {string | undefined} The Git commit SHA or undefined if not found.\n */ function getShas() {\n    if (cachedCommitSHAs !== undefined) {\n        return cachedCommitSHAs;\n    }\n    const common_release_envs = [\n        \"VERCEL_GIT_COMMIT_SHA\",\n        \"NEXT_PUBLIC_VERCEL_GIT_COMMIT_SHA\",\n        \"COMMIT_REF\",\n        \"RENDER_GIT_COMMIT\",\n        \"CI_COMMIT_SHA\",\n        \"CIRCLE_SHA1\",\n        \"CF_PAGES_COMMIT_SHA\",\n        \"REACT_APP_GIT_SHA\",\n        \"SOURCE_VERSION\",\n        \"GITHUB_SHA\",\n        \"TRAVIS_COMMIT\",\n        \"GIT_COMMIT\",\n        \"BUILD_VCS_NUMBER\",\n        \"bamboo_planRepository_revision\",\n        \"Build.SourceVersion\",\n        \"BITBUCKET_COMMIT\",\n        \"DRONE_COMMIT_SHA\",\n        \"SEMAPHORE_GIT_SHA\",\n        \"BUILDKITE_COMMIT\"\n    ];\n    const shas = {};\n    for (const env of common_release_envs){\n        const envVar = getEnvironmentVariable(env);\n        if (envVar !== undefined) {\n            shas[env] = envVar;\n        }\n    }\n    cachedCommitSHAs = shas;\n    return shas;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL2Rpc3QvdXRpbHMvZW52LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLDZEQUE2RDtBQUNuQjtBQUMxQyxJQUFJQztBQUNHLE1BQU1DLFlBQVksSUFBTSxNQUE2QixJQUFJLENBQXNDLENBQUM7QUFDaEcsTUFBTUcsY0FBYyxJQUFNLE9BQU9DLGVBQWUsWUFDbkRBLFdBQVdDLFdBQVcsSUFDdEJELFdBQVdDLFdBQVcsQ0FBQ0MsSUFBSSxLQUFLLDZCQUE2QjtBQUMxRCxNQUFNQyxVQUFVLElBQU0sTUFBMEQsSUFDbEYsT0FBT0MsY0FBYyxlQUNqQkEsQ0FBQUEsVUFBVUMsU0FBUyxDQUFDQyxRQUFRLENBQUMsY0FDMUJGLFVBQVVDLFNBQVMsQ0FBQ0MsUUFBUSxDQUFDLFFBQU8sRUFBSTtBQUNwRCx5REFBeUQ7QUFDekQsNkJBQTZCO0FBQ3RCLE1BQU1DLFNBQVMsSUFBTSxPQUFPQyxTQUFTLFlBQVk7QUFDeEQsZ0RBQWdEO0FBQ3pDLE1BQU1DLFNBQVMsSUFBTSxPQUFPQyxZQUFZLGVBQzNDLE9BQU9BLFFBQVFDLFFBQVEsS0FBSyxlQUM1QixPQUFPRCxRQUFRQyxRQUFRLENBQUNDLElBQUksS0FBSyxlQUNqQyxDQUFDTCxTQUFTO0FBQ1AsTUFBTU0sU0FBUztJQUNsQixJQUFJbEIsV0FBVztRQUNYLE9BQU9BO0lBQ1g7SUFDQSxJQUFJQyxhQUFhO1FBQ2JELFlBQVk7SUFDaEIsT0FDSyxJQUFJYyxVQUFVO1FBQ2ZkLFlBQVk7SUFDaEIsT0FDSyxJQUFJSSxlQUFlO1FBQ3BCSixZQUFZO0lBQ2hCLE9BQ0ssSUFBSVEsV0FBVztRQUNoQlIsWUFBWTtJQUNoQixPQUNLLElBQUlZLFVBQVU7UUFDZlosWUFBWTtJQUNoQixPQUNLO1FBQ0RBLFlBQVk7SUFDaEI7SUFDQSxPQUFPQTtBQUNYLEVBQUU7QUFDRixJQUFJbUI7QUFDRyxTQUFTQztJQUNaLElBQUlELHVCQUF1QkUsV0FBVztRQUNs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QUNyQmM7SUFDVixFQUNBLE9BQU8wQixHQUFHO1FBQ04sT0FBTzFCO0lBQ1g7QUFDSjtBQUNPLFNBQVM0QixnQ0FBZ0MxQyxJQUFJO0lBQ2hELE9BQVF5Qyx1QkFBdUIsQ0FBQyxVQUFVLEVBQUV6QyxLQUFLLENBQUMsS0FDOUN5Qyx1QkFBdUIsQ0FBQyxVQUFVLEVBQUV6QyxLQUFLLENBQUM7QUFDbEQ7QUFDTyxTQUFTMkMsdUJBQXVCM0MsSUFBSSxFQUFFMkIsS0FBSztJQUM5QyxJQUFJLE9BQU9uQixZQUFZLGFBQWE7UUFDaEMsMENBQTBDO1FBQzFDQSxRQUFRTyxHQUFHLENBQUNmLEtBQUssR0FBRzJCO0lBQ3hCO0FBQ0o7QUFDQSxJQUFJaUI7QUFDSjs7OztDQUlDLEdBQ00sU0FBUzNCO0lBQ1osSUFBSTJCLHFCQUFxQjlCLFdBQVc7UUFDaEMsT0FBTzhCO0lBQ1g7SUFDQSxNQUFNQyxzQkFBc0I7UUFDeEI7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7S0FDSDtJQUNELE1BQU1DLE9BQU8sQ0FBQztJQUNkLEtBQUssTUFBTS9CLE9BQU84QixvQkFBcUI7UUFDbkMsTUFBTUUsU0FBU04sdUJBQXVCMUI7UUFDdEMsSUFBSWdDLFdBQVdqQyxXQUFXO1lBQ3RCZ0MsSUFBSSxDQUFDL0IsSUFBSSxHQUFHZ0M7UUFDaEI7SUFDSjtJQUNBSCxtQkFBbUJFO0lBQ25CLE9BQU9BO0FBQ1giLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9haS1tYXJrZXQtcmVzZWFyY2gtYWdlbnQvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL2Rpc3QvdXRpbHMvZW52LmpzP2E3NDAiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gSW5saW5lZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9mbGV4ZGluZXNoL2Jyb3dzZXItb3Itbm9kZVxuaW1wb3J0IHsgX192ZXJzaW9uX18gfSBmcm9tIFwiLi4vaW5kZXguanNcIjtcbmxldCBnbG9iYWxFbnY7XG5leHBvcnQgY29uc3QgaXNCcm93c2VyID0gKCkgPT4gdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB0eXBlb2Ygd2luZG93LmRvY3VtZW50ICE9PSBcInVuZGVmaW5lZFwiO1xuZXhwb3J0IGNvbnN0IGlzV2ViV29ya2VyID0gKCkgPT4gdHlwZW9mIGdsb2JhbFRoaXMgPT09IFwib2JqZWN0XCIgJiZcbiAgICBnbG9iYWxUaGlzLmNvbnN0cnVjdG9yICYmXG4gICAgZ2xvYmFsVGhpcy5jb25zdHJ1Y3Rvci5uYW1lID09PSBcIkRlZGljYXRlZFdvcmtlckdsb2JhbFNjb3BlXCI7XG5leHBvcnQgY29uc3QgaXNKc0RvbSA9ICgpID0+ICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHdpbmRvdy5uYW1lID09PSBcIm5vZGVqc1wiKSB8fFxuICAgICh0eXBlb2YgbmF2aWdhdG9yICE9PSBcInVuZGVmaW5lZFwiICYmXG4gICAgICAgIChuYXZpZ2F0b3IudXNlckFnZW50LmluY2x1ZGVzKFwiTm9kZS5qc1wiKSB8fFxuICAgICAgICAgICAgbmF2aWdhdG9yLnVzZXJBZ2VudC5pbmNsdWRlcyhcImpzZG9tXCIpKSk7XG4vLyBTdXBhYmFzZSBFZGdlIEZ1bmN0aW9uIHByb3ZpZGVzIGEgYERlbm9gIGdsb2JhbCBvYmplY3Rcbi8vIHdpdGhvdXQgYHZlcnNpb25gIHByb3BlcnR5XG5leHBvcnQgY29uc3QgaXNEZW5vID0gKCkgPT4gdHlwZW9mIERlbm8gIT09IFwidW5kZWZpbmVkXCI7XG4vLyBNYXJrIG5vdC1hcy1ub2RlIGlmIGluIFN1cGFiYXNlIEVkZ2UgRnVuY3Rpb25cbmV4cG9ydCBjb25zdCBpc05vZGUgPSAoKSA9PiB0eXBlb2YgcHJvY2VzcyAhPT0gXCJ1bmRlZmluZWRcIiAmJlxuICAgIHR5cGVvZiBwcm9jZXNzLnZlcnNpb25zICE9PSBcInVuZGVmaW5lZFwiICYmXG4gICAgdHlwZW9mIHByb2Nlc3MudmVyc2lvbnMubm9kZSAhPT0gXCJ1bmRlZmluZWRcIiAmJlxuICAgICFpc0Rlbm8oKTtcbmV4cG9ydCBjb25zdCBnZXRFbnYgPSAoKSA9PiB7XG4gICAgaWYgKGdsb2JhbEVudikge1xuICAgICAgICByZXR1cm4gZ2xvYmFsRW52O1xuICAgIH1cbiAgICBpZiAoaXNCcm93c2VyKCkpIHtcbiAgICAgICAgZ2xvYmFsRW52ID0gXCJicm93c2VyXCI7XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzTm9kZSgpKSB7XG4gICAgICAgIGdsb2JhbEVudiA9IFwibm9kZVwiO1xuICAgIH1cbiAgICBlbHNlIGlmIChpc1dlYldvcmtlcigpKSB7XG4gICAgICAgIGdsb2JhbEVudiA9IFwid2Vid29ya2VyXCI7XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzSnNEb20oKSkge1xuICAgICAgICBnbG9iYWxFbnYgPSBcImpzZG9tXCI7XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzRGVubygpKSB7XG4gICAgICAgIGdsb2JhbEVudiA9IFwiZGVub1wiO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZ2xvYmFsRW52ID0gXCJvdGhlclwiO1xuICAgIH1cbiAgICByZXR1cm4gZ2xvYmFsRW52O1xufTtcbmxldCBydW50aW1lRW52aXJvbm1lbnQ7XG5leHBvcnQgZnVuY3Rpb24gZ2V0UnVudGltZUVudmlyb25tZW50KCkge1xuICAgIGlmIChydW50aW1lRW52aXJvbm1lbnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb25zdCBlbnYgPSBnZXRFbnYoKTtcbiAgICAgICAgY29uc3QgcmVsZWFzZUVudiA9IGdldFNoYXMoKTtcbiAgICAgICAgcnVudGltZUVudmlyb25tZW50ID0ge1xuICAgICAgICAgICAgbGlicmFyeTogXCJsYW5nc21pdGhcIixcbiAgICAgICAgICAgIHJ1bnRpbWU6IGVudixcbiAgICAgICAgICAgIHNkazogXCJsYW5nc21pdGgtanNcIixcbiAgICAgICAgICAgIHNka192ZXJzaW9uOiBfX3ZlcnNpb25fXyxcbiAgICAgICAgICAgIC4uLnJlbGVhc2VFbnYsXG4gICAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBydW50aW1lRW52aXJvbm1lbnQ7XG59XG4vKipcbiAqIFJldHJpZXZlcyB0aGUgTGFuZ0NoYWluLXNwZWNpZmljIGVudmlyb25tZW50IHZhcmlhYmxlcyBmcm9tIHRoZSBjdXJyZW50IHJ1bnRpbWUgZW52aXJvbm1lbnQuXG4gKiBTZW5zaXRpdmUga2V5cyAoY29udGFpbmluZyB0aGUgd29yZCBcImtleVwiLCBcInRva2VuXCIsIG9yIFwic2VjcmV0XCIpIGhhdmUgdGhlaXIgdmFsdWVzIHJlZGFjdGVkIGZvciBzZWN1cml0eS5cbiAqXG4gKiBAcmV0dXJucyB7UmVjb3JkPHN0cmluZywgc3RyaW5nPn1cbiAqICAtIEEgcmVjb3JkIG9mIExhbmdDaGFpbi1zcGVjaWZpYyBlbnZpcm9ubWVudCB2YXJpYWJsZXMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRMYW5nQ2hhaW5FbnZWYXJzKCkge1xuICAgIGNvbnN0IGFsbEVudlZhcnMgPSBnZXRFbnZpcm9ubWVudFZhcmlhYmxlcygpIHx8IHt9O1xuICAgIGNvbnN0IGVudlZhcnMgPSB7fTtcbiAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhhbGxFbnZWYXJzKSkge1xuICAgICAgICBpZiAoa2V5LnN0YXJ0c1dpdGgoXCJMQU5HQ0hBSU5fXCIpICYmIHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgZW52VmFyc1trZXldID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZm9yIChjb25zdCBrZXkgaW4gZW52VmFycykge1xuICAgICAgICBpZiAoKGtleS50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKFwia2V5XCIpIHx8XG4gICAgICAgICAgICBrZXkudG9Mb3dlckNhc2UoKS5pbmNsdWRlcyhcInNlY3JldFwiKSB8fFxuICAgICAgICAgICAga2V5LnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoXCJ0b2tlblwiKSkgJiZcbiAgICAgICAgICAgIHR5cGVvZiBlbnZWYXJzW2tleV0gPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gZW52VmFyc1trZXldO1xuICAgICAgICAgICAgZW52VmFyc1trZXldID1cbiAgICAgICAgICAgICAgICB2YWx1ZS5zbGljZSgwLCAyKSArIFwiKlwiLnJlcGVhdCh2YWx1ZS5sZW5ndGggLSA0KSArIHZhbHVlLnNsaWNlKC0yKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZW52VmFycztcbn1cbi8qKlxuICogUmV0cmlldmVzIHRoZSBMYW5nQ2hhaW4tc3BlY2lmaWMgbWV0YWRhdGEgZnJvbSB0aGUgY3VycmVudCBydW50aW1lIGVudmlyb25tZW50LlxuICpcbiAqIEByZXR1cm5zIHtSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+fVxuICogIC0gQSByZWNvcmQgb2YgTGFuZ0NoYWluLXNwZWNpZmljIG1ldGFkYXRhIGVudmlyb25tZW50IHZhcmlhYmxlcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldExhbmdDaGFpbkVudlZhcnNNZXRhZGF0YSgpIHtcbiAgICBjb25zdCBhbGxFbnZWYXJzID0gZ2V0RW52aXJvbm1lbnRWYXJpYWJsZXMoKSB8fCB7fTtcbiAgICBjb25zdCBlbnZWYXJzID0ge307XG4gICAgY29uc3QgZXhjbHVkZWQgPSBbXG4gICAgICAgIFwiTEFOR0NIQUlOX0FQSV9LRVlcIixcbiAgICAgICAgXCJMQU5HQ0hBSU5fRU5EUE9JTlRcIixcbiAgICAgICAgXCJMQU5HQ0hBSU5fVFJBQ0lOR19WMlwiLFxuICAgICAgICBcIkxBTkdDSEFJTl9QUk9KRUNUXCIsXG4gICAgICAgIFwiTEFOR0NIQUlOX1NFU1NJT05cIixcbiAgICAgICAgXCJMQU5HU01JVEhfQVBJX0tFWVwiLFxuICAgICAgICBcIkxBTkdTTUlUSF9FTkRQT0lOVFwiLFxuICAgICAgICBcIkxBTkdTTUlUSF9UUkFDSU5HX1YyXCIsXG4gICAgICAgIFwiTEFOR1NNSVRIX1BST0pFQ1RcIixcbiAgICAgICAgXCJMQU5HU01JVEhfU0VTU0lPTlwiLFxuICAgIF07XG4gICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMoYWxsRW52VmFycykpIHtcbiAgICAgICAgaWYgKChrZXkuc3RhcnRzV2l0aChcIkxBTkdDSEFJTl9cIikgfHwga2V5LnN0YXJ0c1dpdGgoXCJMQU5HU01JVEhfXCIpKSAmJlxuICAgICAgICAgICAgdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiICYmXG4gICAgICAgICAgICAhZXhjbHVkZWQuaW5jbHVkZXMoa2V5KSAmJlxuICAgICAgICAgICAgIWtleS50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKFwia2V5XCIpICYmXG4gICAgICAgICAgICAha2V5LnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoXCJzZWNyZXRcIikgJiZcbiAgICAgICAgICAgICFrZXkudG9Mb3dlckNhc2UoKS5pbmNsdWRlcyhcInRva2VuXCIpKSB7XG4gICAgICAgICAgICBpZiAoa2V5ID09PSBcIkxBTkdDSEFJTl9SRVZJU0lPTl9JRFwiKSB7XG4gICAgICAgICAgICAgICAgZW52VmFyc1tcInJldmlzaW9uX2lkXCJdID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBlbnZWYXJzW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZW52VmFycztcbn1cbi8qKlxuICogUmV0cmlldmVzIHRoZSBlbnZpcm9ubWVudCB2YXJpYWJsZXMgZnJvbSB0aGUgY3VycmVudCBydW50aW1lIGVudmlyb25tZW50LlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gaXMgZGVzaWduZWQgdG8gb3BlcmF0ZSBpbiBhIHZhcmlldHkgb2YgSlMgZW52aXJvbm1lbnRzLFxuICogaW5jbHVkaW5nIE5vZGUuanMsIERlbm8sIGJyb3dzZXJzLCBldGMuXG4gKlxuICogQHJldHVybnMge1JlY29yZDxzdHJpbmcsIHN0cmluZz4gfCB1bmRlZmluZWR9XG4gKiAgLSBBIHJlY29yZCBvZiBlbnZpcm9ubWVudCB2YXJpYWJsZXMgaWYgYXZhaWxhYmxlLlxuICogIC0gYHVuZGVmaW5lZGAgaWYgdGhlIGVudmlyb25tZW50IGRvZXMgbm90IHN1cHBvcnQgb3IgYWxsb3dzIGFjY2VzcyB0byBlbnZpcm9ubWVudCB2YXJpYWJsZXMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRFbnZpcm9ubWVudFZhcmlhYmxlcygpIHtcbiAgICB0cnkge1xuICAgICAgICAvLyBDaGVjayBmb3IgTm9kZS5qcyBlbnZpcm9ubWVudFxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcHJvY2Vzcy1lbnZcbiAgICAgICAgaWYgKHR5cGVvZiBwcm9jZXNzICE9PSBcInVuZGVmaW5lZFwiICYmIHByb2Nlc3MuZW52KSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcHJvY2Vzcy1lbnZcbiAgICAgICAgICAgIHJldHVybiBPYmplY3QuZW50cmllcyhwcm9jZXNzLmVudikucmVkdWNlKChhY2MsIFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgICAgICAgICAgIGFjY1trZXldID0gU3RyaW5nKHZhbHVlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICAgICAgfSwge30pO1xuICAgICAgICB9XG4gICAgICAgIC8vIEZvciBicm93c2VycyBhbmQgb3RoZXIgZW52aXJvbm1lbnRzLCB3ZSBtYXkgbm90IGhhdmUgZGlyZWN0IGFjY2VzcyB0byBlbnYgdmFyaWFibGVzXG4gICAgICAgIC8vIFJldHVybiB1bmRlZmluZWQgb3IgYW55IG90aGVyIGZhbGxiYWNrIGFzIHJlcXVpcmVkLlxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICAvLyBDYXRjaCBhbnkgZXJyb3JzIHRoYXQgbWlnaHQgb2NjdXIgd2hpbGUgdHJ5aW5nIHRvIGFjY2VzcyBlbnZpcm9ubWVudCB2YXJpYWJsZXNcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24gZ2V0RW52aXJvbm1lbnRWYXJpYWJsZShuYW1lKSB7XG4gICAgLy8gQ2VydGFpbiBEZW5vIHNldHVwcyB3aWxsIHRocm93IGFuIGVycm9yIGlmIHlvdSB0cnkgdG8gYWNjZXNzIGVudmlyb25tZW50IHZhcmlhYmxlc1xuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9od2NoYXNlMTcvbGFuZ2NoYWluanMvaXNzdWVzLzE0MTJcbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIHByb2Nlc3MgIT09IFwidW5kZWZpbmVkXCJcbiAgICAgICAgICAgID8gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXByb2Nlc3MtZW52XG4gICAgICAgICAgICAgICAgcHJvY2Vzcy5lbnY/LltuYW1lXVxuICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIGdldExhbmdTbWl0aEVudmlyb25tZW50VmFyaWFibGUobmFtZSkge1xuICAgIHJldHVybiAoZ2V0RW52aXJvbm1lbnRWYXJpYWJsZShgTEFOR1NNSVRIXyR7bmFtZX1gKSB8fFxuICAgICAgICBnZXRFbnZpcm9ubWVudFZhcmlhYmxlKGBMQU5HQ0hBSU5fJHtuYW1lfWApKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBzZXRFbnZpcm9ubWVudFZhcmlhYmxlKG5hbWUsIHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiBwcm9jZXNzICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wcm9jZXNzLWVudlxuICAgICAgICBwcm9jZXNzLmVudltuYW1lXSA9IHZhbHVlO1xuICAgIH1cbn1cbmxldCBjYWNoZWRDb21taXRTSEFzO1xuLyoqXG4gKiBHZXQgdGhlIEdpdCBjb21taXQgU0hBIGZyb20gY29tbW9uIGVudmlyb25tZW50IHZhcmlhYmxlc1xuICogdXNlZCBieSBkaWZmZXJlbnQgQ0kvQ0QgcGxhdGZvcm1zLlxuICogQHJldHVybnMge3N0cmluZyB8IHVuZGVmaW5lZH0gVGhlIEdpdCBjb21taXQgU0hBIG9yIHVuZGVmaW5lZCBpZiBub3QgZm91bmQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRTaGFzKCkge1xuICAgIGlmIChjYWNoZWRDb21taXRTSEFzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIGNhY2hlZENvbW1pdFNIQXM7XG4gICAgfVxuICAgIGNvbnN0IGNvbW1vbl9yZWxlYXNlX2VudnMgPSBbXG4gICAgICAgIFwiVkVSQ0VMX0dJVF9DT01NSVRfU0hBXCIsXG4gICAgICAgIFwiTkVYVF9QVUJMSUNfVkVSQ0VMX0dJVF9DT01NSVRfU0hBXCIsXG4gICAgICAgIFwiQ09NTUlUX1JFRlwiLFxuICAgICAgICBcIlJFTkRFUl9HSVRfQ09NTUlUXCIsXG4gICAgICAgIFwiQ0lfQ09NTUlUX1NIQVwiLFxuICAgICAgICBcIkNJUkNMRV9TSEExXCIsXG4gICAgICAgIFwiQ0ZfUEFHRVNfQ09NTUlUX1NIQVwiLFxuICAgICAgICBcIlJFQUNUX0FQUF9HSVRfU0hBXCIsXG4gICAgICAgIFwiU09VUkNFX1ZFUlNJT05cIixcbiAgICAgICAgXCJHSVRIVUJfU0hBXCIsXG4gICAgICAgIFwiVFJBVklTX0NPTU1JVFwiLFxuICAgICAgICBcIkdJVF9DT01NSVRcIixcbiAgICAgICAgXCJCVUlMRF9WQ1NfTlVNQkVSXCIsXG4gICAgICAgIFwiYmFtYm9vX3BsYW5SZXBvc2l0b3J5X3JldmlzaW9uXCIsXG4gICAgICAgIFwiQnVpbGQuU291cmNlVmVyc2lvblwiLFxuICAgICAgICBcIkJJVEJVQ0tFVF9DT01NSVRcIixcbiAgICAgICAgXCJEUk9ORV9DT01NSVRfU0hBXCIsXG4gICAgICAgIFwiU0VNQVBIT1JFX0dJVF9TSEFcIixcbiAgICAgICAgXCJCVUlMREtJVEVfQ09NTUlUXCIsXG4gICAgXTtcbiAgICBjb25zdCBzaGFzID0ge307XG4gICAgZm9yIChjb25zdCBlbnYgb2YgY29tbW9uX3JlbGVhc2VfZW52cykge1xuICAgICAgICBjb25zdCBlbnZWYXIgPSBnZXRFbnZpcm9ubWVudFZhcmlhYmxlKGVudik7XG4gICAgICAgIGlmIChlbnZWYXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgc2hhc1tlbnZdID0gZW52VmFyO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNhY2hlZENvbW1pdFNIQXMgPSBzaGFzO1xuICAgIHJldHVybiBzaGFzO1xufVxuIl0sIm5hbWVzIjpbIl9fdmVyc2lvbl9fIiwiZ2xvYmFsRW52IiwiaXNCcm93c2VyIiwid2luZG93IiwiZG9jdW1lbnQiLCJpc1dlYldvcmtlciIsImdsb2JhbFRoaXMiLCJjb25zdHJ1Y3RvciIsIm5hbWUiLCJpc0pzRG9tIiwibmF2aWdhdG9yIiwidXNlckFnZW50IiwiaW5jbHVkZXMiLCJpc0Rlbm8iLCJEZW5vIiwiaXNOb2RlIiwicHJvY2VzcyIsInZlcnNpb25zIiwibm9kZSIsImdldEVudiIsInJ1bnRpbWVFbnZpcm9ubWVudCIsImdldFJ1bnRpbWVFbnZpcm9ubWVudCIsInVuZGVmaW5lZCIsImVudiIsInJlbGVhc2VFbnYiLCJnZXRTaGFzIiwibGlicmFyeSIsInJ1bnRpbWUiLCJzZGsiLCJzZGtfdmVyc2lvbiIsImdldExhbmdDaGFpbkVudlZhcnMiLCJhbGxFbnZWYXJzIiwiZ2V0RW52aXJvbm1lbnRWYXJpYWJsZXMiLCJlbnZWYXJzIiwia2V5IiwidmFsdWUiLCJPYmplY3QiLCJlbnRyaWVzIiwic3RhcnRzV2l0aCIsInRvTG93ZXJDYXNlIiwic2xpY2UiLCJyZXBlYXQiLCJsZW5ndGgiLCJnZXRMYW5nQ2hhaW5FbnZWYXJzTWV0YWRhdGEiLCJleGNsdWRlZCIsInJlZHVjZSIsImFjYyIsIlN0cmluZyIsImUiLCJnZXRFbnZpcm9ubWVudFZhcmlhYmxlIiwiZ2V0TGFuZ1NtaXRoRW52aXJvbm1lbnRWYXJpYWJsZSIsInNldEVudmlyb25tZW50VmFyaWFibGUiLCJjYWNoZWRDb21taXRTSEFzIiwiY29tbW9uX3JlbGVhc2VfZW52cyIsInNoYXMiLCJlbnZWYXIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/langsmith/dist/utils/env.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/langsmith/dist/utils/error.js":
/*!****************************************************!*\
  !*** ./node_modules/langsmith/dist/utils/error.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   LangSmithConflictError: () => (/* binding */ LangSmithConflictError),\n/* harmony export */   printErrorStackTrace: () => (/* binding */ printErrorStackTrace),\n/* harmony export */   raiseForStatus: () => (/* binding */ raiseForStatus)\n/* harmony export */ });\nfunction getErrorStackTrace(e) {\n    if (typeof e !== \"object\" || e == null) return undefined;\n    if (!(\"stack\" in e) || typeof e.stack !== \"string\") return undefined;\n    let stack = e.stack;\n    const prevLine = `${e}`;\n    if (stack.startsWith(prevLine)) {\n        stack = stack.slice(prevLine.length);\n    }\n    if (stack.startsWith(\"\\n\")) {\n        stack = stack.slice(1);\n    }\n    return stack;\n}\nfunction printErrorStackTrace(e) {\n    const stack = getErrorStackTrace(e);\n    if (stack == null) return;\n    console.error(stack);\n}\n/**\n * LangSmithConflictError\n *\n * Represents an error that occurs when there's a conflict during an operation,\n * typically corresponding to HTTP 409 status code responses.\n *\n * This error is thrown when an attempt to create or modify a resource conflicts\n * with the current state of the resource on the server. Common scenarios include:\n * - Attempting to create a resource that already exists\n * - Trying to update a resource that has been modified by another process\n * - Violating a uniqueness constraint in the data\n *\n * @extends Error\n *\n * @example\n * try {\n *   await createProject(\"existingProject\");\n * } catch (error) {\n *   if (error instanceof ConflictError) {\n *     console.log(\"A conflict occurred:\", error.message);\n *     // Handle the conflict, e.g., by suggesting a different project name\n *   } else {\n *     // Handle other types of errors\n *   }\n * }\n *\n * @property {string} name - Always set to 'ConflictError' for easy identification\n * @property {string} message - Detailed error message including server response\n *\n * @see https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/409\n */ class LangSmithConflictError extends Error {\n    constructor(message){\n        super(message);\n        this.name = \"LangSmithConflictError\";\n    }\n}\n/**\n * Throws an appropriate error based on the response status and body.\n *\n * @param response - The fetch Response object\n * @param context - Additional context to include in the error message (e.g., operation being performed)\n * @throws {LangSmithConflictError} When the response status is 409\n * @throws {Error} For all other non-ok responses\n */ async function raiseForStatus(response, context, consume) {\n    // consume the response body to release the connection\n    // https://undici.nodejs.org/#/?id=garbage-collection\n    let errorBody;\n    if (response.ok) {\n        if (consume) {\n            errorBody = await response.text();\n        }\n        return;\n    }\n    errorBody = await response.text();\n    const fullMessage = `Failed to ${context}. Received status [${response.status}]: ${response.statusText}. Server response: ${errorBody}`;\n    if (response.status === 409) {\n        throw new LangSmithConflictError(fullMessage);\n    }\n    throw new Error(fullMessage);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL2Rpc3QvdXRpbHMvZXJyb3IuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUEsU0FBU0EsbUJBQW1CQyxDQUFDO0lBQ3pCLElBQUksT0FBT0EsTUFBTSxZQUFZQSxLQUFLLE1BQzlCLE9BQU9DO0lBQ1gsSUFBSSxDQUFFLFlBQVdELENBQUFBLEtBQU0sT0FBT0EsRUFBRUUsS0FBSyxLQUFLLFVBQ3RDLE9BQU9EO0lBQ1gsSUFBSUMsUUFBUUYsRUFBRUUsS0FBSztJQUNuQixNQUFNQyxXQUFXLENBQUMsRUFBRUgsRUFBRSxDQUFDO0lBQ3ZCLElBQUlFLE1BQU1FLFVBQVUsQ0FBQ0QsV0FBVztRQUM1QkQsUUFBUUEsTUFBTUcsS0FBSyxDQUFDRixTQUFTRyxNQUFNO0lBQ3ZDO0lBQ0EsSUFBSUosTUFBTUUsVUFBVSxDQUFDLE9BQU87UUFDeEJGLFFBQVFBLE1BQU1HLEtBQUssQ0FBQztJQUN4QjtJQUNBLE9BQU9IO0FBQ1g7QUFDTyxTQUFTSyxxQkFBcUJQLENBQUM7SUFDbEMsTUFBTUUsUUFBUUgsbUJBQW1CQztJQUNqQyxJQUFJRSxTQUFTLE1BQ1Q7SUFDSk0sUUFBUUMsS0FBSyxDQUFDUDtBQUNsQjtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0E4QkMsR0FDTSxNQUFNUSwrQkFBK0JDO0lBQ3hDQyxZQUFZQyxPQUFPLENBQUU7UUFDakIsS0FBSyxDQUFDQTtRQUNOLElBQUksQ0FBQ0MsSUFBSSxHQUFHO0lBQ2hCO0FBQ0o7QUFDQTs7Ozs7OztDQU9DLEdBQ00sZUFBZUMsZUFBZUMsUUFBUSxFQUFFQyxPQUFPLEVBQUVDLE9BQU87SUFDM0Qsc0RBQXNEO0lBQ3RELHFEQUFxRDtJQUNyRCxJQUFJQztJQUNKLElBQUlILFNBQVNJLEVBQUUsRUFBRTtRQUNiLElBQUlGLFNBQVM7WUFDVEMsWUFBWSxNQUFNSCxTQUFTSyxJQUFJO1FBQ25DO1FBQ0E7SUFDSjtJQUNBRixZQUFZLE1BQU1ILFNBQVNLLElBQUk7SUFDL0IsTUFBTUMsY0FBYyxDQUFDLFVBQVUsRUFBRUwsUUFBUSxtQkFBbUIsRUFBRUQsU0FBU08sTUFBTSxDQUFDLEdBQUcsRUFBRVAsU0FBU1EsVUFBVSxDQUFDLG1CQUFtQixFQUFFTCxVQUFVLENBQUM7SUFDdkksSUFBSUgsU0FBU08sTUFBTSxLQUFLLEtBQUs7UUFDekIsTUFBTSxJQUFJYix1QkFBdUJZO0lBQ3JDO0lBQ0EsTUFBTSxJQUFJWCxNQUFNVztBQUNwQiIsInNvdXJjZXMiOlsid2VicGFjazovL2FpLW1hcmtldC1yZXNlYXJjaC1hZ2VudC8uL25vZGVfbW9kdWxlcy9sYW5nc21pdGgvZGlzdC91dGlscy9lcnJvci5qcz82Nzg2Il0sInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIGdldEVycm9yU3RhY2tUcmFjZShlKSB7XG4gICAgaWYgKHR5cGVvZiBlICE9PSBcIm9iamVjdFwiIHx8IGUgPT0gbnVsbClcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICBpZiAoIShcInN0YWNrXCIgaW4gZSkgfHwgdHlwZW9mIGUuc3RhY2sgIT09IFwic3RyaW5nXCIpXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgbGV0IHN0YWNrID0gZS5zdGFjaztcbiAgICBjb25zdCBwcmV2TGluZSA9IGAke2V9YDtcbiAgICBpZiAoc3RhY2suc3RhcnRzV2l0aChwcmV2TGluZSkpIHtcbiAgICAgICAgc3RhY2sgPSBzdGFjay5zbGljZShwcmV2TGluZS5sZW5ndGgpO1xuICAgIH1cbiAgICBpZiAoc3RhY2suc3RhcnRzV2l0aChcIlxcblwiKSkge1xuICAgICAgICBzdGFjayA9IHN0YWNrLnNsaWNlKDEpO1xuICAgIH1cbiAgICByZXR1cm4gc3RhY2s7XG59XG5leHBvcnQgZnVuY3Rpb24gcHJpbnRFcnJvclN0YWNrVHJhY2UoZSkge1xuICAgIGNvbnN0IHN0YWNrID0gZ2V0RXJyb3JTdGFja1RyYWNlKGUpO1xuICAgIGlmIChzdGFjayA9PSBudWxsKVxuICAgICAgICByZXR1cm47XG4gICAgY29uc29sZS5lcnJvcihzdGFjayk7XG59XG4vKipcbiAqIExhbmdTbWl0aENvbmZsaWN0RXJyb3JcbiAqXG4gKiBSZXByZXNlbnRzIGFuIGVycm9yIHRoYXQgb2NjdXJzIHdoZW4gdGhlcmUncyBhIGNvbmZsaWN0IGR1cmluZyBhbiBvcGVyYXRpb24sXG4gKiB0eXBpY2FsbHkgY29ycmVzcG9uZGluZyB0byBIVFRQIDQwOSBzdGF0dXMgY29kZSByZXNwb25zZXMuXG4gKlxuICogVGhpcyBlcnJvciBpcyB0aHJvd24gd2hlbiBhbiBhdHRlbXB0IHRvIGNyZWF0ZSBvciBtb2RpZnkgYSByZXNvdXJjZSBjb25mbGljdHNcbiAqIHdpdGggdGhlIGN1cnJlbnQgc3RhdGUgb2YgdGhlIHJlc291cmNlIG9uIHRoZSBzZXJ2ZXIuIENvbW1vbiBzY2VuYXJpb3MgaW5jbHVkZTpcbiAqIC0gQXR0ZW1wdGluZyB0byBjcmVhdGUgYSByZXNvdXJjZSB0aGF0IGFscmVhZHkgZXhpc3RzXG4gKiAtIFRyeWluZyB0byB1cGRhdGUgYSByZXNvdXJjZSB0aGF0IGhhcyBiZWVuIG1vZGlmaWVkIGJ5IGFub3RoZXIgcHJvY2Vzc1xuICogLSBWaW9sYXRpbmcgYSB1bmlxdWVuZXNzIGNvbnN0cmFpbnQgaW4gdGhlIGRhdGFcbiAqXG4gKiBAZXh0ZW5kcyBFcnJvclxuICpcbiAqIEBleGFtcGxlXG4gKiB0cnkge1xuICogICBhd2FpdCBjcmVhdGVQcm9qZWN0KFwiZXhpc3RpbmdQcm9qZWN0XCIpO1xuICogfSBjYXRjaCAoZXJyb3IpIHtcbiAqICAgaWYgKGVycm9yIGluc3RhbmNlb2YgQ29uZmxpY3RFcnJvcikge1xuICogICAgIGNvbnNvbGUubG9nKFwiQSBjb25mbGljdCBvY2N1cnJlZDpcIiwgZXJyb3IubWVzc2FnZSk7XG4gKiAgICAgLy8gSGFuZGxlIHRoZSBjb25mbGljdCwgZS5nLiwgYnkgc3VnZ2VzdGluZyBhIGRpZmZlcmVudCBwcm9qZWN0IG5hbWVcbiAqICAgfSBlbHNlIHtcbiAqICAgICAvLyBIYW5kbGUgb3RoZXIgdHlwZXMgb2YgZXJyb3JzXG4gKiAgIH1cbiAqIH1cbiAqXG4gKiBAcHJvcGVydHkge3N0cmluZ30gbmFtZSAtIEFsd2F5cyBzZXQgdG8gJ0NvbmZsaWN0RXJyb3InIGZvciBlYXN5IGlkZW50aWZpY2F0aW9uXG4gKiBAcHJvcGVydHkge3N0cmluZ30gbWVzc2FnZSAtIERldGFpbGVkIGVycm9yIG1lc3NhZ2UgaW5jbHVkaW5nIHNlcnZlciByZXNwb25zZVxuICpcbiAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSFRUUC9TdGF0dXMvNDA5XG4gKi9cbmV4cG9ydCBjbGFzcyBMYW5nU21pdGhDb25mbGljdEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2UpIHtcbiAgICAgICAgc3VwZXIobWVzc2FnZSk7XG4gICAgICAgIHRoaXMubmFtZSA9IFwiTGFuZ1NtaXRoQ29uZmxpY3RFcnJvclwiO1xuICAgIH1cbn1cbi8qKlxuICogVGhyb3dzIGFuIGFwcHJvcHJpYXRlIGVycm9yIGJhc2VkIG9uIHRoZSByZXNwb25zZSBzdGF0dXMgYW5kIGJvZHkuXG4gKlxuICogQHBhcmFtIHJlc3BvbnNlIC0gVGhlIGZldGNoIFJlc3BvbnNlIG9iamVjdFxuICogQHBhcmFtIGNvbnRleHQgLSBBZGRpdGlvbmFsIGNvbnRleHQgdG8gaW5jbHVkZSBpbiB0aGUgZXJyb3IgbWVzc2FnZSAoZS5nLiwgb3BlcmF0aW9uIGJlaW5nIHBlcmZvcm1lZClcbiAqIEB0aHJvd3Mge0xhbmdTbWl0aENvbmZsaWN0RXJyb3J9IFdoZW4gdGhlIHJlc3BvbnNlIHN0YXR1cyBpcyA0MDlcbiAqIEB0aHJvd3Mge0Vycm9yfSBGb3IgYWxsIG90aGVyIG5vbi1vayByZXNwb25zZXNcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHJhaXNlRm9yU3RhdHVzKHJlc3BvbnNlLCBjb250ZXh0LCBjb25zdW1lKSB7XG4gICAgLy8gY29uc3VtZSB0aGUgcmVzcG9uc2UgYm9keSB0byByZWxlYXNlIHRoZSBjb25uZWN0aW9uXG4gICAgLy8gaHR0cHM6Ly91bmRpY2kubm9kZWpzLm9yZy8jLz9pZD1nYXJiYWdlLWNvbGxlY3Rpb25cbiAgICBsZXQgZXJyb3JCb2R5O1xuICAgIGlmIChyZXNwb25zZS5vaykge1xuICAgICAgICBpZiAoY29uc3VtZSkge1xuICAgICAgICAgICAgZXJyb3JCb2R5ID0gYXdhaXQgcmVzcG9uc2UudGV4dCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZXJyb3JCb2R5ID0gYXdhaXQgcmVzcG9uc2UudGV4dCgpO1xuICAgIGNvbnN0IGZ1bGxNZXNzYWdlID0gYEZhaWxlZCB0byAke2NvbnRleHR9LiBSZWNlaXZlZCBzdGF0dXMgWyR7cmVzcG9uc2Uuc3RhdHVzfV06ICR7cmVzcG9uc2Uuc3RhdHVzVGV4dH0uIFNlcnZlciByZXNwb25zZTogJHtlcnJvckJvZHl9YDtcbiAgICBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSA0MDkpIHtcbiAgICAgICAgdGhyb3cgbmV3IExhbmdTbWl0aENvbmZsaWN0RXJyb3IoZnVsbE1lc3NhZ2UpO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoZnVsbE1lc3NhZ2UpO1xufVxuIl0sIm5hbWVzIjpbImdldEVycm9yU3RhY2tUcmFjZSIsImUiLCJ1bmRlZmluZWQiLCJzdGFjayIsInByZXZMaW5lIiwic3RhcnRzV2l0aCIsInNsaWNlIiwibGVuZ3RoIiwicHJpbnRFcnJvclN0YWNrVHJhY2UiLCJjb25zb2xlIiwiZXJyb3IiLCJMYW5nU21pdGhDb25mbGljdEVycm9yIiwiRXJyb3IiLCJjb25zdHJ1Y3RvciIsIm1lc3NhZ2UiLCJuYW1lIiwicmFpc2VGb3JTdGF0dXMiLCJyZXNwb25zZSIsImNvbnRleHQiLCJjb25zdW1lIiwiZXJyb3JCb2R5Iiwib2siLCJ0ZXh0IiwiZnVsbE1lc3NhZ2UiLCJzdGF0dXMiLCJzdGF0dXNUZXh0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/langsmith/dist/utils/error.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/langsmith/dist/utils/fast-safe-stringify/index.js":
/*!************************************************************************!*\
  !*** ./node_modules/langsmith/dist/utils/fast-safe-stringify/index.js ***!
  \************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   serialize: () => (/* binding */ serialize)\n/* harmony export */ });\n/* eslint-disable */ // @ts-nocheck\nvar LIMIT_REPLACE_NODE = \"[...]\";\nvar CIRCULAR_REPLACE_NODE = {\n    result: \"[Circular]\"\n};\nvar arr = [];\nvar replacerStack = [];\nconst encoder = new TextEncoder();\nfunction defaultOptions() {\n    return {\n        depthLimit: Number.MAX_SAFE_INTEGER,\n        edgesLimit: Number.MAX_SAFE_INTEGER\n    };\n}\nfunction encodeString(str) {\n    return encoder.encode(str);\n}\n// Regular stringify\nfunction serialize(obj, replacer, spacer, options) {\n    try {\n        const str = JSON.stringify(obj, replacer, spacer);\n        return encodeString(str);\n    } catch (e) {\n        // Fall back to more complex stringify if circular reference\n        if (!e.message?.includes(\"Converting circular structure to JSON\")) {\n            console.warn(\"[WARNING]: LangSmith received unserializable value.\");\n            return encodeString(\"[Unserializable]\");\n        }\n        console.warn(\"[WARNING]: LangSmith received circular JSON. This will decrease tracer performance.\");\n        if (typeof options === \"undefined\") {\n            options = defaultOptions();\n        }\n        decirc(obj, \"\", 0, [], undefined, 0, options);\n        let res;\n        try {\n            if (replacerStack.length === 0) {\n                res = JSON.stringify(obj, replacer, spacer);\n            } else {\n                res = JSON.stringify(obj, replaceGetterValues(replacer), spacer);\n            }\n        } catch (_) {\n            return encodeString(\"[unable to serialize, circular reference is too complex to analyze]\");\n        } finally{\n            while(arr.length !== 0){\n                const part = arr.pop();\n                if (part.length === 4) {\n                    Object.defineProperty(part[0], part[1], part[3]);\n                } else {\n                    part[0][part[1]] = part[2];\n                }\n            }\n        }\n        return encodeString(res);\n    }\n}\nfunction setReplace(replace, val, k, parent) {\n    var propertyDescriptor = Object.getOwnPropertyDescriptor(parent, k);\n    if (propertyDescriptor.get !== undefined) {\n        if (propertyDescriptor.configurable) {\n            Object.defineProperty(parent, k, {\n                value: replace\n            });\n            arr.push([\n                parent,\n                k,\n                val,\n                propertyDescriptor\n            ]);\n        } else {\n            replacerStack.push([\n                val,\n                k,\n                replace\n            ]);\n        }\n    } else {\n        parent[k] = replace;\n        arr.push([\n            parent,\n            k,\n            val\n        ]);\n    }\n}\nfunction decirc(val, k, edgeIndex, stack, parent, depth, options) {\n    depth += 1;\n    var i;\n    if (typeof val === \"object\" && val !== null) {\n        for(i = 0; i < stack.length; i++){\n            if (stack[i] === val) {\n                setReplace(CIRCULAR_REPLACE_NODE, val, k, parent);\n                return;\n            }\n        }\n        if (typeof options.depthLimit !== \"undefined\" && depth > options.depthLimit) {\n            setReplace(LIMIT_REPLACE_NODE, val, k, parent);\n            return;\n        }\n        if (typeof options.edgesLimit !== \"undefined\" && edgeIndex + 1 > options.edgesLimit) {\n            setReplace(LIMIT_REPLACE_NODE, val, k, parent);\n            return;\n        }\n        stack.push(val);\n        // Optimize for Arrays. Big arrays could kill the performance otherwise!\n        if (Array.isArray(val)) {\n            for(i = 0; i < val.length; i++){\n                decirc(val[i], i, i, stack, val, depth, options);\n            }\n        } else {\n            var keys = Object.keys(val);\n            for(i = 0; i < keys.length; i++){\n                var key = keys[i];\n                decirc(val[key], key, i, stack, val, depth, options);\n            }\n        }\n        stack.pop();\n    }\n}\n// Stable-stringify\nfunction compareFunction(a, b) {\n    if (a < b) {\n        return -1;\n    }\n    if (a > b) {\n        return 1;\n    }\n    return 0;\n}\nfunction deterministicStringify(obj, replacer, spacer, options) {\n    if (typeof options === \"undefined\") {\n        options = defaultOptions();\n    }\n    var tmp = deterministicDecirc(obj, \"\", 0, [], undefined, 0, options) || obj;\n    var res;\n    try {\n        if (replacerStack.length === 0) {\n            res = JSON.stringify(tmp, replacer, spacer);\n        } else {\n            res = JSON.stringify(tmp, replaceGetterValues(replacer), spacer);\n        }\n    } catch (_) {\n        return JSON.stringify(\"[unable to serialize, circular reference is too complex to analyze]\");\n    } finally{\n        // Ensure that we restore the object as it was.\n        while(arr.length !== 0){\n            var part = arr.pop();\n            if (part.length === 4) {\n                Object.defineProperty(part[0], part[1], part[3]);\n            } else {\n                part[0][part[1]] = part[2];\n            }\n        }\n    }\n    return res;\n}\nfunction deterministicDecirc(val, k, edgeIndex, stack, parent, depth, options) {\n    depth += 1;\n    var i;\n    if (typeof val === \"object\" && val !== null) {\n        for(i = 0; i < stack.length; i++){\n            if (stack[i] === val) {\n                setReplace(CIRCULAR_REPLACE_NODE, val, k, parent);\n                return;\n            }\n        }\n        try {\n            if (typeof val.toJSON === \"function\") {\n                return;\n            }\n        } catch (_) {\n            return;\n        }\n        if (typeof options.depthLimit !== \"undefined\" && depth > options.depthLimit) {\n            setReplace(LIMIT_REPLACE_NODE, val, k, parent);\n            return;\n        }\n        if (typeof options.edgesLimit !== \"undefined\" && edgeIndex + 1 > options.edgesLimit) {\n            setReplace(LIMIT_REPLACE_NODE, val, k, parent);\n            return;\n        }\n        stack.push(val);\n        // Optimize for Arrays. Big arrays could kill the performance otherwise!\n        if (Array.isArray(val)) {\n            for(i = 0; i < val.length; i++){\n                deterministicDecirc(val[i], i, i, stack, val, depth, options);\n            }\n        } else {\n            // Create a temporary object in the required way\n            var tmp = {};\n            var keys = Object.keys(val).sort(compareFunction);\n            for(i = 0; i < keys.length; i++){\n                var key = keys[i];\n                deterministicDecirc(val[key], key, i, stack, val, depth, options);\n                tmp[key] = val[key];\n            }\n            if (typeof parent !== \"undefined\") {\n                arr.push([\n                    parent,\n                    k,\n                    val\n                ]);\n                parent[k] = tmp;\n            } else {\n                return tmp;\n            }\n        }\n        stack.pop();\n    }\n}\n// wraps replacer function to handle values we couldn't replace\n// and mark them as replaced value\nfunction replaceGetterValues(replacer) {\n    replacer = typeof replacer !== \"undefined\" ? replacer : function(k, v) {\n        return v;\n    };\n    return function(key, val) {\n        if (replacerStack.length > 0) {\n            for(var i = 0; i < replacerStack.length; i++){\n                var part = replacerStack[i];\n                if (part[1] === key && part[0] === val) {\n                    val = part[2];\n                    replacerStack.splice(i, 1);\n                    break;\n                }\n            }\n        }\n        return replacer.call(this, key, val);\n    };\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL2Rpc3QvdXRpbHMvZmFzdC1zYWZlLXN0cmluZ2lmeS9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUEsa0JBQWtCLEdBQ2xCLGNBQWM7QUFDZCxJQUFJQSxxQkFBcUI7QUFDekIsSUFBSUMsd0JBQXdCO0lBQUVDLFFBQVE7QUFBYTtBQUNuRCxJQUFJQyxNQUFNLEVBQUU7QUFDWixJQUFJQyxnQkFBZ0IsRUFBRTtBQUN0QixNQUFNQyxVQUFVLElBQUlDO0FBQ3BCLFNBQVNDO0lBQ0wsT0FBTztRQUNIQyxZQUFZQyxPQUFPQyxnQkFBZ0I7UUFDbkNDLFlBQVlGLE9BQU9DLGdCQUFnQjtJQUN2QztBQUNKO0FBQ0EsU0FBU0UsYUFBYUMsR0FBRztJQUNyQixPQUFPUixRQUFRUyxNQUFNLENBQUNEO0FBQzFCO0FBQ0Esb0JBQW9CO0FBQ2IsU0FBU0UsVUFBVUMsR0FBRyxFQUFFQyxRQUFRLEVBQUVDLE1BQU0sRUFBRUMsT0FBTztJQUNwRCxJQUFJO1FBQ0EsTUFBTU4sTUFBTU8sS0FBS0MsU0FBUyxDQUFDTCxLQUFLQyxVQUFVQztRQUMxQyxPQUFPTixhQUFhQztJQUN4QixFQUNBLE9BQU9TLEdBQUc7UUFDTiw0REFBNEQ7UUFDNUQsSUFBSSxDQUFDQSxFQUFFQyxPQUFPLEVBQUVDLFNBQVMsMENBQTBDO1lBQy9EQyxRQUFRQyxJQUFJLENBQUM7WUFDYixPQUFPZCxhQUFhO1FBQ3hCO1FBQ0FhLFFBQVFDLElBQUksQ0FBQztRQUNiLElBQUksT0FBT1AsWUFBWSxhQUFhO1lBQ2hDQSxVQUFVWjtRQUNkO1FBQ0FvQixPQUFPWCxLQUFLLElBQUksR0FBRyxFQUFFLEVBQUVZLFdBQVcsR0FBR1Q7UUFDckMsSUFBSVU7UUFDSixJQUFJO1lBQ0EsSUFBSXpCLGNBQWMwQixNQUFNLEtBQUssR0FBRztnQkFDNUJELE1BQU1ULEtBQUtDLFNBQVMsQ0FBQ0wsS0FBS0MsVUFBVUM7WUFDeEMsT0FDSztnQkFDRFcsTUFBTVQs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b2RlX21vZHVsZXMvbGFuZ3NtaXRoL2Rpc3QvdXRpbHMvZmFzdC1zYWZlLXN0cmluZ2lmeS9pbmRleC5qcz84MWUyIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIGVzbGludC1kaXNhYmxlICovXG4vLyBAdHMtbm9jaGVja1xudmFyIExJTUlUX1JFUExBQ0VfTk9ERSA9IFwiWy4uLl1cIjtcbnZhciBDSVJDVUxBUl9SRVBMQUNFX05PREUgPSB7IHJlc3VsdDogXCJbQ2lyY3VsYXJdXCIgfTtcbnZhciBhcnIgPSBbXTtcbnZhciByZXBsYWNlclN0YWNrID0gW107XG5jb25zdCBlbmNvZGVyID0gbmV3IFRleHRFbmNvZGVyKCk7XG5mdW5jdGlvbiBkZWZhdWx0T3B0aW9ucygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBkZXB0aExpbWl0OiBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUixcbiAgICAgICAgZWRnZXNMaW1pdDogTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIsXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGVuY29kZVN0cmluZyhzdHIpIHtcbiAgICByZXR1cm4gZW5jb2Rlci5lbmNvZGUoc3RyKTtcbn1cbi8vIFJlZ3VsYXIgc3RyaW5naWZ5XG5leHBvcnQgZnVuY3Rpb24gc2VyaWFsaXplKG9iaiwgcmVwbGFjZXIsIHNwYWNlciwgb3B0aW9ucykge1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHN0ciA9IEpTT04uc3RyaW5naWZ5KG9iaiwgcmVwbGFjZXIsIHNwYWNlcik7XG4gICAgICAgIHJldHVybiBlbmNvZGVTdHJpbmcoc3RyKTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgLy8gRmFsbCBiYWNrIHRvIG1vcmUgY29tcGxleCBzdHJpbmdpZnkgaWYgY2lyY3VsYXIgcmVmZXJlbmNlXG4gICAgICAgIGlmICghZS5tZXNzYWdlPy5pbmNsdWRlcyhcIkNvbnZlcnRpbmcgY2lyY3VsYXIgc3RydWN0dXJlIHRvIEpTT05cIikpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcIltXQVJOSU5HXTogTGFuZ1NtaXRoIHJlY2VpdmVkIHVuc2VyaWFsaXphYmxlIHZhbHVlLlwiKTtcbiAgICAgICAgICAgIHJldHVybiBlbmNvZGVTdHJpbmcoXCJbVW5zZXJpYWxpemFibGVdXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnNvbGUud2FybihcIltXQVJOSU5HXTogTGFuZ1NtaXRoIHJlY2VpdmVkIGNpcmN1bGFyIEpTT04uIFRoaXMgd2lsbCBkZWNyZWFzZSB0cmFjZXIgcGVyZm9ybWFuY2UuXCIpO1xuICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSBkZWZhdWx0T3B0aW9ucygpO1xuICAgICAgICB9XG4gICAgICAgIGRlY2lyYyhvYmosIFwiXCIsIDAsIFtdLCB1bmRlZmluZWQsIDAsIG9wdGlvbnMpO1xuICAgICAgICBsZXQgcmVzO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKHJlcGxhY2VyU3RhY2subGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmVzID0gSlNPTi5zdHJpbmdpZnkob2JqLCByZXBsYWNlciwgc3BhY2VyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlcyA9IEpTT04uc3RyaW5naWZ5KG9iaiwgcmVwbGFjZUdldHRlclZhbHVlcyhyZXBsYWNlciksIHNwYWNlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKF8pIHtcbiAgICAgICAgICAgIHJldHVybiBlbmNvZGVTdHJpbmcoXCJbdW5hYmxlIHRvIHNlcmlhbGl6ZSwgY2lyY3VsYXIgcmVmZXJlbmNlIGlzIHRvbyBjb21wbGV4IHRvIGFuYWx5emVdXCIpO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgd2hpbGUgKGFyci5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJ0ID0gYXJyLnBvcCgpO1xuICAgICAgICAgICAgICAgIGlmIChwYXJ0Lmxlbmd0aCA9PT0gNCkge1xuICAgICAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocGFydFswXSwgcGFydFsxXSwgcGFydFszXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBwYXJ0WzBdW3BhcnRbMV1dID0gcGFydFsyXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVuY29kZVN0cmluZyhyZXMpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHNldFJlcGxhY2UocmVwbGFjZSwgdmFsLCBrLCBwYXJlbnQpIHtcbiAgICB2YXIgcHJvcGVydHlEZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihwYXJlbnQsIGspO1xuICAgIGlmIChwcm9wZXJ0eURlc2NyaXB0b3IuZ2V0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKHByb3BlcnR5RGVzY3JpcHRvci5jb25maWd1cmFibGUpIHtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwYXJlbnQsIGssIHsgdmFsdWU6IHJlcGxhY2UgfSk7XG4gICAgICAgICAgICBhcnIucHVzaChbcGFyZW50LCBrLCB2YWwsIHByb3BlcnR5RGVzY3JpcHRvcl0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmVwbGFjZXJTdGFjay5wdXNoKFt2YWwsIGssIHJlcGxhY2VdKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcGFyZW50W2tdID0gcmVwbGFjZTtcbiAgICAgICAgYXJyLnB1c2goW3BhcmVudCwgaywgdmFsXSk7XG4gICAgfVxufVxuZnVuY3Rpb24gZGVjaXJjKHZhbCwgaywgZWRnZUluZGV4LCBzdGFjaywgcGFyZW50LCBkZXB0aCwgb3B0aW9ucykge1xuICAgIGRlcHRoICs9IDE7XG4gICAgdmFyIGk7XG4gICAgaWYgKHR5cGVvZiB2YWwgPT09IFwib2JqZWN0XCIgJiYgdmFsICE9PSBudWxsKSB7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBzdGFjay5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKHN0YWNrW2ldID09PSB2YWwpIHtcbiAgICAgICAgICAgICAgICBzZXRSZXBsYWNlKENJUkNVTEFSX1JFUExBQ0VfTk9ERSwgdmFsLCBrLCBwYXJlbnQpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMuZGVwdGhMaW1pdCAhPT0gXCJ1bmRlZmluZWRcIiAmJlxuICAgICAgICAgICAgZGVwdGggPiBvcHRpb25zLmRlcHRoTGltaXQpIHtcbiAgICAgICAgICAgIHNldFJlcGxhY2UoTElNSVRfUkVQTEFDRV9OT0RFLCB2YWwsIGssIHBhcmVudCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLmVkZ2VzTGltaXQgIT09IFwidW5kZWZpbmVkXCIgJiZcbiAgICAgICAgICAgIGVkZ2VJbmRleCArIDEgPiBvcHRpb25zLmVkZ2VzTGltaXQpIHtcbiAgICAgICAgICAgIHNldFJlcGxhY2UoTElNSVRfUkVQTEFDRV9OT0RFLCB2YWwsIGssIHBhcmVudCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgc3RhY2sucHVzaCh2YWwpO1xuICAgICAgICAvLyBPcHRpbWl6ZSBmb3IgQXJyYXlzLiBCaWcgYXJyYXlzIGNvdWxkIGtpbGwgdGhlIHBlcmZvcm1hbmNlIG90aGVyd2lzZSFcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsKSkge1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHZhbC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGRlY2lyYyh2YWxbaV0sIGksIGksIHN0YWNrLCB2YWwsIGRlcHRoLCBvcHRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXModmFsKTtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgICAgICAgICAgICAgZGVjaXJjKHZhbFtrZXldLCBrZXksIGksIHN0YWNrLCB2YWwsIGRlcHRoLCBvcHRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzdGFjay5wb3AoKTtcbiAgICB9XG59XG4vLyBTdGFibGUtc3RyaW5naWZ5XG5mdW5jdGlvbiBjb21wYXJlRnVuY3Rpb24oYSwgYikge1xuICAgIGlmIChhIDwgYikge1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgfVxuICAgIGlmIChhID4gYikge1xuICAgICAgICByZXR1cm4gMTtcbiAgICB9XG4gICAgcmV0dXJuIDA7XG59XG5mdW5jdGlvbiBkZXRlcm1pbmlzdGljU3RyaW5naWZ5KG9iaiwgcmVwbGFjZXIsIHNwYWNlciwgb3B0aW9ucykge1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICBvcHRpb25zID0gZGVmYXVsdE9wdGlvbnMoKTtcbiAgICB9XG4gICAgdmFyIHRtcCA9IGRldGVybWluaXN0aWNEZWNpcmMob2JqLCBcIlwiLCAwLCBbXSwgdW5kZWZpbmVkLCAwLCBvcHRpb25zKSB8fCBvYmo7XG4gICAgdmFyIHJlcztcbiAgICB0cnkge1xuICAgICAgICBpZiAocmVwbGFjZXJTdGFjay5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJlcyA9IEpTT04uc3RyaW5naWZ5KHRtcCwgcmVwbGFjZXIsIHNwYWNlcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXMgPSBKU09OLnN0cmluZ2lmeSh0bXAsIHJlcGxhY2VHZXR0ZXJWYWx1ZXMocmVwbGFjZXIpLCBzcGFjZXIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNhdGNoIChfKSB7XG4gICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShcIlt1bmFibGUgdG8gc2VyaWFsaXplLCBjaXJjdWxhciByZWZlcmVuY2UgaXMgdG9vIGNvbXBsZXggdG8gYW5hbHl6ZV1cIik7XG4gICAgfVxuICAgIGZpbmFsbHkge1xuICAgICAgICAvLyBFbnN1cmUgdGhhdCB3ZSByZXN0b3JlIHRoZSBvYmplY3QgYXMgaXQgd2FzLlxuICAgICAgICB3aGlsZSAoYXJyLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgICAgdmFyIHBhcnQgPSBhcnIucG9wKCk7XG4gICAgICAgICAgICBpZiAocGFydC5sZW5ndGggPT09IDQpIHtcbiAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocGFydFswXSwgcGFydFsxXSwgcGFydFszXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBwYXJ0WzBdW3BhcnRbMV1dID0gcGFydFsyXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufVxuZnVuY3Rpb24gZGV0ZXJtaW5pc3RpY0RlY2lyYyh2YWwsIGssIGVkZ2VJbmRleCwgc3RhY2ssIHBhcmVudCwgZGVwdGgsIG9wdGlvbnMpIHtcbiAgICBkZXB0aCArPSAxO1xuICAgIHZhciBpO1xuICAgIGlmICh0eXBlb2YgdmFsID09PSBcIm9iamVjdFwiICYmIHZhbCAhPT0gbnVsbCkge1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgc3RhY2subGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChzdGFja1tpXSA9PT0gdmFsKSB7XG4gICAgICAgICAgICAgICAgc2V0UmVwbGFjZShDSVJDVUxBUl9SRVBMQUNFX05PREUsIHZhbCwgaywgcGFyZW50KTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsLnRvSlNPTiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChfKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLmRlcHRoTGltaXQgIT09IFwidW5kZWZpbmVkXCIgJiZcbiAgICAgICAgICAgIGRlcHRoID4gb3B0aW9ucy5kZXB0aExpbWl0KSB7XG4gICAgICAgICAgICBzZXRSZXBsYWNlKExJTUlUX1JFUExBQ0VfTk9ERSwgdmFsLCBrLCBwYXJlbnQpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5lZGdlc0xpbWl0ICE9PSBcInVuZGVmaW5lZFwiICYmXG4gICAgICAgICAgICBlZGdlSW5kZXggKyAxID4gb3B0aW9ucy5lZGdlc0xpbWl0KSB7XG4gICAgICAgICAgICBzZXRSZXBsYWNlKExJTUlUX1JFUExBQ0VfTk9ERSwgdmFsLCBrLCBwYXJlbnQpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHN0YWNrLnB1c2godmFsKTtcbiAgICAgICAgLy8gT3B0aW1pemUgZm9yIEFycmF5cy4gQmlnIGFycmF5cyBjb3VsZCBraWxsIHRoZSBwZXJmb3JtYW5jZSBvdGhlcndpc2UhXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbCkpIHtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCB2YWwubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBkZXRlcm1pbmlzdGljRGVjaXJjKHZhbFtpXSwgaSwgaSwgc3RhY2ssIHZhbCwgZGVwdGgsIG9wdGlvbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gQ3JlYXRlIGEgdGVtcG9yYXJ5IG9iamVjdCBpbiB0aGUgcmVxdWlyZWQgd2F5XG4gICAgICAgICAgICB2YXIgdG1wID0ge307XG4gICAgICAgICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHZhbCkuc29ydChjb21wYXJlRnVuY3Rpb24pO1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgICAgICAgICBkZXRlcm1pbmlzdGljRGVjaXJjKHZhbFtrZXldLCBrZXksIGksIHN0YWNrLCB2YWwsIGRlcHRoLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICB0bXBba2V5XSA9IHZhbFtrZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBwYXJlbnQgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgICAgICBhcnIucHVzaChbcGFyZW50LCBrLCB2YWxdKTtcbiAgICAgICAgICAgICAgICBwYXJlbnRba10gPSB0bXA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdG1wO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHN0YWNrLnBvcCgpO1xuICAgIH1cbn1cbi8vIHdyYXBzIHJlcGxhY2VyIGZ1bmN0aW9uIHRvIGhhbmRsZSB2YWx1ZXMgd2UgY291bGRuJ3QgcmVwbGFjZVxuLy8gYW5kIG1hcmsgdGhlbSBhcyByZXBsYWNlZCB2YWx1ZVxuZnVuY3Rpb24gcmVwbGFjZUdldHRlclZhbHVlcyhyZXBsYWNlcikge1xuICAgIHJlcGxhY2VyID1cbiAgICAgICAgdHlwZW9mIHJlcGxhY2VyICE9PSBcInVuZGVmaW5lZFwiXG4gICAgICAgICAgICA/IHJlcGxhY2VyXG4gICAgICAgICAgICA6IGZ1bmN0aW9uIChrLCB2KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHY7XG4gICAgICAgICAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoa2V5LCB2YWwpIHtcbiAgICAgICAgaWYgKHJlcGxhY2VyU3RhY2subGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZXBsYWNlclN0YWNrLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBhcnQgPSByZXBsYWNlclN0YWNrW2ldO1xuICAgICAgICAgICAgICAgIGlmIChwYXJ0WzFdID09PSBrZXkgJiYgcGFydFswXSA9PT0gdmFsKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbCA9IHBhcnRbMl07XG4gICAgICAgICAgICAgICAgICAgIHJlcGxhY2VyU3RhY2suc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcGxhY2VyLmNhbGwodGhpcywga2V5LCB2YWwpO1xuICAgIH07XG59XG4iXSwibmFtZXMiOlsiTElNSVRfUkVQTEFDRV9OT0RFIiwiQ0lSQ1VMQVJfUkVQTEFDRV9OT0RFIiwicmVzdWx0IiwiYXJyIiwicmVwbGFjZXJTdGFjayIsImVuY29kZXIiLCJUZXh0RW5jb2RlciIsImRlZmF1bHRPcHRpb25zIiwiZGVwdGhMaW1pdCIsIk51bWJlciIsIk1BWF9TQUZFX0lOVEVHRVIiLCJlZGdlc0xpbWl0IiwiZW5jb2RlU3RyaW5nIiwic3RyIiwiZW5jb2RlIiwic2VyaWFsaXplIiwib2JqIiwicmVwbGFjZXIiLCJzcGFjZXIiLCJvcHRpb25zIiwiSlNPTiIsInN0cmluZ2lmeSIsImUiLCJtZXNzYWdlIiwiaW5jbHVkZXMiLCJjb25zb2xlIiwid2FybiIsImRlY2lyYyIsInVuZGVmaW5lZCIsInJlcyIsImxlbmd0aCIsInJlcGxhY2VHZXR0ZXJWYWx1ZXMiLCJfIiwicGFydCIsInBvcCIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5Iiwic2V0UmVwbGFjZSIsInJlcGxhY2UiLCJ2YWwiLCJrIiwicGFyZW50IiwicHJvcGVydHlEZXNjcmlwdG9yIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwiZ2V0IiwiY29uZmlndXJhYmxlIiwidmFsdWUiLCJwdXNoIiwiZWRnZUluZGV4Iiwic3RhY2siLCJkZXB0aCIsImkiLCJBcnJheSIsImlzQXJyYXkiLCJrZXlzIiwia2V5IiwiY29tcGFyZUZ1bmN0aW9uIiwiYSIsImIiLCJkZXRlcm1pbmlzdGljU3RyaW5naWZ5IiwidG1wIiwiZGV0ZXJtaW5pc3RpY0RlY2lyYyIsInRvSlNPTiIsInNvcnQiLCJ2Iiwic3BsaWNlIiwiY2FsbCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/langsmith/dist/utils/fast-safe-stringify/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/langsmith/dist/utils/messages.js":
/*!*******************************************************!*\
  !*** ./node_modules/langsmith/dist/utils/messages.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   convertLangChainMessageToExample: () => (/* binding */ convertLangChainMessageToExample),\n/* harmony export */   isLangChainMessage: () => (/* binding */ isLangChainMessage)\n/* harmony export */ });\nfunction isLangChainMessage(// eslint-disable-next-line @typescript-eslint/no-explicit-any\nmessage) {\n    return typeof message?._getType === \"function\";\n}\nfunction convertLangChainMessageToExample(message) {\n    const converted = {\n        type: message._getType(),\n        data: {\n            content: message.content\n        }\n    };\n    // Check for presence of keys in additional_kwargs\n    if (message?.additional_kwargs && Object.keys(message.additional_kwargs).length > 0) {\n        converted.data.additional_kwargs = {\n            ...message.additional_kwargs\n        };\n    }\n    return converted;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL2Rpc3QvdXRpbHMvbWVzc2FnZXMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBTyxTQUFTQSxtQkFDaEIsOERBQThEO0FBQzlEQyxPQUFPO0lBQ0gsT0FBTyxPQUFPQSxTQUFTQyxhQUFhO0FBQ3hDO0FBQ08sU0FBU0MsaUNBQWlDRixPQUFPO0lBQ3BELE1BQU1HLFlBQVk7UUFDZEMsTUFBTUosUUFBUUMsUUFBUTtRQUN0QkksTUFBTTtZQUFFQyxTQUFTTixRQUFRTSxPQUFPO1FBQUM7SUFDckM7SUFDQSxrREFBa0Q7SUFDbEQsSUFBSU4sU0FBU08scUJBQ1RDLE9BQU9DLElBQUksQ0FBQ1QsUUFBUU8saUJBQWlCLEVBQUVHLE1BQU0sR0FBRyxHQUFHO1FBQ25EUCxVQUFVRSxJQUFJLENBQUNFLGlCQUFpQixHQUFHO1lBQUUsR0FBR1AsUUFBUU8saUJBQWlCO1FBQUM7SUFDdEU7SUFDQSxPQUFPSjtBQUNYIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYWktbWFya2V0LXJlc2VhcmNoLWFnZW50Ly4vbm9kZV9tb2R1bGVzL2xhbmdzbWl0aC9kaXN0L3V0aWxzL21lc3NhZ2VzLmpzPzQ3M2EiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGZ1bmN0aW9uIGlzTGFuZ0NoYWluTWVzc2FnZShcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG5tZXNzYWdlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBtZXNzYWdlPy5fZ2V0VHlwZSA9PT0gXCJmdW5jdGlvblwiO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGNvbnZlcnRMYW5nQ2hhaW5NZXNzYWdlVG9FeGFtcGxlKG1lc3NhZ2UpIHtcbiAgICBjb25zdCBjb252ZXJ0ZWQgPSB7XG4gICAgICAgIHR5cGU6IG1lc3NhZ2UuX2dldFR5cGUoKSxcbiAgICAgICAgZGF0YTogeyBjb250ZW50OiBtZXNzYWdlLmNvbnRlbnQgfSxcbiAgICB9O1xuICAgIC8vIENoZWNrIGZvciBwcmVzZW5jZSBvZiBrZXlzIGluIGFkZGl0aW9uYWxfa3dhcmdzXG4gICAgaWYgKG1lc3NhZ2U/LmFkZGl0aW9uYWxfa3dhcmdzICYmXG4gICAgICAgIE9iamVjdC5rZXlzKG1lc3NhZ2UuYWRkaXRpb25hbF9rd2FyZ3MpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgY29udmVydGVkLmRhdGEuYWRkaXRpb25hbF9rd2FyZ3MgPSB7IC4uLm1lc3NhZ2UuYWRkaXRpb25hbF9rd2FyZ3MgfTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbnZlcnRlZDtcbn1cbiJdLCJuYW1lcyI6WyJpc0xhbmdDaGFpbk1lc3NhZ2UiLCJtZXNzYWdlIiwiX2dldFR5cGUiLCJjb252ZXJ0TGFuZ0NoYWluTWVzc2FnZVRvRXhhbXBsZSIsImNvbnZlcnRlZCIsInR5cGUiLCJkYXRhIiwiY29udGVudCIsImFkZGl0aW9uYWxfa3dhcmdzIiwiT2JqZWN0Iiwia2V5cyIsImxlbmd0aCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/langsmith/dist/utils/messages.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/langsmith/dist/utils/prompts.js":
/*!******************************************************!*\
  !*** ./node_modules/langsmith/dist/utils/prompts.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   isVersionGreaterOrEqual: () => (/* binding */ isVersionGreaterOrEqual),\n/* harmony export */   parsePromptIdentifier: () => (/* binding */ parsePromptIdentifier)\n/* harmony export */ });\n/* harmony import */ var semver__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! semver */ \"(rsc)/./node_modules/semver/index.js\");\n\nfunction isVersionGreaterOrEqual(current_version, target_version) {\n    const current = (0,semver__WEBPACK_IMPORTED_MODULE_0__.parse)(current_version);\n    const target = (0,semver__WEBPACK_IMPORTED_MODULE_0__.parse)(target_version);\n    if (!current || !target) {\n        throw new Error(\"Invalid version format.\");\n    }\n    return current.compare(target) >= 0;\n}\nfunction parsePromptIdentifier(identifier) {\n    if (!identifier || identifier.split(\"/\").length > 2 || identifier.startsWith(\"/\") || identifier.endsWith(\"/\") || identifier.split(\":\").length > 2) {\n        throw new Error(`Invalid identifier format: ${identifier}`);\n    }\n    const [ownerNamePart, commitPart] = identifier.split(\":\");\n    const commit = commitPart || \"latest\";\n    if (ownerNamePart.includes(\"/\")) {\n        const [owner, name] = ownerNamePart.split(\"/\", 2);\n        if (!owner || !name) {\n            throw new Error(`Invalid identifier format: ${identifier}`);\n        }\n        return [\n            owner,\n            name,\n            commit\n        ];\n    } else {\n        if (!ownerNamePart) {\n            throw new Error(`Invalid identifier format: ${identifier}`);\n        }\n        return [\n            \"-\",\n            ownerNamePart,\n            commit\n        ];\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL2Rpc3QvdXRpbHMvcHJvbXB0cy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBK0M7QUFDeEMsU0FBU0Usd0JBQXdCQyxlQUFlLEVBQUVDLGNBQWM7SUFDbkUsTUFBTUMsVUFBVUosNkNBQVlBLENBQUNFO0lBQzdCLE1BQU1HLFNBQVNMLDZDQUFZQSxDQUFDRztJQUM1QixJQUFJLENBQUNDLFdBQVcsQ0FBQ0MsUUFBUTtRQUNyQixNQUFNLElBQUlDLE1BQU07SUFDcEI7SUFDQSxPQUFPRixRQUFRRyxPQUFPLENBQUNGLFdBQVc7QUFDdEM7QUFDTyxTQUFTRyxzQkFBc0JDLFVBQVU7SUFDNUMsSUFBSSxDQUFDQSxjQUNEQSxXQUFXQyxLQUFLLENBQUMsS0FBS0MsTUFBTSxHQUFHLEtBQy9CRixXQUFXRyxVQUFVLENBQUMsUUFDdEJILFdBQVdJLFFBQVEsQ0FBQyxRQUNwQkosV0FBV0MsS0FBSyxDQUFDLEtBQUtDLE1BQU0sR0FBRyxHQUFHO1FBQ2xDLE1BQU0sSUFBSUwsTUFBTSxDQUFDLDJCQUEyQixFQUFFRyxXQUFXLENBQUM7SUFDOUQ7SUFDQSxNQUFNLENBQUNLLGVBQWVDLFdBQVcsR0FBR04sV0FBV0MsS0FBSyxDQUFDO0lBQ3JELE1BQU1NLFNBQVNELGNBQWM7SUFDN0IsSUFBSUQsY0FBY0csUUFBUSxDQUFDLE1BQU07UUFDN0IsTUFBTSxDQUFDQyxPQUFPQyxLQUFLLEdBQUdMLGNBQWNKLEtBQUssQ0FBQyxLQUFLO1FBQy9DLElBQUksQ0FBQ1EsU0FBUyxDQUFDQyxNQUFNO1lBQ2pCLE1BQU0sSUFBSWIsTUFBTSxDQUFDLDJCQUEyQixFQUFFRyxXQUFXLENBQUM7UUFDOUQ7UUFDQSxPQUFPO1lBQUNTO1lBQU9DO1lBQU1IO1NBQU87SUFDaEMsT0FDSztRQUNELElBQUksQ0FBQ0YsZUFBZTtZQUNoQixNQUFNLElBQUlSLE1BQU0sQ0FBQywyQkFBMkIsRUFBRUcsV0FBVyxDQUFDO1FBQzlEO1FBQ0EsT0FBTztZQUFDO1lBQUtLO1lBQWVFO1NBQU87SUFDdkM7QUFDSiIsInNvdXJjZXMiOlsid2VicGFjazovL2FpLW1hcmtldC1yZXNlYXJjaC1hZ2VudC8uL25vZGVfbW9kdWxlcy9sYW5nc21pdGgvZGlzdC91dGlscy9wcm9tcHRzLmpzPzc5YjEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgcGFyc2UgYXMgcGFyc2VWZXJzaW9uIH0gZnJvbSBcInNlbXZlclwiO1xuZXhwb3J0IGZ1bmN0aW9uIGlzVmVyc2lvbkdyZWF0ZXJPckVxdWFsKGN1cnJlbnRfdmVyc2lvbiwgdGFyZ2V0X3ZlcnNpb24pIHtcbiAgICBjb25zdCBjdXJyZW50ID0gcGFyc2VWZXJzaW9uKGN1cnJlbnRfdmVyc2lvbik7XG4gICAgY29uc3QgdGFyZ2V0ID0gcGFyc2VWZXJzaW9uKHRhcmdldF92ZXJzaW9uKTtcbiAgICBpZiAoIWN1cnJlbnQgfHwgIXRhcmdldCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHZlcnNpb24gZm9ybWF0LlwiKTtcbiAgICB9XG4gICAgcmV0dXJuIGN1cnJlbnQuY29tcGFyZSh0YXJnZXQpID49IDA7XG59XG5leHBvcnQgZnVuY3Rpb24gcGFyc2VQcm9tcHRJZGVudGlmaWVyKGlkZW50aWZpZXIpIHtcbiAgICBpZiAoIWlkZW50aWZpZXIgfHxcbiAgICAgICAgaWRlbnRpZmllci5zcGxpdChcIi9cIikubGVuZ3RoID4gMiB8fFxuICAgICAgICBpZGVudGlmaWVyLnN0YXJ0c1dpdGgoXCIvXCIpIHx8XG4gICAgICAgIGlkZW50aWZpZXIuZW5kc1dpdGgoXCIvXCIpIHx8XG4gICAgICAgIGlkZW50aWZpZXIuc3BsaXQoXCI6XCIpLmxlbmd0aCA+IDIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGlkZW50aWZpZXIgZm9ybWF0OiAke2lkZW50aWZpZXJ9YCk7XG4gICAgfVxuICAgIGNvbnN0IFtvd25lck5hbWVQYXJ0LCBjb21taXRQYXJ0XSA9IGlkZW50aWZpZXIuc3BsaXQoXCI6XCIpO1xuICAgIGNvbnN0IGNvbW1pdCA9IGNvbW1pdFBhcnQgfHwgXCJsYXRlc3RcIjtcbiAgICBpZiAob3duZXJOYW1lUGFydC5pbmNsdWRlcyhcIi9cIikpIHtcbiAgICAgICAgY29uc3QgW293bmVyLCBuYW1lXSA9IG93bmVyTmFtZVBhcnQuc3BsaXQoXCIvXCIsIDIpO1xuICAgICAgICBpZiAoIW93bmVyIHx8ICFuYW1lKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgaWRlbnRpZmllciBmb3JtYXQ6ICR7aWRlbnRpZmllcn1gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW293bmVyLCBuYW1lLCBjb21taXRdO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaWYgKCFvd25lck5hbWVQYXJ0KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgaWRlbnRpZmllciBmb3JtYXQ6ICR7aWRlbnRpZmllcn1gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW1wiLVwiLCBvd25lck5hbWVQYXJ0LCBjb21taXRdO1xuICAgIH1cbn1cbiJdLCJuYW1lcyI6WyJwYXJzZSIsInBhcnNlVmVyc2lvbiIsImlzVmVyc2lvbkdyZWF0ZXJPckVxdWFsIiwiY3VycmVudF92ZXJzaW9uIiwidGFyZ2V0X3ZlcnNpb24iLCJjdXJyZW50IiwidGFyZ2V0IiwiRXJyb3IiLCJjb21wYXJlIiwicGFyc2VQcm9tcHRJZGVudGlmaWVyIiwiaWRlbnRpZmllciIsInNwbGl0IiwibGVuZ3RoIiwic3RhcnRzV2l0aCIsImVuZHNXaXRoIiwib3duZXJOYW1lUGFydCIsImNvbW1pdFBhcnQiLCJjb21taXQiLCJpbmNsdWRlcyIsIm93bmVyIiwibmFtZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/langsmith/dist/utils/prompts.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/langsmith/dist/utils/warn.js":
/*!***************************************************!*\
  !*** ./node_modules/langsmith/dist/utils/warn.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   warnOnce: () => (/* binding */ warnOnce)\n/* harmony export */ });\nconst warnedMessages = {};\nfunction warnOnce(message) {\n    if (!warnedMessages[message]) {\n        console.warn(message);\n        warnedMessages[message] = true;\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL2Rpc3QvdXRpbHMvd2Fybi5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUEsTUFBTUEsaUJBQWlCLENBQUM7QUFDakIsU0FBU0MsU0FBU0MsT0FBTztJQUM1QixJQUFJLENBQUNGLGNBQWMsQ0FBQ0UsUUFBUSxFQUFFO1FBQzFCQyxRQUFRQyxJQUFJLENBQUNGO1FBQ2JGLGNBQWMsQ0FBQ0UsUUFBUSxHQUFHO0lBQzlCO0FBQ0oiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9haS1tYXJrZXQtcmVzZWFyY2gtYWdlbnQvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL2Rpc3QvdXRpbHMvd2Fybi5qcz8wMmQwIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IHdhcm5lZE1lc3NhZ2VzID0ge307XG5leHBvcnQgZnVuY3Rpb24gd2Fybk9uY2UobWVzc2FnZSkge1xuICAgIGlmICghd2FybmVkTWVzc2FnZXNbbWVzc2FnZV0pIHtcbiAgICAgICAgY29uc29sZS53YXJuKG1lc3NhZ2UpO1xuICAgICAgICB3YXJuZWRNZXNzYWdlc1ttZXNzYWdlXSA9IHRydWU7XG4gICAgfVxufVxuIl0sIm5hbWVzIjpbIndhcm5lZE1lc3NhZ2VzIiwid2Fybk9uY2UiLCJtZXNzYWdlIiwiY29uc29sZSIsIndhcm4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/langsmith/dist/utils/warn.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/langsmith/index.js":
/*!*****************************************!*\
  !*** ./node_modules/langsmith/index.js ***!
  \*****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Client: () => (/* reexport safe */ _dist_index_js__WEBPACK_IMPORTED_MODULE_0__.Client),\n/* harmony export */   RunTree: () => (/* reexport safe */ _dist_index_js__WEBPACK_IMPORTED_MODULE_0__.RunTree),\n/* harmony export */   __version__: () => (/* reexport safe */ _dist_index_js__WEBPACK_IMPORTED_MODULE_0__.__version__),\n/* harmony export */   overrideFetchImplementation: () => (/* reexport safe */ _dist_index_js__WEBPACK_IMPORTED_MODULE_0__.overrideFetchImplementation)\n/* harmony export */ });\n/* harmony import */ var _dist_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dist/index.js */ \"(rsc)/./node_modules/langsmith/dist/index.js\");\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQStCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYWktbWFya2V0LXJlc2VhcmNoLWFnZW50Ly4vbm9kZV9tb2R1bGVzL2xhbmdzbWl0aC9pbmRleC5qcz8xODFiIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCAqIGZyb20gJy4vZGlzdC9pbmRleC5qcyciXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/langsmith/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/langsmith/run_trees.js":
/*!*********************************************!*\
  !*** ./node_modules/langsmith/run_trees.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   RunTree: () => (/* reexport safe */ _dist_run_trees_js__WEBPACK_IMPORTED_MODULE_0__.RunTree),\n/* harmony export */   convertToDottedOrderFormat: () => (/* reexport safe */ _dist_run_trees_js__WEBPACK_IMPORTED_MODULE_0__.convertToDottedOrderFormat),\n/* harmony export */   isRunTree: () => (/* reexport safe */ _dist_run_trees_js__WEBPACK_IMPORTED_MODULE_0__.isRunTree),\n/* harmony export */   isRunnableConfigLike: () => (/* reexport safe */ _dist_run_trees_js__WEBPACK_IMPORTED_MODULE_0__.isRunnableConfigLike)\n/* harmony export */ });\n/* harmony import */ var _dist_run_trees_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dist/run_trees.js */ \"(rsc)/./node_modules/langsmith/dist/run_trees.js\");\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL3J1bl90cmVlcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFtQyIsInNvdXJjZXMiOlsid2VicGFjazovL2FpLW1hcmtldC1yZXNlYXJjaC1hZ2VudC8uL25vZGVfbW9kdWxlcy9sYW5nc21pdGgvcnVuX3RyZWVzLmpzPzA1MmEiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0ICogZnJvbSAnLi9kaXN0L3J1bl90cmVlcy5qcyciXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/langsmith/run_trees.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/langsmith/singletons/traceable.js":
/*!********************************************************!*\
  !*** ./node_modules/langsmith/singletons/traceable.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AsyncLocalStorageProviderSingleton: () => (/* reexport safe */ _dist_singletons_traceable_js__WEBPACK_IMPORTED_MODULE_0__.AsyncLocalStorageProviderSingleton),\n/* harmony export */   ROOT: () => (/* reexport safe */ _dist_singletons_traceable_js__WEBPACK_IMPORTED_MODULE_0__.ROOT),\n/* harmony export */   getCurrentRunTree: () => (/* reexport safe */ _dist_singletons_traceable_js__WEBPACK_IMPORTED_MODULE_0__.getCurrentRunTree),\n/* harmony export */   isTraceableFunction: () => (/* reexport safe */ _dist_singletons_traceable_js__WEBPACK_IMPORTED_MODULE_0__.isTraceableFunction),\n/* harmony export */   withRunTree: () => (/* reexport safe */ _dist_singletons_traceable_js__WEBPACK_IMPORTED_MODULE_0__.withRunTree)\n/* harmony export */ });\n/* harmony import */ var _dist_singletons_traceable_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../dist/singletons/traceable.js */ \"(rsc)/./node_modules/langsmith/dist/singletons/traceable.js\");\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL3NpbmdsZXRvbnMvdHJhY2VhYmxlLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUErQyIsInNvdXJjZXMiOlsid2VicGFjazovL2FpLW1hcmtldC1yZXNlYXJjaC1hZ2VudC8uL25vZGVfbW9kdWxlcy9sYW5nc21pdGgvc2luZ2xldG9ucy90cmFjZWFibGUuanM/MjZmNiJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgKiBmcm9tICcuLi9kaXN0L3NpbmdsZXRvbnMvdHJhY2VhYmxlLmpzJyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/langsmith/singletons/traceable.js\n");

/***/ })

};
;